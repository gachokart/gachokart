<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>game1 — Аналітика і закономірності</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{--bg:#0b1220;--card:#09111a;--muted:#9aa7bd;--accent:#1f8feb}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#071027 0%,#07111b 100%);color:#e6eef6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
    .wrap{max-width:1100px;width:100%}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    input,button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:9px;border-radius:8px;color:inherit}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);text-align:left}
    .meta{font-size:13px;color:var(--muted)}
    .prediction{padding:12px;border-radius:10px;margin-bottom:10px}
    .pred-good{background:linear-gradient(90deg,#063b12,#0d6430);color:#dfffe0}
    .pred-bad{background:linear-gradient(90deg,#3b0606,#641010);color:#ffe0e0}
    .pred-neutral{background:linear-gradient(90deg,#2a2a3b,#3b3b5a);color:#fff}
    .reason{font-size:13px;margin:6px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    #patterns{display:none;margin-top:12px}
    .charts{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .hero-list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .hero-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hero-item img{width:48px;height:28px;object-fit:cover;border-radius:4px}
    @media (max-width:920px){.grid{grid-template-columns:1fr} .charts{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="flex:1;display:flex;align-items:center;justify-content:space-between;padding:12px">
        <div>
          <h1>game1 — Прогноз + Закономірності</h1>
          <div class="small">OpenDota аналіз останніх ігор → прогноз, закономірності, графіки, топ-3 героїв.</div>
        </div>
        <div class="small">Тестовий ID: <strong>863386335</strong></div>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;flex-direction:column">
        <label>Steam64 ID або OpenDota account_id:</label>
        <div class="inputs">
          <input id="idInput" placeholder="Steam64 або account_id" />
          <select id="limitSelect">
            <option value="20">Останні 20 ігор</option>
            <option value="50">Останні 50 ігор</option>
            <option value="100">Останні 100 ігор</option>
          </select>
          <button id="fetchBtn">Отримати прогноз</button>
          <button id="patternsBtn">Показати закономірності</button>
          <button id="demoBtn">Тестовий ID</button>
        </div>
        <div class="small" style="margin-top:8px">Натисни «Показати закономірності» після отримання прогнозу — побудуються графіки winrate по днях і годинах і виявляться повторювані патерни.</div>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="leftCard">
        <h3>Останні матчі</h3>
        <div id="statsSummary" class="meta"></div>
        <div style="margin-top:8px;max-height:420px;overflow:auto">
          <table id="matchesTable">
            <thead><tr><th>Дата</th><th>Герой</th><th>K/D/A</th><th>Результат</th><th>Тривалість</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <aside class="card" id="rightCard">
        <h3>Прогноз на наступний матч</h3>
        <div id="predictionArea" class="prediction pred-neutral">Очікування...</div>
        <div id="predictionDetails" class="meta"></div>
        <div id="patterns" class="meta card">
          <h4>Закономірності матчів</h4>
          <div class="charts">
            <canvas id="chartDays" width="400" height="200"></canvas>
            <canvas id="chartHours" width="400" height="200"></canvas>
          </div>
          <div id="patternText" style="margin-top:10px"></div>
          <h4 style="margin-top:10px">Топ-3 герої</h4>
          <div id="topHeroes" class="hero-list"></div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // ---- Утиліти
    function steam64ToAccountId(steam64){ try{ const n=BigInt(steam64); const base=BigInt('76561197960265728'); if(n<=BigInt(4294967295)) return Number(n); return Number(n-base);}catch(e){return NaN} }
    function playerWon(m){ const playerRadiant = (m.player_slot||0) < 128; return (playerRadiant && m.radiant_win) || (!playerRadiant && !m.radiant_win); }
    function secsToMinSecs(s){ const m=Math.floor(s/60), sec=s%60; return m+':'+String(sec).padStart(2,'0'); }

    async function fetchOpenDotaMatches(id,limit){ const url=`https://api.opendota.com/api/players/${id}/matches?limit=${limit}`; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota matches fetch failed: '+res.status); return res.json(); }
    async function fetchHeroesConstants(){ const url='https://api.opendota.com/api/constants/heroes'; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota heroes fetch failed'); return res.json(); }

    // ---- Аналіз
    function analyzeMatches(matches){
      const out={games:matches.length,wins:0,k:0,d:0,a:0,dur:0,shortWins:0,shortLosses:0,longWins:0,longLosses:0,leaves:0,byHero:{},seq:[]};
      for(const m of matches){ const won=playerWon(m); out.seq.push(won?'W':'L'); if(won) out.wins++; const kills=m.kills||0,deaths=m.deaths||0,assists=m.assists||0,duration=m.duration||0; out.k+=kills; out.d+=deaths; out.a+=assists; out.dur+=duration; if(duration<1500 && won) out.shortWins++; if(duration<1500 && !won) out.shortLosses++; if(duration>2700 && won) out.longWins++; if(duration>2700 && !won) out.longLosses++; if(m.leaver_status && m.leaver_status!==0) out.leaves++; const hid=m.hero_id||0; if(!out.byHero[hid]) out.byHero[hid]={games:0,wins:0}; out.byHero[hid].games++; if(won) out.byHero[hid].wins++; }
      out.winrate=out.games? out.wins/out.games*100:0; out.avgK=out.games? out.k/out.games:0; out.avgD=out.games? out.d/out.games:0; out.avgA=out.games? out.a/out.games:0; out.avgKDA=out.avgD? (out.avgK+out.avgA)/out.avgD: (out.avgK+out.avgA); out.avgDuration=out.games? out.dur/out.games:0; out.pctShortWins=out.games? out.shortWins/out.games*100:0; out.pctShortLosses=out.games? out.shortLosses/out.games*100:0; out.pctLongWins=out.games? out.longWins/out.games*100:0; out.pctLongLosses=out.games? out.longLosses/out.games*100:0; out.leaveRate=out.games? out.leaves/out.games*100:0; return out; }

    // ---- Прогноз (як раніше, трохи вдосконалено)
    function computeDetailedProbabilities(summary){
      let winProb=50; const reasons=[];
      winProb += (summary.winrate-50)*0.9; reasons.push(`Winrate ${summary.winrate.toFixed(1)}% → ${( (summary.winrate-50)*0.9).toFixed(1)}%`);
      winProb += (summary.avgKDA-2)*6; reasons.push(`Avg KDA ${summary.avgKDA.toFixed(2)} → ${( (summary.avgKDA-2)*6).toFixed(1)}%`);
      if(summary.avgDuration<1200){ winProb -= 3; reasons.push(`Короткі ігри (avg ${Math.round(summary.avgDuration/60)} хв) → -3%`); }
      if(summary.pctShortLosses>20){ winProb -= 4; reasons.push(`Короткі поразки ${summary.pctShortLosses.toFixed(1)}% → -4%`); }
      if(summary.leaveRate>5){ const v=Math.min(10,Math.round(summary.leaveRate)); winProb -= v; reasons.push(`Leave rate ${summary.leaveRate.toFixed(1)}% → -${v}%`); }
      winProb = Math.max(3, Math.min(97, Math.round(winProb)));
      const predictedLength = Math.round(summary.avgDuration * (0.95 + Math.max(-0.1, Math.min(0.1, (summary.pctShortWins - summary.pctShortLosses)/100))));
      // boosters/ruiners heuristics
      function clamp(v){ return Math.max(1, Math.min(95, Math.round(v))); }
      let boosterMy=5, ruinerMy=5, boosterEnemy=5, ruinerEnemy=5;
      if(summary.avgKDA>3.5){ const add=Math.round((summary.avgKDA-3.5)*8); boosterMy += add; }
      if(summary.pctShortWins>20){ boosterMy += Math.round((summary.pctShortWins-20)/2); }
      if(summary.winrate>60){ boosterMy += Math.round((summary.winrate-60)/1.5); }
      if(summary.avgD>7){ ruinerMy += Math.round((summary.avgD-7)*4); }
      if(summary.pctShortLosses>15){ ruinerMy += Math.round((summary.pctShortLosses-15)/1.5); }
      if(summary.leaveRate>3){ ruinerMy += Math.round(summary.leaveRate); }
      if(summary.pctShortLosses>20){ boosterEnemy += Math.round((summary.pctShortLosses-20)/1.2); }
      if(summary.pctLongWins>15){ ruinerEnemy += Math.round((summary.pctLongWins-15)/1.2); }
      if(summary.pctLongLosses>12){ ruinerEnemy += Math.round((summary.pctLongLosses-12)/1.1); }
      if(summary.leaveRate>6){ boosterEnemy+=3; ruinerEnemy+=3; }
      boosterMy=clamp(boosterMy); ruinerMy=clamp(ruinerMy); boosterEnemy=clamp(boosterEnemy); ruinerEnemy=clamp(ruinerEnemy);
      // prepare reasons list (short)
      // We'll include full reasons in detailed patterns
      return {winProb,predictedLength,boosterMy,ruinerMy,boosterEnemy,ruinerEnemy,reasons};
    }

    // ---- Патерни: дні/години/послідовності
    function analyzePatterns(matches, summary, heroesConst){
      // days and hours winrate
      const days = Array(7).fill(0).map(()=>({games:0,wins:0}));
      const hours = Array(24).fill(0).map(()=>({games:0,wins:0}));
      for(const m of matches){ const d = new Date((m.start_time||0)*1000); const dow = d.getDay(); const h = d.getHours(); const won=playerWon(m); days[dow].games++; if(won) days[dow].wins++; hours[h].games++; if(won) hours[h].wins++; }
      const dayRates = days.map((x,i)=>({day:i,winrate: x.games? x.wins/x.games*100:0,games:x.games}));
      const hourRates = hours.map((x,h)=>({hour:h,winrate: x.games? x.wins/x.games*100:0,games:x.games}));

      // sequences patterns: check n losses followed by win frequency
      const seq = summary.seq; const seqPatterns = [];
      for(let n=1;n<=5;n++){
        let total=0,afterWin=0;
        for(let i=0;i+ n < seq.length;i++){
          let ok=true; for(let j=0;j<n;j++){ if(seq[i+j] !== 'L'){ ok=false; break; } }
          if(ok){ total++; if(seq[i+n] === 'W') afterWin++; }
        }
        if(total>0) seqPatterns.push({n, total, afterWin, prob: Math.round(afterWin/total*100)});
      }

      // short/long duration pattern
      const shortGames = matches.filter(m=> (m.duration||0) < 1500);
      const longGames = matches.filter(m=> (m.duration||0) > 2700);
      const shortWinrate = shortGames.length? shortGames.filter(playerWon).length/shortGames.length*100:0;
      const longWinrate = longGames.length? longGames.filter(playerWon).length/longGames.length*100:0;

      // top 3 heroes by winrate (require min games threshold 2)
      const heroes = Object.entries(summary.byHero).map(([hid,st])=>({hero_id: Number(hid), games:st.games, wins:st.wins, winrate: st.games? st.wins/st.games*100:0}));
      heroes.sort((a,b)=>{ if(b.winrate!==a.winrate) return b.winrate-a.winrate; return b.games-a.games; });
      const top3 = heroes.filter(h=>h.games>=2).slice(0,3);
      // map hero data via heroesConst
      const top3Mapped = top3.map(h=>{
        const c = heroesConst[h.hero_id]; // note: constants use hero_id as keys (string)
        const img = c && c.img? 'https://api.opendota.com'+c.img : null;
        const name = c && c.localized_name? c.localized_name : `hero_${h.hero_id}`;
        return {...h, name, img};
      });

      return {dayRates, hourRates, seqPatterns, shortWinrate, longWinrate, top3: top3Mapped};
    }

    // ---- Рендер UI
    function renderMatches(matches, heroesConst){ const tbody=document.querySelector('#matchesTable tbody'); tbody.innerHTML=''; matches.forEach(m=>{ const tr=document.createElement('tr'); const d=new Date((m.start_time||0)*1000); const hid=m.hero_id||0; const heroName = heroesConst && heroesConst[hid] ? heroesConst[hid].localized_name : hid; tr.innerHTML=`<td>${d.toLocaleString()}</td><td>${heroName}</td><td>${m.kills||0}/${m.deaths||0}/${m.assists||0}</td><td>${playerWon(m)?'W':'L'}</td><td>${secsToMinSecs(m.duration||0)}</td>`; tbody.appendChild(tr); }); }

    function renderPredictionUI(summary, result){ document.getElementById('statsSummary').innerText = `Ігор: ${summary.games} · Winrate: ${summary.winrate.toFixed(1)}% · Avg K/D/A: ${summary.avgK.toFixed(2)}/${summary.avgD.toFixed(2)}/${summary.avgA.toFixed(2)} · Avg KDA: ${summary.avgKDA.toFixed(2)} · Avg тривалість: ${Math.round(summary.avgDuration/60)} хв`;
      const p=document.getElementById('predictionArea'); p.className='prediction '+(result.winProb>60?'pred-good':result.winProb<40?'pred-bad':'pred-neutral'); p.innerHTML=`<strong>Ймовірність перемоги: ${result.winProb}%</strong><div class="small">Прогнозована довжина: ${Math.round(result.predictedLength/60)} хв</div>`;
      const det=document.getElementById('predictionDetails'); det.innerHTML=`<div class="reason"><strong>Шанси</strong><div class="small">Бустер (мої): ${result.boosterMy}% · Руінер (мої): ${result.ruinerMy}%<br>Бустер (ворог): ${result.boosterEnemy}% · Руінер (ворог): ${result.ruinerEnemy}%</div></div>`;
    }

    // ---- Побудова графіків через Chart.js
    let chartDays=null, chartHours=null;
    function buildCharts(dayRates, hourRates){ const daysLabels=['Нд','Пн','Вт','Ср','Чт','Пт','Сб']; const dayData = dayRates.map(d=>+d.winrate.toFixed(1)); const hourLabels = hourRates.map(h=>h.hour); const hourData = hourRates.map(h=>+h.winrate.toFixed(1));
      const ctxD = document.getElementById('chartDays').getContext('2d'); if(chartDays) chartDays.destroy(); chartDays = new Chart(ctxD,{type:'bar',data:{labels:daysLabels, datasets:[{label:'Winrate %', data:dayData}]}, options:{scales:{y:{beginAtZero:true, max:100}}}});
      const ctxH = document.getElementById('chartHours').getContext('2d'); if(chartHours) chartHours.destroy(); chartHours = new Chart(ctxH,{type:'line',data:{labels:hourLabels, datasets:[{label:'Winrate %', data:hourData, fill:true, tension:0.3}]}, options:{scales:{y:{beginAtZero:true, max:100}}}});
    }

    function renderPatternsUI(patterns){ document.getElementById('patterns').style.display='block'; const pt=document.getElementById('patternText'); pt.innerHTML='';
      // sequence patterns
      const seqRoot=document.createElement('div'); seqRoot.innerHTML='<strong>Послідовності W/L</strong>';
      patterns.seqPatterns.forEach(p=>{ const div=document.createElement('div'); div.className='reason'; div.textContent = `Після ${p.n} поразок поспіль (${p.total} випадків) наступна гра була перемогою у ${p.prob}% випадків.`; seqRoot.appendChild(div); });
      pt.appendChild(seqRoot);
      // short/long
      const durRoot=document.createElement('div'); durRoot.innerHTML='<strong>Тривалість і winrate</strong>';
      durRoot.appendChild(Object.assign(document.createElement('div'),{className:'reason',textContent:`Короткі ігри (<25хв) winrate: ${patterns.shortWinrate?patterns.shortWinrate.toFixed(1):0}%` }));
      durRoot.appendChild(Object.assign(document.createElement('div'),{className:'reason',textContent:`Довгі ігри (>45хв) winrate: ${patterns.longWinrate?patterns.longWinrate.toFixed(1):0}%` }));
      pt.appendChild(durRoot);
      // top heroes
      const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML=''; if(patterns.top3.length===0){ topRoot.innerHTML='<div class="small">Недостатньо ігор на героях (min 2)</div>'; } else { patterns.top3.forEach(h=>{ const el=document.createElement('div'); el.className='hero-item'; const img=document.createElement('img'); img.src = h.img || ''; img.alt=h.name; const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% · Ігор: ${h.games}</div>`; el.appendChild(img); el.appendChild(info); topRoot.appendChild(el); }); }
    }

    // ---- Пошук закономірностей за днями/годинами та рендер
    async function showPatterns(matches, summary, heroesConst){ const analysis = analyzePatterns(matches, summary, heroesConst); buildCharts(analysis.dayRates, analysis.hourRates); renderPatternsUI(analysis); }

    // ---- Події кнопок
    let lastMatches=null, lastSummary=null, lastHeroesConst=null;
    document.getElementById('demoBtn').addEventListener('click', ()=>{ document.getElementById('idInput').value='863386335'; });

    document.getElementById('fetchBtn').addEventListener('click', async ()=>{
      const raw=document.getElementById('idInput').value.trim(); if(!raw) return alert('Введіть ID'); const id = raw.length>12? steam64ToAccountId(raw): Number(raw); if(isNaN(id)) return alert('Не вдалося розпізнати ID'); const limit = Number(document.getElementById('limitSelect').value);
      document.getElementById('predictionArea').textContent='Завантаження...';
      try{
        const [matches, heroesConstRaw] = await Promise.all([ fetchOpenDotaMatches(id, limit), fetchHeroesConstants() ]);
        // normalize heroesConst into map by hero_id (OpenDota constants keys are names, values have 'id')
        const heroesConst = {};
        Object.values(heroesConstRaw).forEach(h=>{ if(h.id!==undefined) heroesConst[h.id]=h; });
        lastMatches = matches; lastSummary = analyzeMatches(matches); lastHeroesConst = heroesConst;
        const pred = computeDetailedProbabilities(lastSummary);
        renderMatches(matches, heroesConst);
        renderPredictionUI(lastSummary, pred);
        // hide patterns until user presses button
        document.getElementById('patterns').style.display='none';
      }catch(err){ console.error(err); document.getElementById('predictionArea').textContent='Помилка: '+err.message; }
    });

    document.getElementById('patternsBtn').addEventListener('click', async ()=>{
      if(!lastMatches || !lastSummary){ alert('Спочатку отримайте прогноз (натисніть "Отримати прогноз").'); return; }
      try{ await showPatterns(lastMatches, lastSummary, lastHeroesConst); }catch(err){ console.error(err); alert('Проблема при побудові закономірностей: '+err.message); }
    });

  </script>
</body>
</html>

