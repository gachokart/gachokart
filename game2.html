<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Dota 2 Draft Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f7f9;
      --panel: #fff;
      --border: #ddd;
      --accent: #16a34a;
      --text: #222;
      --muted: #666;
    }
    body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; }
    #app { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    h1 { margin: 0 0 12px; }
    h3 { margin: 0 0 8px; }
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin: 12px 0; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .team { border: 1px dashed var(--border); border-radius: 8px; padding: 10px; }
    .slotRow { display: flex; gap: 8px; flex-wrap: wrap; min-height: 44px; }
    .chip { display: inline-flex; gap: 6px; align-items: center; background: #f9fafb; border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; }
    .chip .rm { cursor: pointer; color: #b00; font-weight: 700; }
    .role-btn { margin: 2px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background:#fff; cursor:pointer; }
    .role-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }
    .suggestion { padding: 6px 8px; border-bottom: 1px solid var(--border); font-size: 13px; display:flex; justify-content:space-between; gap:8px; }
    .tiny { font-size: 12px; color: var(--muted); }
    .analysis-block { margin-top: 6px; font-size: 13px; color: #444; background: #f8f8f8; border: 1px solid #ddd; padding: 6px 8px; border-radius: 6px; }
    .picker { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    select, button { padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border); background:#fff; cursor: pointer; }
    button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    pre { white-space: pre-wrap; }
  </style>
</head>
<body>
  <div id="app">
    <h1>Dota 2 Draft Assistant</h1>

    <!-- Панель вибору ролі -->
    <div class="panel">
      <h3>Оберіть свою роль</h3>
      <div id="rolesContainer"></div>
      <div class="picker">
        <select id="roleFilter"></select>
        <button id="startBtn" class="primary" disabled>Почати драфт</button>
        <div class="tiny">Ваша роль: <span id="playerRoleLabel">—</span></div>
      </div>
    </div>

    <!-- Основний драфт -->
    <div class="panel">
      <div class="grid2">
        <div class="team">
          <h3>Моя команда</h3>
          <div id="myTeam" class="slotRow"></div>
          <div>Winrate: <span id="winrateA">—</span></div>
          <div id="synergyA" class="analysis-block"></div>
          <div class="picker" style="margin-top:8px;">
            <select id="heroSelectMy"></select>
            <button id="addHeroMy">Додати</button>
            <button id="clearMy">Очистити</button>
          </div>
        </div>
        <div class="team">
          <h3>Ворожа команда</h3>
          <div id="enemyTeam" class="slotRow"></div>
          <div>Winrate: <span id="winrateB">—</span></div>
          <div id="synergyB" class="analysis-block"></div>
          <div class="picker" style="margin-top:8px;">
            <select id="heroSelectEnemy"></select>
            <button id="addHeroEnemy">Додати</button>
            <button id="clearEnemy">Очистити</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Рекомендації контрпіків -->
    <div class="panel">
      <h3>Рекомендовані контрпіки</h3>
      <div id="suggestionsEl"></div>
    </div>

    <!-- Живий аналіз -->
    <div class="panel">
      <h3>Аналіз драфту</h3>
      <div id="winEstimate" style="font-weight:700; font-size:18px;">—</div>
      <pre id="analysisText"></pre>
    </div>
  </div>

  <!-- === DraftEval module (advanced synergy + counters + composition) === -->
  <script>
  (function(){
    const DraftEval = {};
    const CFG = {
      WEIGHTS: { counters: 0.38, synergy: 0.34, composition: 0.18, lanes: 0.10 },
      SUB: {
        synergy: { combos: 0.35, timing: 0.25, roles: 0.20, coverage: 0.20 },
        composition: { damageMix: 0.28, control: 0.28, sustainSave: 0.22, pushRosh: 0.22 },
        lanes: { offlaneVsCarry: 0.40, midVsMid: 0.35, pos4pos5: 0.25 }
      },
      LOGODDS: { minGames: 200, maxGames: 5000, baseShrink: 0.45 },
      DECAY: { halfLifeDays: 21 },
      PROB_CLAMP: { min: 0.08, max: 0.92 }
    };
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const sigmoid = x => 1/(1+Math.exp(-x));
    const decayWeight = (days, halfLife)=> Math.pow(0.5, days/halfLife);
    const logit = p => { p = clamp(p,1e-6,1-1e-6); return Math.log(p/(1-p)); };
    const invLogit = l => sigmoid(l);

    // Lightweight hero DB (fallback; реальний пул прийде з API-адаптера)
    const HERO_DB = {
      1:{name:'Shadow Fiend',roles:['Mid','Carry'],tags:['Burst','WaveClear','Tower','ArmorShred']},
      2:{name:'Earthshaker',roles:['Support','Offlane'],tags:['Initiation','Teamfight','StunChain']},
      3:{name:'Phantom Assassin',roles:['Carry'],tags:['Physical','Crit','Scaling']},
      4:{name:'Axe',roles:['Offlane'],tags:['Initiation','Durable','AntiCarry','BKBPierce']},
      5:{name:'Silencer',roles:['Support'],tags:['Silence','AntiCombo','Global']},
      6:{name:'Dazzle',roles:['Support'],tags:['Save','Sustain','Armor','SoftDispel']},
      7:{name:'Puck',roles:['Mid'],tags:['Elusive','Disables','Teamfight','Magic']},
      8:{name:'Faceless Void',roles:['Carry'],tags:['Teamfight','Lockdown','Scaling','BKBPierce']},
      9:{name:'Viper',roles:['Mid','Offlane'],tags:['AntiRegen','LaneDominance','Magic']},
      10:{name:'Morphling',roles:['Carry','Mid'],tags:['Adaptive','Burst','Scaling','MagicPhysical']}
    };
    const KNOWN_COMBOS = [
      { heroes:[2,8], score:+0.28, reason:'Chrono + Echo Slam' },
      { heroes:[6,3], score:+0.16, reason:'Dazzle save + PA crit' },
      { heroes:[7,2], score:+0.14, reason:'Dream Coil + Fissure' },
      { heroes:[1,2], score:+0.12, reason:'SF razes setup' }
    ];
    const TIMING = {
      early: ['LaneDominance','AntiRegen','Durable'],
      mid: ['Teamfight','Initiation','Silence','Save','WaveClear','Push','Tower'],
      late: ['Scaling','Crit','Adaptive','Lockdown']
    };
    const TAG_COUNTERS = [
      { a:'Silence', b:'Elusive', impact:+0.15 },
      { a:'AntiCarry', b:'Scaling', impact:+0.12 },
      { a:'ArmorShred', b:'Physical', impact:+0.08 },
      { a:'BKBPierce', b:'Teamfight', impact:+0.10 }
    ];

    const DefaultAdapters = {
      async getHeroMatchups(heroId){ return []; },
      async getLaneMatchup(){ return null; },
      getHeroDb(){ return HERO_DB; }
    };

    async function countersComponent(teamA, teamB, adapters, options){
      const patchDate = options?.patchDate ? new Date(options.patchDate) : new Date();
      let total = 0, pairs = 0, details = [];
      for(const a of teamA){
        const matchups = await adapters.getHeroMatchups(a);
        const map = new Map(matchups.map(m => [m.opponentId, m]));
        for(const b of teamB){
          const m = map.get(b);
          let contrib = 0, conf = 0, dw = 1;
          if(m && m.games>0){
            const wr = m.wins / m.games;
            const lo = logit(wr);
            const g = clamp((m.games - CFG.LOGODDS.minGames)/(CFG.LOGODDS.maxGames - CFG.LOGODDS.minGames),0,1);
            conf = (1-CFG.LOGODDS.baseShrink)*g + CFG.LOGODDS.baseShrink*0.5;
            const last = m.lastUpdate ? new Date(m.lastUpdate) : patchDate;
            const days = Math.max(0,(patchDate - last)/(1000*3600*24));
            dw = decayWeight(days, CFG.DECAY.halfLifeDays);
            contrib = lo * conf * dw;
          }
          total += contrib; pairs++;
          details.push({ a, b, contrib, conf, decay:dw });
        }
      }
      const score = pairs ? (total/pairs) : 0;
      return { score, details };
    }

    function synergyComponent(team, heroDb){
      const ids = team.slice();
      const tagsByHero = ids.map(id => heroDb[id]?.tags || []);
      const allTags = new Set(tagsByHero.flat());

      let comboScore = 0;
      for(const c of KNOWN_COMBOS){
        if(c.heroes.every(h=>ids.includes(h))) comboScore += c.score;
      }
      const countTiming = (bucket)=> tagsByHero.reduce((acc,t)=> acc + t.filter(x=>TIMING[bucket].includes(x)).length,0);
      const e = countTiming('early'), m = countTiming('mid'), l = countTiming('late');
      const totalTL = e+m+l || 1;
      const balance = 1 - Math.abs((l/totalTL) - (m/totalTL));
      const timingScore = 0.18*(e/totalTL) + 0.42*(m/totalTL) + 0.40*(l/totalTL) + 0.15*balance;

      const roles = ids.map(id => heroDb[id]?.roles || []);
      const ideal = ['Carry','Mid','Offlane','Support','Support'];
      const used = new Set(); let matched=0;
      for(const r of ideal){
        const idx = roles.findIndex((rs,i)=> !used.has(i) && rs.includes(r));
        if(idx!==-1){ used.add(idx); matched++; }
      }
      const roleScore = matched/ideal.length;

      const coverage = {
        damageMix: (allTags.has('Magic') && allTags.has('Physical')) || allTags.has('MagicPhysical') ? 1 : 0,
        control: (allTags.has('StunChain') || allTags.has('Lockdown') || allTags.has('Disables')) ? 1 : 0,
        sustainSave: (allTags.has('Save') || allTags.has('Sustain') || allTags.has('SoftDispel')) ? 1 : 0,
        pushRosh: (allTags.has('Push') || allTags.has('Tower')) ? 1 : 0
      };
      const coverageScore = 0.28*coverage.damageMix + 0.28*coverage.control + 0.22*coverage.sustainSave + 0.22*coverage.pushRosh;

      let score =
        CFG.SUB.synergy.combos   * comboScore +
        CFG.SUB.synergy.timing   * timingScore +
        CFG.SUB.synergy.roles    * roleScore +
        CFG.SUB.synergy.coverage * coverageScore;

      return {
        score,
        details: { comboScore, timingScore, roleScore, coverageScore, timing:{e,m,l} }
      };
    }

    function tagCounters(teamA, teamB, heroDb){
      let s=0;
      const tagsA = new Set(teamA.flatMap(id => heroDb[id]?.tags || []));
      const tagsB = new Set(teamB.flatMap(id => heroDb[id]?.tags || []));
      for(const rule of TAG_COUNTERS){
        if(tagsA.has(rule.a) && tagsB.has(rule.b)) s += rule.impact;
      }
      return { score:s };
    }

    function compositionComponent(team, heroDb){
      const tags = team.flatMap(id => heroDb[id]?.tags || []);
      const countTag = t => tags.filter(x=>x===t).length;
      const manyMagic = countTag('Magic') >= 3;
      const manyPhysical = countTag('Physical') >= 3;
      const redundancyPenalty = (manyMagic ? 0.10 : 0) + (manyPhysical ? 0.10 : 0);
      const controlLevel = Math.min(1, (countTag('StunChain')*0.5 + countTag('Lockdown')*0.5 + countTag('Disables')*0.35));
      const saveLevel = Math.min(1, (countTag('Save')*0.6 + countTag('Sustain')*0.4 + countTag('SoftDispel')*0.4));
      const pushLevel = Math.min(1, (countTag('Push')*0.6 + countTag('Tower')*0.5 + countTag('ArmorShred')*0.3));
      const damageMix = (tags.includes('MagicPhysical') || (tags.includes('Magic') && tags.includes('Physical'))) ? 1 : 0;
      const dmScore = 1*damageMix - redundancyPenalty;

      const score =
        CFG.SUB.composition.damageMix   * dmScore +
        CFG.SUB.composition.control     * controlLevel +
        CFG.SUB.composition.sustainSave * saveLevel +
        CFG.SUB.composition.pushRosh    * pushLevel;

      return { score, details:{ dmScore, controlLevel, saveLevel, pushLevel, redundancyPenalty } };
    }

    async function lanesComponent(){ return { score:0, details:[] }; }

    function aggregateToProbability(parts){
      const z =
        CFG.WEIGHTS.counters    * parts.counters.score +
        CFG.WEIGHTS.synergy     * parts.synergy.score +
        CFG.WEIGHTS.composition * parts.composition.score +
        CFG.WEIGHTS.lanes       * (parts.lanes?.score || 0);
      let p = invLogit(z);
      p = clamp(p, CFG.PROB_CLAMP.min, CFG.PROB_CLAMP.max);
      return p;
    }

    DraftEval.evaluate = async function(teamA, teamB, adapters=DefaultAdapters, options={}){
      const heroDb = adapters.getHeroDb();

      const countersA = await countersComponent(teamA, teamB, adapters, options);
      const countersB = await countersComponent(teamB, teamA, adapters, options);

      const synergyA = synergyComponent(teamA, heroDb);
      const synergyB = synergyComponent(teamB, heroDb);

      const tagCtrA = tagCounters(teamA, teamB, heroDb);
      const tagCtrB = tagCounters(teamB, teamA, heroDb);
      synergyA.score += 0.12 * tagCtrA.score;
      synergyB.score += 0.12 * tagCtrB.score;

      const compA = compositionComponent(teamA, heroDb);
      const compB = compositionComponent(teamB, heroDb);

      const lanesA = await lanesComponent(teamA, teamB);
      const lanesB = await lanesComponent(teamB, teamA);

      const probA = aggregateToProbability({ counters:countersA, synergy:synergyA, composition:compA, lanes:lanesA });
      const probB = aggregateToProbability({ counters:countersB, synergy:synergyB, composition:compB, lanes:lanesB });

      const sum = probA + probB;
      let winProbA = probA / sum;
      let winProbB = probB / sum;
      const clampProb = x => clamp(x, CFG.PROB_CLAMP.min, CFG.PROB_CLAMP.max);
      winProbA = clampProb(winProbA);
      winProbB = clampProb(winProbB);

      return {
        winProbA, winProbB,
        scores: {
          A: { counters: countersA.score, synergy: synergyA.score, composition: compA.score, lanes: lanesA.score },
          B: { counters: countersB.score, synergy: synergyB.score, composition: compB.score, lanes: lanesB.score }
        },
        breakdown: {
          A: { counters: countersA.details, synergy: synergyA.details, composition: compA.details, lanes: lanesA.details },
          B: { counters: countersB.details, synergy: synergyB.details, composition: compB.details, lanes: lanesB.details }
        }
      };
    };

    window.DraftEval = DraftEval;
  })();
  </script>
  <!-- === End DraftEval module === -->

  <script>
  // ====== Глобальні змінні UI/стану ======
  const rolesContainer = document.getElementById('rolesContainer');
  const roleFilter = document.getElementById('roleFilter');
  const startBtn = document.getElementById('startBtn');
  const playerRoleLabel = document.getElementById('playerRoleLabel');

  const myTeamEl = document.getElementById('myTeam');
  const enemyTeamEl = document.getElementById('enemyTeam');
  const heroSelectMy = document.getElementById('heroSelectMy');
  const heroSelectEnemy = document.getElementById('heroSelectEnemy');
  const addHeroMyBtn = document.getElementById('addHeroMy');
  const addHeroEnemyBtn = document.getElementById('addHeroEnemy');
  const clearMyBtn = document.getElementById('clearMy');
  const clearEnemyBtn = document.getElementById('clearEnemy');

  const suggestionsEl = document.getElementById('suggestionsEl');
  const winEstimateEl = document.getElementById('winEstimate');
  const analysisText = document.getElementById('analysisText');
  const winrateAEl = document.getElementById('winrateA');
  const winrateBEl = document.getElementById('winrateB');
  const synergyAEl = document.getElementById('synergyA');
  const synergyBEl = document.getElementById('synergyB');

  const roleKeys = ['Carry','Mid','Offlane','Support 4','Support 5'];
  let playerRole = '';

  const picked = { my: [null,null,null,null,null], enemy: [null,null,null,null,null] };

  let allHeroesApi = [];            // [{id, localized_name, name, ...}]
  let heroByName = {};              // name->object
  let heroById = {};                // id->object

  // ====== Fallback: великий локальний список героїв (буде використаний якщо API не відповість) ======
  // Список з великою кількістю героїв Dota 2 (текстові імена). Якщо хочеш, можу оновити локалізації UA.
  const ALL_HEROES_FALLBACK = [
    "Abaddon","Alchemist","Ancient Apparition","Anti-Mage","Arc Warden","Axe","Bane","Batrider","Beastmaster","Bloodseeker",
    "Bounty Hunter","Brewmaster","Bristleback","Broodmother","Centaur Warrunner","Chaos Knight","Chen","Clinkz","Clockwerk","Crystal Maiden",
    "Dark Seer","Dark Willow","Dazzle","Death Prophet","Disruptor","Doom","Dragon Knight","Drow Ranger","Earth Spirit","Earthshaker",
    "Elder Titan","Ember Spirit","Enchantress","Enigma","Faceless Void","Grimstroke","Gyrocopter","Huskar","Invoker","Io",
    "Jakiro","Juggernaut","Keeper of the Light","Kunkka","Legion Commander","Leshrac","Lich","Lifestealer","Lina","Lion",
    "Lone Druid","Luna","Lycan","Magnus","Marci","Mars","Medusa","Meepo","Mirana","Monkey King",
    "Morphling","Naga Siren","Nature's Prophet","Necrophos","Night Stalker","Nyx Assassin","Ogre Magi","Omniknight","Oracle","Outworld Devourer",
    "Pangolier","Phantom Assassin","Phantom Lancer","Phoenix","Puck","Pudge","Pugna","Queen of Pain","Razor","Riki",
    "Rubick","Sand King","Shadow Demon","Shadow Fiend","Shadow Shaman","Silencer","Skywrath Mage","Slardar","Slark","Snapfire",
    "Sniper","Spectre","Spirit Breaker","Storm Spirit","Sven","Techies","Templar Assassin","Terrorblade","Tidehunter","Timbersaw",
    "Tinker","Tiny","Treant Protector","Troll Warlord","Tusk","Underlord","Undying","Ursa","Vengeful Spirit","Venomancer",
    "Viper","Visage","Void Spirit","Warlock","Weaver","Windranger","Winter Wyvern","Witch Doctor","Wraith King","Zeus",
    "Hoodwink","Dawnbreaker","Primal Beast","Muerta","Ringmaster"
  ];

  // ====== Локальні списки ролей (мінімальні; для показу ролі у чіпі, не для обмеження вибору) ======
  const LOCAL_ROLES = {
    'Carry': ['Phantom Assassin','Faceless Void','Morphling','Shadow Fiend','Spectre','Medusa','Anti-Mage','Terrorblade','Juggernaut'],
    'Mid':   ['Invoker','Puck','Viper','Shadow Fiend','Queen of Pain','Storm Spirit','Tinker','Ember Spirit'],
    'Offlane':['Axe','Tidehunter','Mars','Beastmaster','Dark Seer','Timbersaw','Underlord'],
    'Support 4':['Rubick','Tusk','Mirana','Snapfire','Earth Spirit'],
    'Support 5':['Crystal Maiden','Lion','Witch Doctor','Dazzle','Omniknight']
  };
  function getRolesForHero(name){
    const roles = [];
    for(const r of roleKeys){
      if(LOCAL_ROLES[r]?.includes(name)) roles.push(r);
    }
    // important: if no local mapping — allow any hero (user wanted можливість обрати будь-якого героя)
    return roles.length ? roles : ['—'];
  }

  // ====== Кеш матчапів ======
  const matchupCache = {};

  async function fetchMatchups(heroId){
    if (heroId >= 10000) return []; // пропускаємо фейкові ID з fallback
    if (matchupCache[heroId]) return matchupCache[heroId];

    try{
      const res = await fetch(`https://api.opendota.com/api/heroes/${heroId}/matchups`);
      const data = await res.json();
      data.forEach(d => d.win_rate = d.games_played ? (d.wins / d.games_played) : 0.5);
      matchupCache[heroId] = data;
      await new Promise(r => setTimeout(r, 60)); // легкий throttle
      return data;
    }catch(e){
      console.warn('Matchup fetch failed', e);
      matchupCache[heroId] = [];
      return [];
    }
  }

  // ====== Завантаження героїв з OpenDota з fallback (VARIANT 2) ======
  async function loadHeroes(){
    try{
      const res = await fetch('https://api.opendota.com/api/heroes');
      if(!res.ok) throw new Error('OpenDota returned ' + res.status);
      const data = await res.json();
      allHeroesApi = data.sort((a,b)=> a.localized_name.localeCompare(b.localized_name));
      heroByName = Object.fromEntries(allHeroesApi.map(h => [h.localized_name, h]));
      heroById = Object.fromEntries(allHeroesApi.map(h => [h.id, h]));
      populateHeroSelectsFromApi();
      console.info('Heroes loaded from OpenDota API:', allHeroesApi.length);
    }catch(e){
      console.warn('Heroes API failed, using local fallback list', e);
      // build fallback objects with synthetic ids >=10000
      allHeroesApi = ALL_HEROES_FALLBACK.map((name,i)=>({
        id: 10000 + i,
        localized_name: name,
        name: 'npc_dota_hero_' + name.toLowerCase().replace(/[^a-z0-9]+/g,'_')
      })).sort((a,b)=> a.localized_name.localeCompare(b.localized_name));
      heroByName = Object.fromEntries(allHeroesApi.map(h => [h.localized_name, h]));
      heroById = Object.fromEntries(allHeroesApi.map(h => [h.id, h]));
      populateHeroSelectsFromApi();
      console.info('Fallback heroes loaded:', allHeroesApi.length);
    }
  }

  function clearSelect(sel){
    while(sel.firstChild) sel.removeChild(sel.firstChild);
  }
  function populateHeroSelectsFromApi(){
    clearSelect(heroSelectMy);
    clearSelect(heroSelectEnemy);
    // add blank first option
    const blankA = document.createElement('option'); blankA.value = ''; blankA.textContent = '-- Оберіть героя --'; heroSelectMy.appendChild(blankA);
    const blankB = document.createElement('option'); blankB.value = ''; blankB.textContent = '-- Оберіть героя --'; heroSelectEnemy.appendChild(blankB);

    const names = allHeroesApi.map(h=>h.localized_name).sort((a,b)=>a.localeCompare(b));
    names.forEach(name => {
      const optA = document.createElement('option');
      optA.value = name;
      optA.textContent = name;
      heroSelectMy.appendChild(optA);

      const optB = document.createElement('option');
      optB.value = name;
      optB.textContent = name;
      heroSelectEnemy.appendChild(optB);
    });
  }

  // ====== Рендер ролей UI ======
  function renderRoleButtons(){
    rolesContainer.innerHTML = '';
    roleFilter.innerHTML = '<option value="">Всі ролі</option>';
    roleKeys.forEach(r => {
      const b = document.createElement('button');
      b.className = 'role-btn';
      b.textContent = r;
      b.onclick = () => {
        document.querySelectorAll('.role-btn').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        playerRole = r;
        startBtn.disabled = false;
        playerRoleLabel.textContent = r;
        updateSuggestions();
      };
      rolesContainer.appendChild(b);

      const opt = document.createElement('option');
      opt.value = r; opt.textContent = r;
      roleFilter.appendChild(opt);
    });
    roleFilter.onchange = () => {
      playerRole = roleFilter.value || '';
      playerRoleLabel.textContent = playerRole || '—';
      updateSuggestions();
    };
  }

  // ====== Рекомендації контрпіків (залишив логіку як у тебе) ======
  async function updateSuggestions(){
    suggestionsEl.innerHTML = '';
    if(!playerRole){
      suggestionsEl.innerHTML = '<div class="tiny">Оберіть роль для рекомендацій.</div>';
      return;
    }
    const enemyPicks = picked.enemy.filter(Boolean);
    if(enemyPicks.length === 0){
      suggestionsEl.innerHTML = '<div class="tiny">Оберіть хоча б 1 ворожий пік — тут з’являться контрпіки.</div>';
      return;
    }

    // candidates: усі герої (але фільтр по ролям тут залишено — якщо хочеш, можна прибрати)
    const candidates = allHeroesApi
  .map(h => h.localized_name)
  .filter(n => ![...picked.my, ...picked.enemy].includes(n));

    const scores = [];
    const CHUNK = 8;

    for (let i = 0; i < candidates.length; i += CHUNK) {
      const slice = candidates.slice(i, i + CHUNK);
      const batch = await Promise.all(slice.map(async cand => {
        const candObj = heroByName[cand];
        const candId = candObj?.id ?? null;

        let counterAvg = 0.5;
        if (candId && candId < 10000) {
          const matchups = await fetchMatchups(candId);
          let sum = 0, cnt = 0;
          for (const e of enemyPicks) {
            const eObj = heroByName[e];
            const entry = eObj ? matchups.find(x => x.hero_id === eObj.id) : null;
            const wr = entry ? entry.win_rate : 0.5;
            sum += wr; cnt++;
          }
          counterAvg = cnt ? (sum / cnt) : 0.5;
        }

        // проста парна синергія (демо)
        let synergy = 0;
        const allies = picked.my.filter(Boolean);
        for (const a of allies) {
          if((a==='Magnus' && cand==='Faceless Void') || (a==='Faceless Void' && cand==='Magnus')) synergy += 0.22;
        }
        const finalScore = (counterAvg * 0.82) + (synergy * 0.18);
        return { hero: cand, counterAvg, synergy, finalScore };
      }));
      scores.push(...batch);
    }

    scores.sort((a,b)=>b.finalScore - a.finalScore);
    const top = scores.slice(0,10);
    top.forEach(s => {
      const div = document.createElement('div');
      div.className = 'suggestion';
      div.innerHTML = `<span>${s.hero}</span><span class="tiny">контр ${(s.counterAvg*100).toFixed(0)}% · синергія ${(s.synergy*100).toFixed(0)}%</span>`;
      suggestionsEl.appendChild(div);
    });
  }

  // ====== Quick live estimate (як у початковому коді) ======
  let estimateGeneration = 0;
  async function computeLiveEstimate(){
    const myP = picked.my.filter(Boolean);
    const enP = picked.enemy.filter(Boolean);
    const gen = ++estimateGeneration;

    if(myP.length===0 || enP.length===0){
      if (gen !== estimateGeneration) return;
      analysisText.textContent = 'Почніть заповнювати слоти — тут з’явиться попередній аналіз.';
      winEstimateEl.textContent = '—';
      return;
    }

    let myScore=0, enScore=0, cnt=0;
    for(const m of myP){
      const mObj = heroByName[m];
      if(!mObj) continue;
      const matchups = await fetchMatchups(mObj.id);
      for(const e of enP){
        const eObj = heroByName[e];
        if(!eObj) continue;
        const entry = matchups.find(x => x.hero_id === eObj.id);
        if(entry){ myScore += entry.win_rate; cnt++; }
      }
    }
    for(const e of enP){
      const eObj = heroByName[e];
      if(!eObj) continue;
      const matchups = await fetchMatchups(eObj.id);
      for(const m of myP){
        const mObj = heroByName[m];
        if(!mObj) continue;
        const entry = matchups.find(x => x.hero_id === mObj.id);
        if(entry){ enScore += entry.win_rate; }
      }
    }
    if(cnt>0){ myScore/=cnt; enScore/=cnt; }

    let estimate = 50 + 20*(myScore - enScore);
    estimate = Math.max(8, Math.min(92, estimate));

    if (gen !== estimateGeneration) return;
    winEstimateEl.textContent = `${estimate.toFixed(0)}%`;
    analysisText.textContent = `Мої піки: ${myP.join(', ')}\nВороги: ${enP.join(', ')}\nМоя середня: ${(myScore*100).toFixed(0)}% · ворожа середня: ${(enScore*100).toFixed(0)}%`;
  }

  // ====== DraftEval adapters integration ======
  const adapters = {
    async getHeroMatchups(heroId){
      if(heroId >= 10000) return [];
      const res = await fetch(`https://api.opendota.com/api/heroes/${heroId}/matchups`);
      const arr = await res.json();
      return arr.map(m => ({
        opponentId: m.hero_id,
        wins: m.wins,
        games: m.games_played,
        lastUpdate: new Date().toISOString().slice(0,10)
      }));
    },
    async getLaneMatchup(){ return null; },
    getHeroDb(){
      // Build hero DB from API fallback names (tags are derived heuristically)
      const db = {};
      for(const h of allHeroesApi){
        const name = h.localized_name;
        const roles = getRolesForHero(name).filter(r => r !== '—').map(r => r.includes('Support')?'Support':r);
        db[h.id] = {
          name,
          roles: roles.length ? roles : ['—'],
          tags: deriveTagsFromName(name)
        };
      }
      return Object.keys(db).length ? db : window.DraftEval?.HERO_DB || {};
    }
  };

  function deriveTagsFromName(name){
    const n = name.toLowerCase();
    const tags = [];
    if(n.includes('void')) tags.push('Lockdown','Teamfight','Scaling','BKBPierce');
    if(n.includes('assassin') || n.includes('phantom') || n.includes('pa')) tags.push('Physical','Crit','Scaling');
    if(n.includes('viper')) tags.push('Magic','AntiRegen','LaneDominance');
    if(n.includes('axe')) tags.push('Initiation','Durable','AntiCarry','BKBPierce');
    if(n.includes('silencer')) tags.push('Silence','AntiCombo','Global');
    if(n.includes('dazzle')) tags.push('Save','Sustain','SoftDispel','Armor');
    if(n.includes('earthshaker')) tags.push('Initiation','Teamfight','StunChain');
    if(n.includes('puck')) tags.push('Elusive','Disables','Teamfight','Magic');
    if(n.includes('morphling')) tags.push('Adaptive','Burst','Scaling','MagicPhysical');
    if(n.includes('shadow fiend')) tags.push('Burst','WaveClear','Tower','ArmorShred');
    return tags.length ? tags : ['Magic'];
  }

  async function updateWinrate() {
    const teamAIds = picked.my.filter(Boolean).map(n => heroByName[n]?.id).filter(Boolean);
    const teamBIds = picked.enemy.filter(Boolean).map(n => heroByName[n]?.id).filter(Boolean);
    if(teamAIds.length===0 || teamBIds.length===0){
      winrateAEl.textContent = '—';
      winrateBEl.textContent = '—';
      synergyAEl.textContent = '';
      synergyBEl.textContent = '';
      return;
    }

    const res = await DraftEval.evaluate(teamAIds, teamBIds, adapters, { patchDate: new Date().toISOString().slice(0,10) });

    winrateAEl.textContent = Math.round(res.winProbA*100) + '%';
    winrateBEl.textContent = Math.round(res.winProbB*100) + '%';

    synergyAEl.textContent = `Синергія: ${(res.scores.A.synergy*100).toFixed(0)} · Контрпіки: ${(res.scores.A.counters*100).toFixed(0)} · Композиція: ${(res.scores.A.composition*100).toFixed(0)}`;
    synergyBEl.textContent = `Синергія: ${(res.scores.B.synergy*100).toFixed(0)} · Контрпіки: ${(res.scores.B.counters*100).toFixed(0)} · Композиція: ${(res.scores.B.composition*100).toFixed(0)}`;
  }

  // ====== Render teams ======
  function renderTeam(container, arr, label){
    container.innerHTML = '';
    arr.forEach((name, idx) => {
      if(!name){
        const ghost = document.createElement('div');
        ghost.className = 'chip';
        ghost.textContent = `Слот ${idx+1}`;
        container.appendChild(ghost);
        return;
      }
      const chip = document.createElement('div');
      chip.className = 'chip';
      const roles = getRolesForHero(name).join(' / ');
      chip.innerHTML = `<span>${name}</span><span class="tiny">${roles}</span><span class="rm" title="Видалити">×</span>`;
      chip.querySelector('.rm').onclick = () => {
        if(label === 'my'){ picked.my[idx] = null; } else { picked.enemy[idx] = null; }
        renderAll();
      };
      container.appendChild(chip);
    });
  }

  function renderAll(){
    renderTeam(myTeamEl, picked.my, 'my');
    renderTeam(enemyTeamEl, picked.enemy, 'enemy');
    computeLiveEstimate();
    updateWinrate();
    updateSuggestions();
  }

  // ====== Events for add buttons ======
  addHeroMyBtn.onclick = () => {
    const name = heroSelectMy.value;
    if(!name) return;
    if(picked.enemy.includes(name) || picked.my.includes(name)) return alert('Герой вже вибраний.');
    const idx = picked.my.findIndex(x => !x);
    if(idx === -1) return alert('Команда заповнена.');
    picked.my[idx] = name;
    renderAll();
  };
  addHeroEnemyBtn.onclick = () => {
    const name = heroSelectEnemy.value;
    if(!name) return;
    if(picked.enemy.includes(name) || picked.my.includes(name)) return alert('Герой вже вибраний.');
    const idx = picked.enemy.findIndex(x => !x);
    if(idx === -1) return alert('Команда заповнена.');
    picked.enemy[idx] = name;
    renderAll();
  };
  clearMyBtn.onclick = () => { picked.my = [null,null,null,null,null]; renderAll(); };
  clearEnemyBtn.onclick = () => { picked.enemy = [null,null,null,null,null]; renderAll(); };

  startBtn.onclick = () => {
    if(!playerRole) return alert('Оберіть роль.');
    alert(`Роль встановлена: ${playerRole}. Починай драфт!`);
  };

  // ====== Ініціалізація ======
  (async function init(){
    renderRoleButtons();
    await loadHeroes();
    renderAll();
  })();
  </script>
</body>
</html>







