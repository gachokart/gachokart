<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dota2 Draft ‚Äî –†–æ–ª—å ‚Üí –î—Ä–∞—Ñ—Ç ‚Üí –†–µ–∑—É–ª—å—Ç–∞—Ç</title>
  <style>
    :root {
      --bg:#111;
      --panel:#171717;
      --muted:#9aa1a8;
      --accent:#4caf50;
      --danger:#f44336;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    body{
      margin:0;padding:20px;
      font-family:Inter,Arial,Helvetica,sans-serif;
      background:linear-gradient(180deg,#0b0b0b 0%, #131313 100%);
      color:#e6eef3;
    }
    header{display:flex;align-items:center;gap:12px; margin-bottom:18px}
    header h1{margin:0;font-size:20px}
    .card{background:var(--panel);border-radius:10px;padding:14px;}
    .center{display:flex;align-items:center;justify-content:center}
    .screen{max-width:1100px;margin:0 auto;}
    /* Role select */
    .roles{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:18px}
    .role-btn{padding:10px 16px;border-radius:8px;background:var(--glass);color:var(--muted);cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
    .role-btn.active{background:linear-gradient(90deg,#2b7a3a,#178a6a);color:#fff;box-shadow:0 6px 18px rgba(23,138,106,0.16)}
    .muted{color:var(--muted);font-size:13px}
    /* Draft layout */
    .draft-grid{display:grid;grid-template-columns:1fr 350px 1fr;gap:18px;margin-top:18px;align-items:start}
    .team-col{min-height:240px;padding:12px;border-radius:8px;background:linear-gradient(180deg,#151515,#171717);border:1px solid rgba(255,255,255,0.02)}
    .team-title{display:flex;align-items:center;gap:10px;margin-bottom:8px}
    .slot{display:flex;align-items:center;gap:10px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-bottom:8px}
    .slot .hero-thumb{width:46px;height:26px;background:#0c0c0c;border-radius:3px;display:inline-block;overflow:hidden}
    .slot .hero-name{flex:1}
    .slot .pick-btn{padding:6px 10px;border-radius:6px;border:none;background:linear-gradient(90deg,#2b7a3a,#178a6a);color:white;cursor:pointer}
    .slot .empty{color:var(--muted)}
    .center-actions{display:flex;flex-direction:column;gap:10px;align-items:center}
    .muted-small{font-size:13px;color:var(--muted)}
    /* hero picker */
    .picker{background:var(--panel);padding:12px;border-radius:8px;max-height:560px;overflow:auto}
    .picker .filter-row{display:flex;gap:8px;margin-bottom:10px}
    .hero-list{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .hero-item{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;background:rgba(255,255,255,0.01);cursor:pointer}
    .hero-item.disabled{opacity:0.35;pointer-events:none}
    .hero-item img{width:40px;height:24px;object-fit:cover;border-radius:4px}
    .hero-item .hname{font-size:14px}
    /* right panel */
    .panel {padding:12px;border-radius:8px;background:linear-gradient(180deg,#0f1111,#131313);border:1px solid rgba(255,255,255,0.02)}
    .panel h3{margin-top:0;margin-bottom:8px}
    .suggestions{display:flex;flex-direction:column;gap:8px}
    .suggestion{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .score{min-width:48px;text-align:right;font-weight:600}
    .tiny{font-size:12px;color:var(--muted)}
    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}
    .btn {padding:8px 12px;border-radius:8px;background:var(--accent);border:none;color:#fff;cursor:pointer}
    .btn.secondary{background:#2b2b2b;border:1px solid rgba(255,255,255,0.02)}
    .stage{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:13px}
    .hero-thumb img{width:100%;height:100%;object-fit:cover}
    .small-note{font-size:12px;color:var(--muted)}
    /* results */
    .results{margin-top:14px;padding:12px;border-radius:8px;background:linear-gradient(180deg,#0f1410,#091213);border:1px solid rgba(255,255,255,0.02)}
  </style>
</head>
<body>
  <div class="screen">
    <header>
      <h1>Dota 2 ‚Äî Draft —Å–∏–º—É–ª—è—Ç–æ—Ä (—Ä—É—á–Ω–∏–π) ‚Äî —Ä–æ–ª—å ‚Üí –¥—Ä–∞—Ñ—Ç ‚Üí —Ä–µ–∑—É–ª—å—Ç–∞—Ç</h1>
      <div style="margin-left:auto" class="muted">Data source: OpenDota API</div>
    </header>

    <!-- ROLE SELECT SCREEN -->
    <div id="role-screen" class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="muted">–ö–†–û–ö 1</div>
          <h2>–û–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å, –∑–∞ —è–∫—É –≤–∏ –±—É–¥–µ—Ç–µ –≥—Ä–∞—Ç–∏</h2>
        </div>
        <div class="stage">–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –≤–∏–±—ñ—Ä —Ä–æ–ª—ñ</div>
      </div>

      <div class="roles" id="roles-container">
        <!-- –∫–Ω–æ–ø–∫–∏ —Ä–æ–ª–µ–π –±—É–¥—É—Ç—å –¥–æ–¥–∞–Ω—ñ —Å–∫—Ä–∏–ø—Ç–æ–º -->
      </div>

      <div style="display:flex;justify-content:center;margin-top:16px;gap:12px">
        <button id="start-draft" class="btn" disabled>Start Draft</button>
        <button id="use-default" class="btn secondary">–û–±–µ—Ä—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤—É —Ä–æ–ª—å</button>
      </div>
      <p class="tiny center" style="margin-top:12px">–ü—ñ—Å–ª—è –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è Start Draft ‚Äî –≤—ñ–¥–∫—Ä–∏—î—Ç—å—Å—è –µ–∫—Ä–∞–Ω –¥—Ä–∞—Ñ—Ç—É. –ü—ñ–∫–∏ –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è –≤—Ä—É—á–Ω—É: –≤–∏–±–∏—Ä–∞–π —Å–ª–æ—Ç–∏ —ñ –æ–±–∏—Ä–∞–π –≥–µ—Ä–æ—è –∑ –ø—Ä–∞–≤–æ–≥–æ —Å–ø–∏—Å–∫–∞.</p>
    </div>

    <!-- DRAFT SCREEN -->
    <div id="draft-screen" style="display:none">
      <div style="display:flex;justify-content:space-between;gap:12px;margin-top:18px">
        <div class="muted-small">–ö–†–û–ö 2 ‚Äî –î—Ä–∞—Ñ—Ç: –≤–∏–±–∏—Ä–∞–π—Ç–µ –ø—ñ–∫–∏ –≤—Ä—É—á–Ω—É (–ø–æ —á–µ—Ä–∑—ñ –ø–æ —Å—Ç–∞–¥—ñ—è—Ö)</div>
        <div class="stage" id="stage-indicator">Stage: ‚Äî</div>
      </div>

      <div class="draft-grid" style="margin-top:10px">
        <!-- My Team -->
        <div class="team-col card">
          <div class="team-title"><strong>–ú–æ—è –∫–æ–º–∞–Ω–¥–∞</strong><div style="margin-left:auto" class="tiny">–í–∞—à —Ä–∞—É–Ω–¥: <span id="my-role-label"></span></div></div>
          <div id="my-slots-container">
            <!-- 5 —Å–ª–æ—Ç—ñ–≤ -->
          </div>
        </div>

        <!-- Center: hero picker -->
        <div>
          <div class="picker card">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
              <div>
                <div class="muted-small">Hero picker</div>
                <div style="font-weight:600" id="picker-context">–û–±–µ—Ä—ñ—Ç—å —Å–ª–æ—Ç —â–æ–± –ø–æ—á–∞—Ç–∏ –ø—ñ–∫—É</div>
              </div>
              <div>
                <div class="muted-small">–ü–æ—à—É–∫</div>
                <input id="hero-search" placeholder="–§—ñ–ª—å—Ç—Ä –∑–∞ —ñ–º'—è–º..." style="background:#0f0f0f;border-radius:6px;border:1px solid rgba(255,255,255,0.03);padding:6px;color:#fff" />
              </div>
            </div>

            <div style="display:flex;gap:8px;margin-bottom:10px" class="filter-row">
              <select id="role-filter" style="flex:1;padding:8px;border-radius:6px;background:#0f0f0f;color:#fff;border:1px solid rgba(255,255,255,0.03)">
                <option value="">–í—Å—ñ —Ä–æ–ª—ñ</option>
              </select>
              <button id="clear-filter" class="btn secondary">–û—á–∏—Å—Ç–∏—Ç–∏</button>
            </div>

            <div class="hero-list" id="hero-list">
              <!-- –≥–µ—Ä–æ—ó -->
            </div>

            <div style="margin-top:10px" class="small-note">–Ü–∫–æ–Ω–∫–∏ –±–µ—Ä—É—Ç—å—Å—è –∑ OpenDota. –ì–µ—Ä–æ–π, —è–∫–∏–π —É–∂–µ –≤–∏–±—Ä–∞–Ω–∏–π ‚Äî –≤–∏–∫–ª—é—á–∞—î—Ç—å—Å—è.</div>
          </div>

          <div style="margin-top:12px" class="center">
            <button id="next-stage" class="btn secondary">–î–∞–ª—ñ (–Ω–∞—Å—Ç—É–ø–Ω–∞ —Å—Ç–∞–¥—ñ—è)</button>
            <button id="finish-draft" class="btn" style="margin-left:8px">–§—ñ–Ω—ñ—à (–ø–æ–∫–∞–∑–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç)</button>
          </div>
        </div>

        <!-- Right panel: suggestions & counters -->
        <div class="panel card">
          <h3>–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –∫–æ–Ω—Ç—Ä–ø—ñ–∫–∏ –¥–ª—è –≤–∞—à–æ—ó —Ä–æ–ª—ñ</h3>
          <div class="tiny">–ü—ñ–¥–±—ñ—Ä –≤—Ä–∞—Ö–æ–≤—É—î –≤–∏–±—Ä–∞–Ω–∏—Ö –≤–æ—Ä–æ–≥—ñ–≤ —Ç–∞ —Å–æ—é–∑–Ω–∏–∫—ñ–≤. –î–∞–Ω—ñ –º–∞—Ç—á–∞–ø—ñ–≤ ‚Äî OpenDota.</div>
          <div style="height:10px"></div>
          <div id="suggestions" class="suggestions">
            <!-- –¥–∏–Ω–∞–º—ñ—á–Ω—ñ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó -->
          </div>

          <div style="margin-top:12px" class="results" id="live-analysis">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div class="muted-small">–ü–æ—Ç–æ—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑</div>
              <div class="muted-small">–®–∞–Ω—Å (–æ—Ä—ñ—î–Ω—Ç–∏—Ä)</div>
            </div>
            <div style="display:flex;gap:10px;margin-top:8px;align-items:center">
              <div style="flex:1">
                <div id="analysis-text" class="tiny">–û–±–µ—Ä—ñ—Ç—å –ø–µ—Ä—à—ñ –ø—ñ–∫–∏ —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑.</div>
              </div>
              <div style="width:120px;text-align:right">
                <div id="win-estimate" style="font-weight:700;font-size:18px">‚Äî</div>
                <div class="tiny" style="color:var(--muted)">–ü—Ä–∏–±–ª–∏–∑–Ω–æ</div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- RESULTS SCREEN -->
    <div id="results-screen" style="display:none;margin-top:14px">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç –¥—Ä–∞—Ñ—Ç—É</h2>
            <div class="tiny">–ê–Ω–∞–ª—ñ–∑ –ø—ñ–∫/–∫–æ–Ω—Ç—Ä–ø—ñ–∫ —Ç–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —à–∞–Ω—Å (—Å–∏–º—É–ª—è—Ü—ñ—è)</div>
          </div>
          <div style="text-align:right">
            <div style="font-size:20px;font-weight:700" id="final-win">‚Äî</div>
            <div class="tiny" id="final-strategy">‚Äî</div>
          </div>
        </div>

        <div style="display:flex;gap:12px;margin-top:12px">
          <div style="flex:1" class="team-col card">
            <strong>–ú–æ—è –∫–æ–º–∞–Ω–¥–∞</strong>
            <div id="final-my" style="margin-top:8px"></div>
          </div>
          <div style="flex:1" class="team-col card">
            <strong>–°—É–ø–µ—Ä–Ω–∏–∫</strong>
            <div id="final-enemy" style="margin-top:8px"></div>
          </div>
        </div>

        <div style="margin-top:12px">
          <h3>–ö–æ—Ä–æ—Ç–∫–∏–π –∞–Ω–∞–ª—ñ–∑</h3>
          <div id="final-analysis" class="tiny"></div>
        </div>

        <div style="margin-top:12px" class="center">
          <button id="restart" class="btn secondary">–ü–æ—á–∞—Ç–∏ —Å–ø–æ—á–∞—Ç–∫—É</button>
        </div>
      </div>
    </div>

    <footer>Made with ‚ù§Ô∏è ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î OpenDota API –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –º–∞—Ç—á–∞–ø—ñ–≤. –Ø–∫—â–æ API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π ‚Äî —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º–µ –∑ –±–∞–∑–æ–≤–∏–º–∏ —Å–ø–∏—Å–∫–∞–º–∏ –ª–æ–∫–∞–ª—å–Ω–æ.</footer>
  </div>

<script>
(async function(){

/* ============================
   –ö–æ–Ω—Ñ—ñ–≥ —Ç–∞ —Ä–æ–ª—å–æ–≤—ñ —Å–ø–∏—Å–∫–∏
   ============================ */

const roleHeroes = {
  Carry: ["Phantom Assassin","Juggernaut","Sven","Morphling","Faceless Void","Medusa","Spectre","Anti-Mage","Weaver","Lifestealer","Drow Ranger","Terrorblade"],
  Mid: ["Invoker","Storm Spirit","Puck","Queen of Pain","Shadow Fiend","Ember Spirit","Tinker","Leshrac","Zeus","Death Prophet","Kunkka","Windranger"],
  Offlane: ["Centaur Warrunner","Tidehunter","Mars","Beastmaster","Dark Seer","Timbersaw","Axe","Bristleback","Underlord","Doom","Magnus","Slardar"],
  "Support 4": ["Rubick","Earth Spirit","Tusk","Mirana","Snapfire","Nyx Assassin","Phoenix","Clockwerk","Marci","Techies","Pudge","Spirit Breaker"],
  "Support 5": ["Crystal Maiden","Lion","Witch Doctor","Dazzle","Omniknight","Warlock","Shadow Shaman","Lich","Oracle","Treant Protector","Bane","Disruptor"]
};

// helper to get list of all role keys
const roleKeys = Object.keys(roleHeroes);

/* ============================
   State
   ============================ */

let allHeroesApi = [];    // raw response from /api/heroes
let heroByName = {};     // map localized_name -> hero object {id, name, localized_name}
let heroShort = {};      // map localized_name -> short name for icon urls
let picked = {
  my: Array(5).fill(null),
  enemy: Array(5).fill(null)
};
let playerRole = null;
let currentStage = 0; // 0 = first round (2 picks each), 1 = second (2picks), 2 = final (1 pick)
let pickOrder = []; // will store order of slots for UI convenience
let activeSlot = null; // {team:'my'|'enemy', index:0..4} ‚Äî which slot user is currently picking for
let matchupCache = {}; // caches matchups per hero id to avoid many requests

/* ============================
   UI nodes
   ============================ */

const rolesContainer = document.getElementById('roles-container');
const startBtn = document.getElementById('start-draft');
const useDefaultBtn = document.getElementById('use-default');
const myRoleLabel = document.getElementById('my-role-label');

const roleScreen = document.getElementById('role-screen');
const draftScreen = document.getElementById('draft-screen');
const resultsScreen = document.getElementById('results-screen');

const mySlotsContainer = document.getElementById('my-slots-container');
const heroListEl = document.getElementById('hero-list');
const roleFilter = document.getElementById('role-filter');
const heroSearch = document.getElementById('hero-search');
const clearFilterBtn = document.getElementById('clear-filter');
const pickerContext = document.getElementById('picker-context');
const suggestionsEl = document.getElementById('suggestions');
const winEstimateEl = document.getElementById('win-estimate');
const analysisText = document.getElementById('analysis-text');
const stageIndicator = document.getElementById('stage-indicator');

const nextStageBtn = document.getElementById('next-stage');
const finishDraftBtn = document.getElementById('finish-draft');
const finalMy = document.getElementById('final-my');
const finalEnemy = document.getElementById('final-enemy');
const finalWin = document.getElementById('final-win');
const finalStrategy = document.getElementById('final-strategy');
const finalAnalysis = document.getElementById('final-analysis');
const restartBtn = document.getElementById('restart');

/* ============================
   –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ–ª–µ–π –∏ UI
   ============================ */

function renderRoleButtons(){
  rolesContainer.innerHTML = '';
  roleKeys.forEach(r=>{
    const btn = document.createElement('button');
    btn.className = 'role-btn';
    btn.textContent = r;
    btn.onclick = ()=>{
      document.querySelectorAll('.role-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      playerRole = r;
      startBtn.disabled = false;
      myRoleLabel.textContent = r;
    };
    rolesContainer.appendChild(btn);
  });
  // —Ä–æ–ª–∏ –≤ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó –≥–µ—Ä–æ—è
  roleKeys.forEach(r=>{
    const opt = document.createElement('option');
    opt.value = r;
    opt.textContent = r;
    roleFilter.appendChild(opt);
  });
}

renderRoleButtons();

/* ============================
   –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫—É –≥–µ—Ä–æ—ó–≤ –∑ OpenDota
   ============================ */

async function loadHeroList(){
  try{
    const res = await fetch('https://api.opendota.com/api/heroes');
    const data = await res.json();
    allHeroesApi = data.sort((a,b)=>a.localized_name.localeCompare(b.localized_name));
    // maps
    allHeroesApi.forEach(h=>{
      heroByName[h.localized_name] = h;
      // short name for icon URLs: take h.name 'npc_dota_hero_antimage' => antimage
      const short = h.name.replace('npc_dota_hero_','');
      heroShort[h.localized_name] = short;
    });
    populateHeroPicker();
  }catch(e){
    console.error('Failed loading OpenDota heroes, falling back to role lists only',e);
    // build minimal fallback list from roleHeroes keys
    const fallback = new Set();
    Object.values(roleHeroes).flat().forEach(n=>fallback.add(n));
    allHeroesApi = Array.from(fallback).map((name,i)=>({
      id: 10000+i,
      localized_name: name,
      name: 'npc_dota_hero_'+name.toLowerCase().replace(/\s+/g,'_')
    }));
    allHeroesApi.forEach(h=>{
      heroByName[h.localized_name] = h;
      heroShort[h.localized_name] = h.name.replace('npc_dota_hero_','');
    });
    populateHeroPicker();
  }
}

/* ============================
   Populate hero picker
   ============================ */

function heroItemHtml(heroName){
  const short = heroShort[heroName];
  const imgUrl = `https://api.opendota.com/apps/dota2/images/heroes/${short}_full.png`;
  return `
    <div style="display:flex;align-items:center;gap:8px;width:100%">
      <div style="width:44px;height:26px;border-radius:4px;overflow:hidden" class="hero-thumb"><img src="${imgUrl}" alt="" /></div>
      <div style="flex:1"><div class="hname">${heroName}</div><div class="tiny" style="opacity:0.6;font-size:12px">${getRolesForHero(heroName).join(', ')}</div></div>
      <div style="min-width:56px;text-align:right" class="tiny">pick</div>
    </div>
  `;
}

function getRolesForHero(name){
  // returns array of roles in which hero exists in roleHeroes mapping
  return roleKeys.filter(r => roleHeroes[r].includes(name));
}

function populateHeroPicker(){
  heroListEl.innerHTML = '';
  // initial list is all heroes sorted by localized_name (allHeroesApi)
  const names = allHeroesApi.map(h=>h.localized_name);
  names.forEach(n=>{
    const div = document.createElement('div');
    div.className = 'hero-item';
    div.innerHTML = heroItemHtml(n);
    div.title = n;
    div.onclick = ()=> tryPickHero(n);
    div.dataset.name = n;
    heroListEl.appendChild(div);
  });
  updateDisabledHeroes();
}

/* ============================
   Update disabled heroes (already picked)
   ============================ */

function updateDisabledHeroes(){
  const chosen = new Set([...picked.my.filter(Boolean), ...picked.enemy.filter(Boolean)]);
  document.querySelectorAll('.hero-item').forEach(el=>{
    const name = el.dataset.name;
    if(chosen.has(name)){
      el.classList.add('disabled');
    } else {
      el.classList.remove('disabled');
    }
  });
}

/* ============================
   Draft slots render
   ============================ */

function createSlotEl(team,index){
  const cont = document.createElement('div');
  cont.className = 'slot';
  cont.id = `slot-${team}-${index}`;

  const thumb = document.createElement('div'); thumb.className='hero-thumb';
  const nameWrap = document.createElement('div'); nameWrap.className='hero-name';
  const btn = document.createElement('button'); btn.className='pick-btn';
  btn.textContent = 'Pick';
  btn.onclick = ()=> {
    activeSlot = {team,index};
    highlightActiveSlot();
    pickerContext.textContent = `–ü—ñ–∫–∞–π –¥–ª—è ${team === 'my' ? '–ú–æ—ó–π –∫–æ–º–∞–Ω–¥—ñ' : '–°—É–ø–µ—Ä–Ω–∏–∫—É'} ‚Äî —Å–ª–æ—Ç ${index+1}`;
    // focus search
    heroSearch.focus();
  };

  // initial empty content
  thumb.textContent = '';
  nameWrap.innerHTML = `<div class="empty">–ü–æ—Ä–æ–∂–Ω—ñ–π —Å–ª–æ—Ç</div>`;

  cont.appendChild(thumb);
  cont.appendChild(nameWrap);
  cont.appendChild(btn);
  return cont;
}

function renderSlots(){
  mySlotsContainer.innerHTML = '';
  for(let i=0;i<5;i++){
    const el = createSlotEl('my',i);
    mySlotsContainer.appendChild(el);
  }
  // enemy column left as part of final display ‚Äî in draft UI they are not all shown, but we'll show picks in suggestions area/analysis.
  // Also create visual for enemy somewhere minimal (not needed here).
  refreshSlotDisplays();
}

function refreshSlotDisplays(){
  // update my slots
  for(let i=0;i<5;i++){
    const el = document.getElementById(`slot-my-${i}`);
    const heroName = picked.my[i];
    const thumb = el.querySelector('.hero-thumb');
    const nameWrap = el.querySelector('.hero-name');
    const btn = el.querySelector('.pick-btn');
    if(heroName){
      const short = heroShort[heroName];
      const imgUrl = `https://api.opendota.com/apps/dota2/images/heroes/${short}_full.png`;
      thumb.innerHTML = `<img src="${imgUrl}" alt="" />`;
      nameWrap.innerHTML = `<div style="font-weight:600">${heroName}</div><div class="tiny">Role: ${getRolesForHero(heroName).join(', ')}</div>`;
      btn.textContent = 'Replace';
    } else {
      thumb.innerHTML = '';
      nameWrap.innerHTML = `<div class="empty">–ü–æ—Ä–æ–∂–Ω—ñ–π —Å–ª–æ—Ç</div>`;
      btn.textContent = 'Pick';
    }
  }
  // enemy slots visible in analysis/final only
  updateDisabledHeroes();
  updateSuggestions();
}

/* ============================
   Picking logic
   ============================ */

function tryPickHero(name){
  if(!activeSlot){
    // if no active slot chosen, default choose next empty my slot
    const nextMy = picked.my.findIndex(x=>!x);
    if(nextMy !== -1){
      activeSlot = {team:'my', index: nextMy};
      highlightActiveSlot();
      pickerContext.textContent = `–ê–≤—Ç–æ–≤–∏–±—ñ—Ä: —Å–ª–æ—Ç ${nextMy+1}`;
    } else {
      pickerContext.textContent = '–°–ø–æ—á–∞—Ç–∫—É –æ–±–µ—Ä—ñ—Ç—å —Å–ª–æ—Ç';
      return;
    }
  }

  const {team,index} = activeSlot;
  // uniqueness: ensure hero not chosen already
  const chosen = new Set([...picked.my.filter(Boolean), ...picked.enemy.filter(Boolean)]);
  if(chosen.has(name)){
    alert('–¶–µ–π –≥–µ—Ä–æ–π –≤–∂–µ –≤–∏–±—Ä–∞–Ω–∏–π –≤ —ñ–Ω—à–æ–º—É —Å–ª–æ—Ç—ñ.');
    return;
  }
  picked[team][index] = name;
  activeSlot = null;
  highlightActiveSlot();
  refreshSlotDisplays();
  computeLiveEstimate();
}

function highlightActiveSlot(){
  // remove highlight
  document.querySelectorAll('.slot').forEach(s=>s.style.boxShadow='none');
  if(activeSlot){
    const el = document.getElementById(`slot-${activeSlot.team}-${activeSlot.index}`);
    if(el) el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.6), inset 0 0 0 2px rgba(76,175,80,0.14)';
  }
}

/* ============================
   Filters: search + role filter
   ============================ */

roleFilter.addEventListener('change', ()=>{
  renderFilteredHeroes();
});
heroSearch.addEventListener('input', ()=>{
  renderFilteredHeroes();
});
clearFilterBtn.addEventListener('click', ()=>{
  roleFilter.value = '';
  heroSearch.value = '';
  renderFilteredHeroes();
});

function renderFilteredHeroes(){
  const q = heroSearch.value.trim().toLowerCase();
  const roleSel = roleFilter.value;
  document.querySelectorAll('.hero-item').forEach(el=>{
    const name = el.dataset.name;
    const matchesQ = !q || name.toLowerCase().includes(q);
    const matchesRole = !roleSel || getRolesForHero(name).includes(roleSel);
    el.style.display = (matchesQ && matchesRole) ? 'flex' : 'none';
  });
  updateDisabledHeroes();
}

/* ============================
   Stages logic
   ============================ */

/*
Draft stages structure:
Stage 0: each team picks 2 heroes (we will allow user to pick any order but stage restricts count)
Stage 1: each team picks next 2 heroes
Stage 2: each team picks final hero (1 each)
We will enforce counts and show stageIndicator
*/

function setStage(n){
  currentStage = n;
  const labels = ['Round 1 ‚Äî 2 picks each','Round 2 ‚Äî 2 picks each','Round 3 ‚Äî final pick'];
  stageIndicator.textContent = `Stage: ${labels[n]}`;
  // compute how many picks allowed per team in this stage
  const allowedPerStage = [2,2,1];
  // compute how many picks already made in this stage for each team
  // we don't track by stage, only by totals ‚Äî so we limit: in stage 0, each team must pick up to 2 slots
  updateStageButtons();
}

function updateStageButtons(){
  // Next stage button enabled only if stage picks are completed
  const required = currentStage === 0 ? 2 : currentStage===1 ? 2 : 1;
  const myDone = countNewPicksInStage('my') >= required;
  const enDone = countNewPicksInStage('enemy') >= required;
  nextStageBtn.disabled = !(myDone && enDone) || currentStage >= 2;
}

function countNewPicksInStage(team){
  // We can't know which picks are from which stage if user replaced ‚Äî but simplest: count total picks in team and limit by stage cumulative
  // We'll enforce by cumulative: after stage0, total picks per team must be >=2; after stage1 >=4; after stage2 ==5
  const total = picked[team].filter(Boolean).length;
  if(currentStage===0) return Math.min(total,2);
  if(currentStage===1) return Math.min(Math.max(total-2,0),2);
  if(currentStage===2) return Math.min(Math.max(total-4,0),1);
  return 0;
}

nextStageBtn.addEventListener('click', ()=>{
  if(currentStage < 2){
    setStage(currentStage + 1);
    updateStageButtons();
  }
});

finishDraftBtn.addEventListener('click', ()=>{
  // ensure both teams have 5 picks (if not, warn)
  if(picked.my.filter(Boolean).length !==5 || picked.enemy.filter(Boolean).length !==5){
    if(!confirm('–ù–µ –≤—Å—ñ —Å–ª–æ—Ç–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω—ñ. –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ —ñ –ø–æ–∫–∞–∑–∞—Ç–∏ –∞–Ω–∞–ª—ñ–∑?')) return;
  }
  showResults();
});

/* ============================
   Suggestions & analytics (uses OpenDota matchups)
   ============================ */

async function updateSuggestions(){
  suggestionsEl.innerHTML = '';
  // suggestion list should show top candidate heroes for player's role (that are not picked)
  if(!playerRole){
    suggestionsEl.innerHTML = '<div class="tiny">–û–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å —â–æ–± –±–∞—á–∏—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó.</div>';
    return;
  }
  const candidatePool = roleHeroes[playerRole].filter(n => ![...picked.my,...picked.enemy].includes(n));
  // For each candidate get counter score vs enemy picks
  const enemyPicks = picked.enemy.filter(Boolean);
  if(enemyPicks.length === 0){
    suggestionsEl.innerHTML = '<div class="tiny">–û–±–µ—Ä—ñ—Ç—å —Ö–æ—á–∞ –± –æ–¥–Ω–æ–≥–æ –≥–µ—Ä–æ—è —Å—É–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞, —â–æ–± –±–∞—á–∏—Ç–∏ –∫–æ–Ω—Ç—Ä–ø—ñ–∫–∏.</div>';
    return;
  }

  // compute scores for candidates
  const scores = [];
  for(const c of candidatePool){
    const cId = heroByName[c] ? heroByName[c].id : null;
    let counterScore = 0;
    if(cId){
      const matchups = await fetchMatchups(cId);
      for(const e of enemyPicks){
        const eObj = heroByName[e];
        if(!eObj) continue;
        const entry = matchups.find(it => it.hero_id === eObj.id);
        // if found, wins/games denote wins for candidate vs enemy: use win_rate
        let winRate = entry ? (entry.wins / entry.games_played) : 0.5;
        counterScore += winRate; // more is better
      }
      // normalize average
      counterScore = counterScore / enemyPicks.length;
    } else {
      counterScore = 0.5; // fallback neutral
    }

    // synergy score: simple heuristic based on ally roles
    const allyPicks = picked.my.filter(Boolean);
    let synergy = 0;
    for(const a of allyPicks){
      if(!a) continue;
      // if ally is support and candidate is carry ‚Äî +0.12
      if(roleHeroes['Support 5'].includes(a) || roleHeroes['Support 4'].includes(a)){
        if(roleHeroes['Carry'].includes(c)) synergy += 0.12;
      }
      // if ally is offlane and candidate is mid/carry -> small synergy
      if(roleHeroes['Offlane'].includes(a) && (roleHeroes['Mid'].includes(c) || roleHeroes['Carry'].includes(c))) synergy += 0.06;
      // if ally shares a strong combo (very naive): e.g., Magnus + Faceless Void synergy
      if((a==='Magnus' && c==='Faceless Void') || (a==='Faceless Void' && c==='Magnus')) synergy += 0.2;
      if((a==='Shaker' && c==='Enigma') || (a==='Enigma' && c==='Shaker')) synergy += 0.12;
    }

    // penalty if candidate counters friendly picks? (none)
    const finalScore = (counterScore * 0.85) + (synergy * 0.15); // weighted
    scores.push({hero:c, finalScore, counterScore, synergy});
  }

  // sort by finalScore desc
  scores.sort((a,b)=>b.finalScore - a.finalScore);

  // render top 8
  const top = scores.slice(0,8);
  for(const s of top){
    const el = document.createElement('div');
    el.className = 'suggestion';
    const short = heroShort[s.hero] || '';
    const imgUrl = short ? `https://api.opendota.com/apps/dota2/images/heroes/${short}_full.png` : '';
    el.innerHTML = `
      <div style="width:56px;height:30px;border-radius:6px;overflow:hidden"><img src="${imgUrl}" style="width:100%;height:100%;object-fit:cover" /></div>
      <div style="flex:1">
        <div style="font-weight:700">${s.hero}</div>
        <div class="tiny">counter avg: ${(s.counterScore*100).toFixed(0)}% ¬∑ synergy ${(s.synergy*100).toFixed(0)}%</div>
      </div>
      <div class="score">${(s.finalScore*100).toFixed(0)}</div>
    `;
    // clicking suggestion will pick hero into activeSlot if set
    el.onclick = ()=> {
      if(!activeSlot){
        alert('–û–±–µ—Ä—ñ—Ç—å —Å–ª–æ—Ç, –∫—É–¥–∏ –ø–æ—Å—Ç–∞–≤–∏—Ç–∏ —Ü—å–æ–≥–æ –≥–µ—Ä–æ—è (–Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É Pick —É —Å–ª–æ—Ç—ñ).');
        return;
      }
      tryPickHero(s.hero);
    };
    suggestionsEl.appendChild(el);
  }

  if(top.length === 0){
    suggestionsEl.innerHTML = '<div class="tiny">–ù–µ–º–∞—î –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ (–≤—Å—ñ –≥–µ—Ä–æ—ó —Ü—ñ—î—ó —Ä–æ–ª—ñ –≤–∂–µ –≤ –∫–æ–º–∞–Ω–¥–∞—Ö –∞–±–æ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç–∏–π).</div>';
  }
}

/* ============================
   Fetch matchups & cache
   ============================ */

async function fetchMatchups(heroId){
  if(matchupCache[heroId]) return matchupCache[heroId];
  try{
    const res = await fetch(`https://api.opendota.com/api/heroes/${heroId}/matchups`);
    const data = await res.json();
    // data: array {hero_id, games_played, wins} where wins is number of wins for heroId vs hero_id
    // compute win_rate per entry (wins/games)
    data.forEach(d=> d.win_rate = (d.games_played ? (d.wins / d.games_played) : 0.5));
    matchupCache[heroId] = data;
    // throttle safety: small delay to be polite (not required but reduces burst)
    await new Promise(r=>setTimeout(r,80));
    return data;
  }catch(e){
    console.warn('matchup fetch failed for',heroId,e);
    matchupCache[heroId] = [];
    return [];
  }
}

/* ============================
   Live estimate & analysis
   ============================ */

async function computeLiveEstimate(){
  // Simple heuristic: combine 'strength' of my team vs enemy team using matchups.
  const myPicks = picked.my.filter(Boolean);
  const enemyPicks = picked.enemy.filter(Boolean);
  if(myPicks.length === 0 || enemyPicks.length === 0){
    analysisText.textContent = '–ü–æ—á–Ω—ñ—Ç—å –≤–∏–±–∏—Ä–∞—Ç–∏ –ø—ñ–∫–∏ ‚Äî —Ç—É—Ç –∑\'—è–≤–∏—Ç—å—Å—è –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –∞–Ω–∞–ª—ñ–∑.';
    winEstimateEl.textContent = '‚Äî';
    return;
  }

  // For each my hero, compute avg win rate vs enemy heroes (using matchups for my hero)
  let myScore = 0;
  for(const m of myPicks){
    const mObj = heroByName[m];
    if(!mObj) continue;
    const matchups = await fetchMatchups(mObj.id);
    let total = 0, cnt = 0;
    for(const e of enemyPicks){
      const eObj = heroByName[e]; if(!eObj) continue;
      const entry = matchups.find(it=>it.hero_id === eObj.id);
      const wr = entry ? entry.win_rate : 0.5;
      total += wr; cnt++;
    }
    if(cnt) myScore += (total/cnt);
  }
  myScore = myScore / (myPicks.length || 1);

  // enemy score symmetrical: for each enemy hero compute avg vs my picks
  let enScore = 0;
  for(const e of enemyPicks){
    const eObj = heroByName[e];
    if(!eObj) continue;
    const matchups = await fetchMatchups(eObj.id);
    let total = 0, cnt = 0;
    for(const m of myPicks){
      const mObj = heroByName[m]; if(!mObj) continue;
      const entry = matchups.find(it=>it.hero_id === mObj.id);
      const wr = entry ? entry.win_rate : 0.5;
      // here wins are for eObj vs mObj; if eObj has high win_rate -> enemy advantage
      total += wr; cnt++;
    }
    if(cnt) enScore += (total/cnt);
  }
  enScore = enScore / (enemyPicks.length || 1);

  // convert to percent estimate: higher myScore relative to enScore -> advantage
  // we combine: base 50 + 20*(myScore-enScore)
  let estimate = 50 + 20 * (myScore - enScore);
  estimate = Math.max(10, Math.min(90, estimate));
  winEstimateEl.textContent = `${estimate.toFixed(0)}%`;

  // simple textual analysis
  let text = `–ú–æ—ó –ø—ñ–∫–∏: ${myPicks.join(', ') || '‚Äî'}\n–í–æ—Ä–æ–≥–∏: ${enemyPicks.join(', ') || '‚Äî'}\n`;
  text += `–°–µ—Ä–µ–¥–Ω—ñ–π –ø–æ–∫–∞–∑–Ω–∏–∫ –º–æ—î—ó –∫–æ–º–∞–Ω–¥–∏: ${(myScore*100).toFixed(0)}% ; –≤–æ—Ä–æ–∂–æ—ó: ${(enScore*100).toFixed(0)}%`;
  analysisText.textContent = text;
}

/* ============================
   Show final results
   ============================ */

function showResults(){
  roleScreen.style.display = 'none';
  draftScreen.style.display = 'none';
  resultsScreen.style.display = 'block';
  // fill final lists
  finalMy.innerHTML = '';
  finalEnemy.innerHTML = '';
  picked.my.forEach((h,i)=>{
    const short = h ? heroShort[h] : null;
    const img = short ? `https://api.opendota.com/apps/dota2/images/heroes/${short}_full.png` : '';
    const div = document.createElement('div');
    div.style.display='flex';div.style.gap='8px';div.style.alignItems='center';div.style.marginBottom='6px';
    div.innerHTML = `<div style="width:44px;height:26px;border-radius:4px;overflow:hidden"><img src="${img}" style="width:100%;height:100%;object-fit:cover" /></div><div style="flex:1">${h||'‚Äî'}</div><div class="tiny">slot ${i+1}</div>`;
    finalMy.appendChild(div);
  });
  picked.enemy.forEach((h,i)=>{
    const short = h ? heroShort[h] : null;
    const img = short ? `https://api.opendota.com/apps/dota2/images/heroes/${short}_full.png` : '';
    const div = document.createElement('div');
    div.style.display='flex';div.style.gap='8px';div.style.alignItems='center';div.style.marginBottom='6px';
    div.innerHTML = `<div style="width:44px;height:26px;border-radius:4px;overflow:hidden"><img src="${img}" style="width:100%;height:100%;object-fit:cover" /></div><div style="flex:1">${h||'‚Äî'}</div><div class="tiny">slot ${i+1}</div>`;
    finalEnemy.appendChild(div);
  });

  // final estimate + strategy
  // For final estimate, call computeLiveEstimate (but it's async)
  (async ()=>{
    await computeLiveEstimate();
    finalWin.textContent = winEstimateEl.textContent;
    finalStrategy.textContent = getStrategy(picked.my);
    // final analysis text
    finalAnalysis.textContent = analysisText.textContent + '\n' + 'üîé –ü–æ—Ä–∞–¥–∏: –≤–∏–±–∏—Ä–∞–π –≥–µ—Ä–æ—è, —è–∫–∏–π –º–∞—î –≤–∏—Å–æ–∫–∏–π —Å–µ—Ä–µ–¥–Ω—ñ–π winrate –ø—Ä–æ—Ç–∏ –≤–∏–±—Ä–∞–Ω–∏—Ö –≤–æ—Ä–æ–≥—ñ–≤ —ñ —Å–∏–Ω–µ—Ä–≥—ñ–π–Ω–∏–π —ñ–∑ —Å–æ—é–∑–Ω–∏–∫–∞–º–∏.';
  })();
}

/* ============================
   Simple strategy function
   ============================ */

function getStrategy(myHeroes){
  // re-use previous heuristic
  const carry = ["Spectre","Terrorblade","Medusa","Anti-Mage","Faceless Void","Naga Siren"];
  const push = ["Lycan","Nature's Prophet","Shadow Shaman","Death Prophet","Broodmother"];
  const fight = ["Magnus","Phoenix","Disruptor","Tidehunter","Enigma","Kunkka"];
  const heal = ["Dazzle","Omniknight","Treant Protector","Warlock"];
  const burst = ["Lina","Lion","Pugna","Zeus","Tinker"];

  let score = {carry:0,push:0,fight:0,heal:0,burst:0};
  for(const h of myHeroes){
    if(carry.includes(h)) score.carry++;
    if(push.includes(h)) score.push++;
    if(fight.includes(h)) score.fight++;
    if(heal.includes(h)) score.heal++;
    if(burst.includes(h)) score.burst++;
  }
  const max = Object.keys(score).reduce((a,b)=>score[a]>score[b]?a:b);
  switch(max){
    case 'carry': return '–ü–µ—Ä–µ–≤–∞–≥–∞ –≤ –ª–µ–π—Ç—ñ ‚Äî —Ä–æ–∑–∫–∞—á–∞–π—Ç–µ—Å—è –¥–æ 30 —Ö–≤.';
    case 'push': return '–°–∏–ª—å–Ω–∏–π –ø—É—à ‚Äî –∑–∞—á–∏—Å—Ç—ñ—Ç—å –≤–µ–∂—ñ —ñ –∑–∞–≤–µ—Ä—à—ñ—Ç—å –≥—Ä—É —Ä–∞–Ω—ñ—à–µ.';
    case 'fight': return '–ü–æ—Ç—É–∂–Ω—ñ –∫–æ–º–∞–Ω–¥–Ω—ñ –±–æ—ó ‚Äî —ñ–Ω—ñ—Ü—ñ—é–π—Ç–µ –∑ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º.';
    case 'heal': return '–°—Ç—ñ–π–∫–∞ –∫–æ–º–∞–Ω–¥–∞ ‚Äî –≥—Ä–∞–π—Ç–µ –≤—ñ–¥ –≤–∏–∂–∏–≤–∞–Ω–Ω—è —ñ –≤–∏—Ç—Ä–∏–º–∫–∏.';
    case 'burst': return '–í–∏–±—É—Ö–æ–≤–∏–π —É—Ä–æ–Ω ‚Äî —Ñ–æ–∫—É—Å—É–π—Ç–µ –∫–ª—é—á–æ–≤—ñ —Ü—ñ–ª—ñ.';
    default: return '–ó–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—è ‚Äî –≥–Ω—É—á–∫—ñ—Å—Ç—å —ñ –º—ñ–∫—Ä–æ –≤–∞–∂–ª–∏–≤—ñ.';
  }
}

/* ============================
   Button handlers: start / restart
   ============================ */

startBtn.addEventListener('click', ()=>{
  if(!playerRole){ alert('–û–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º'); return; }
  roleScreen.style.display = 'none';
  draftScreen.style.display = 'block';
  setStage(0);
  renderSlots();
  updateSuggestions();
});

useDefaultBtn.addEventListener('click', ()=>{
  // choose random role
  const r = roleKeys[Math.floor(Math.random()*roleKeys.length)];
  document.querySelectorAll('.role-btn').forEach(b=>{
    b.classList.toggle('active', b.textContent === r);
  });
  playerRole = r;
  startBtn.disabled = false;
  myRoleLabel.textContent = r;
});

restartBtn.addEventListener('click', ()=>{
  // reset everything
  picked = {my:Array(5).fill(null), enemy:Array(5).fill(null)};
  playerRole = null;
  currentStage = 0;
  matchupCache = {};
  // UI reset
  roleScreen.style.display = 'block';
  draftScreen.style.display = 'none';
  resultsScreen.style.display = 'none';
  document.querySelectorAll('.role-btn').forEach(b=>b.classList.remove('active'));
  startBtn.disabled = true;
  pickerContext.textContent = '–û–±–µ—Ä—ñ—Ç—å —Å–ª–æ—Ç —â–æ–± –ø–æ—á–∞—Ç–∏ –ø—ñ–∫—É';
  document.getElementById('hero-search').value = '';
  renderRoleButtons();
  renderFilteredHeroes();
  renderSlots();
  suggestionsEl.innerHTML = '';
  winEstimateEl.textContent = '‚Äî';
  analysisText.textContent = '';
});

/* ============================
   Init
   ============================ */

await loadHeroList();
renderSlots();
updateSuggestions(); // initial (will ask to pick enemy picks)
computeLiveEstimate();

})(); // IIFE
</script>
</body>
</html>







