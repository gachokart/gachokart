<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dota 2 ‚Äî –ú–æ—è –∫–æ–º–∞–Ω–¥–∞ vs –°—É–ø–µ—Ä–Ω–∏–∫</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1e1e1e;
      color: #eee;
      padding: 20px;
    }
    h1, h2 { text-align: center; }
    .teams {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .team {
      background: #222;
      padding: 15px;
      border-radius: 8px;
      width: 48%;
      box-sizing: border-box;
    }
    select {
      width: 100%;
      padding: 8px;
      margin: 6px 0 12px 0;
      font-size: 14px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
    }
    .results {
      margin-top: 30px;
      background: #222;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    .counter {
      display: inline-block;
      background: #444;
      padding: 5px 12px;
      margin: 5px;
      border-radius: 6px;
      color: #fff;
      transition: transform 0.2s;
    }
    .counter:hover {
      transform: scale(1.05);
    }
    .action-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 20px;
      gap: 15px;
    }
    button {
      background: #4caf50;
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover { background: #66bb6a; }
    #win-chance { font-weight: bold; font-size: 18px; }
    #strategy { margin-top: 10px; font-size: 17px; color: #ccc; }
  </style>
</head>
<body>

  <h1>–ú–æ—è –∫–æ–º–∞–Ω–¥–∞ vs –°—É–ø–µ—Ä–Ω–∏–∫ ‚Äî –ö–æ–Ω—Ç—Ä–ø—ñ–∫–∏</h1>

  <div class="teams">
    <div class="team" id="my-team">
      <h2>–ú–æ—è –∫–æ–º–∞–Ω–¥–∞</h2>
      <div id="my-slots"></div>
    </div>

    <div class="team" id="enemy-team">
      <h2>–°—É–ø–µ—Ä–Ω–∏–∫</h2>
      <div id="enemy-slots"></div>
    </div>
  </div>

  <div class="action-bar">
    <button id="go-button">Go</button>
    <span id="win-chance"></span>
  </div>
  <div id="strategy"></div>

  <div class="results" id="results-section">
    <h2>–ö–æ–Ω—Ç—Ä–ø—ñ–∫–∏ –¥–ª—è –æ–±—Ä–∞–Ω–∏—Ö –≥–µ—Ä–æ—ó–≤ —Å—É–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</h2>
    <div id="counters-container"></div>
  </div>

  <script>
    // --- –ê–ö–¢–£–ê–õ–¨–ù–Ü –°–ü–ò–°–ö–ò –ì–ï–†–û–á–í –ü–û –†–û–õ–Ø–• (META 2025) ---
    const roleHeroes = {
      Carry: [
        "Phantom Assassin", "Juggernaut", "Sven", "Morphling",
        "Faceless Void", "Medusa", "Spectre", "Anti-Mage",
        "Weaver", "Lifestealer", "Drow Ranger", "Terrorblade"
      ],
      Mid: [
        "Invoker", "Storm Spirit", "Puck", "Queen of Pain",
        "Shadow Fiend", "Ember Spirit", "Tinker", "Leshrac",
        "Zeus", "Death Prophet", "Kunkka", "Windranger"
      ],
      Offlane: [
        "Centaur Warrunner", "Tidehunter", "Mars", "Beastmaster",
        "Dark Seer", "Timbersaw", "Axe", "Bristleback",
        "Underlord", "Doom", "Magnus", "Slardar"
      ],
      "Support 4": [
        "Rubick", "Earth Spirit", "Tusk", "Mirana",
        "Snapfire", "Nyx Assassin", "Phoenix", "Clockwerk",
        "Marci", "Techies", "Pudge", "Spirit Breaker"
      ],
      "Support 5": [
        "Crystal Maiden", "Lion", "Witch Doctor", "Dazzle",
        "Omniknight", "Warlock", "Shadow Shaman", "Lich",
        "Oracle", "Treant Protector", "Bane", "Disruptor"
      ]
    };

    let heroes = [];
    let heroMap = {};
    let nameToId = {};

    async function fetchHeroes() {
      const res = await fetch("https://api.opendota.com/api/heroes");
      const data = await res.json();
      heroes = data.map(h => h.localized_name).sort();
      heroMap = Object.fromEntries(data.map(h => [h.id, h.localized_name]));
      nameToId = Object.fromEntries(data.map(h => [h.localized_name, h.id]));
      initTeamSlots();
      attachEvents();
    }

    function initTeamSlots() {
      const mySlots = document.getElementById("my-slots");
      const enemySlots = document.getElementById("enemy-slots");

      for (let i = 0; i < 5; i++) {
        mySlots.appendChild(createRoleHeroSelect("my"));
        enemySlots.appendChild(createRoleHeroSelect("enemy"));
      }
    }

    function createRoleHeroSelect(type) {
      const container = document.createElement("div");

      const roleSel = document.createElement("select");
      roleSel.innerHTML = `<option value="">-- –û–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å --</option>` +
        Object.keys(roleHeroes).map(r => `<option value="${r}">${r}</option>`).join("");

      const heroSel = document.createElement("select");
      heroSel.innerHTML = `<option value="">-- –°–ø–æ—á–∞—Ç–∫—É –æ–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å --</option>`;
      heroSel.className = `slot ${type}`;

      roleSel.addEventListener("change", () => {
        const role = roleSel.value;
        heroSel.innerHTML = `<option value="">-- –û–±–µ—Ä—ñ—Ç—å –≥–µ—Ä–æ—è --</option>`;
        if (roleHeroes[role]) {
          roleHeroes[role].forEach(h => {
            const opt = document.createElement("option");
            opt.value = h;
            opt.textContent = h;
            heroSel.appendChild(opt);
          });
        }
        updateSelectOptions();
      });

      heroSel.addEventListener("change", async () => {
        updateSelectOptions();
        await showCounters();
      });

      container.appendChild(roleSel);
      container.appendChild(heroSel);
      return container;
    }

    function attachEvents() {
      document.getElementById("go-button").addEventListener("click", async () => {
        const myHeroes = Array.from(document.querySelectorAll(".slot.my")).map(s => s.value).filter(v => v);
        const enemyHeroes = Array.from(document.querySelectorAll(".slot.enemy")).map(s => s.value).filter(v => v);
        const winEl = document.getElementById("win-chance");
        const stratEl = document.getElementById("strategy");
        const resultsSection = document.getElementById("results-section");

        if (myHeroes.length === 5 && enemyHeroes.length === 5) {
          resultsSection.style.display = "none";
          winEl.textContent = "–û–±—á–∏—Å–ª—é—î–º–æ...";
          stratEl.textContent = "";

          const chance = calcFastWinChance(myHeroes, enemyHeroes);

          setTimeout(() => {
            winEl.textContent = `–®–∞–Ω—Å –Ω–∞ –ø–µ—Ä–µ–º–æ–≥—É: ${chance.toFixed(1)}%`;
            winEl.style.color = chance > 55 ? "#4caf50" : chance < 45 ? "#f44336" : "#ffeb3b";
            stratEl.textContent = `üîç ${getStrategy(myHeroes)}`;
          }, 1500);
        } else {
          winEl.textContent = "–û–±–µ—Ä—ñ—Ç—å —É—Å—ñ—Ö 10 –≥–µ—Ä–æ—ó–≤!";
        }
      });
    }

    function updateSelectOptions() {
      const allSelected = Array.from(document.querySelectorAll("select.slot"))
        .map(s => s.value).filter(v => v);

      document.querySelectorAll("select.slot").forEach(sel => {
        const currentValue = sel.value;
        Array.from(sel.options).forEach(opt => {
          if (!opt.value) return;
          opt.disabled = (opt.value !== currentValue && allSelected.includes(opt.value));
        });
      });
    }

    async function fetchCounters(heroName) {
      const heroId = nameToId[heroName];
      if (!heroId) return [];
      const res = await fetch(`https://api.opendota.com/api/heroes/${heroId}/matchups`);
      const data = await res.json();
      data.forEach(d => d.win_rate = d.wins / d.games_played);
      data.sort((a, b) => a.win_rate - b.win_rate);
      return data.slice(0, 10).map(d => heroMap[d.hero_id]);
    }

    async function showCounters() {
      const container = document.getElementById("counters-container");
      const resultsSection = document.getElementById("results-section");
      container.innerHTML = "";

      const myHeroes = Array.from(document.querySelectorAll(".slot.my")).map(s => s.value).filter(v => v);
      const enemyHeroes = Array.from(document.querySelectorAll(".slot.enemy")).map(s => s.value).filter(v => v);

      if (myHeroes.length === 5 && enemyHeroes.length === 5) {
        resultsSection.style.display = "none";
        return;
      } else {
        resultsSection.style.display = "block";
      }

      if (enemyHeroes.length === 0) {
        container.textContent = "–û–±–µ—Ä—ñ—Ç—å –≥–µ—Ä–æ—ó–≤ —Å—É–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–ø—ñ–∫—ñ–≤.";
        return;
      }

      let counterCounts = {};
      for (let h of enemyHeroes) {
        const counters = await fetchCounters(h);
        counters.forEach(c => counterCounts[c] = (counterCounts[c] || 0) + 1);
      }

      const sorted = Object.entries(counterCounts).sort((a, b) => b[1] - a[1]);
      sorted.forEach(([name, count]) => {
        const div = document.createElement("div");
        div.className = "counter";
        div.textContent = `${name} (√ó${count})`;
        container.appendChild(div);
      });
    }

    function calcFastWinChance(myHeroes, enemyHeroes) {
      let base = 50;
      for (let my of myHeroes) base += (my.charCodeAt(0) % 5 - 2);
      for (let en of enemyHeroes) base -= (en.charCodeAt(0) % 5 - 2);
      return Math.max(30, Math.min(70, base + (Math.random() * 6 - 3)));
    }

    function getStrategy(heroes) {
      const carry = ["Spectre", "Terrorblade", "Medusa", "Anti-Mage", "Faceless Void", "Naga Siren"];
      const push = ["Lycan", "Nature's Prophet", "Shadow Shaman", "Death Prophet", "Broodmother"];
      const fight = ["Magnus", "Phoenix", "Disruptor", "Tidehunter", "Enigma", "Kunkka"];
      const heal = ["Dazzle", "Omniknight", "Treant Protector", "Warlock"];
      const burst = ["Lina", "Lion", "Pugna", "Zeus", "Tinker"];

      let score = { carry: 0, push: 0, fight: 0, heal: 0, burst: 0 };
      for (let h of heroes) {
        if (carry.includes(h)) score.carry++;
        if (push.includes(h)) score.push++;
        if (fight.includes(h)) score.fight++;
        if (heal.includes(h)) score.heal++;
        if (burst.includes(h)) score.burst++;
      }

      const max = Object.keys(score).reduce((a, b) => score[a] > score[b] ? a : b);
      switch (max) {
        case "carry": return "–ü–µ—Ä–µ–≤–∞–≥–∞ –≤ –ª–µ–π—Ç—ñ ‚Äî —Ä–æ–∑–∫–∞—á–∞–π—Ç–µ—Å—è –¥–æ 30 —Ö–≤–∏–ª–∏–Ω–∏!";
        case "push": return "–°–∏–ª—å–Ω–∏–π –ø—É—à ‚Äî –∑–∞–≤–µ—Ä—à—É–π—Ç–µ –≥—Ä—É —Ä–∞–Ω–æ.";
        case "fight": return "–ü–æ—Ç—É–∂–Ω–∞ –∫–æ–º–∞–Ω–¥–Ω–∞ –±—ñ–π–∫–∞ ‚Äî —ñ–Ω—ñ—Ü—ñ—é–π—Ç–µ –π –≥—Ä–∞–π—Ç–µ —Ä–∞–∑–æ–º!";
        case "heal": return "–°—Ç—ñ–π–∫—ñ—Å—Ç—å ‚Äî —Ç—Ä–∏–º–∞–π—Ç–µ –ø–æ–∑–∏—Ü—ñ—ó —Ç–∞ –≥—Ä–∞–π—Ç–µ –≤—ñ–¥ –≤–∏–∂–∏–≤–∞–Ω–Ω—è.";
        case "burst": return "–í–∏–±—É—Ö–æ–≤–∏–π —É—Ä–æ–Ω ‚Äî –∑–Ω–∏—â—É–π—Ç–µ –∫–ª—é—á–æ–≤—ñ —Ü—ñ–ª—ñ —à–≤–∏–¥–∫–æ!";
        default: return "–ó–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—è ‚Äî –≤—Å–µ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –º—ñ–∫—Ä–æ.";
      }
    }

    window.onload = fetchHeroes;
  </script>
</body>
</html>






