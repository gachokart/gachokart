<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>game1 — Аналітика і закономірності</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{--bg:#0b1220;--card:#09111a;--muted:#9aa7bd;--accent:#1f8feb}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#071027 0%,#07111b 100%);color:#e6eef6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
    .wrap{max-width:1100px;width:100%}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    input,button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:9px;border-radius:8px;color:inherit}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);text-align:left}
    .meta{font-size:13px;color:var(--muted)}
    .prediction{padding:12px;border-radius:10px;margin-bottom:10px}
    .pred-good{background:linear-gradient(90deg,#063b12,#0d6430);color:#dfffe0}
    .pred-bad{background:linear-gradient(90deg,#3b0606,#641010);color:#ffe0e0}
    .pred-neutral{background:linear-gradient(90deg,#2a2a3b,#3b3b5a);color:#fff}
    .reason{font-size:13px;margin:6px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    #patterns{display:none;margin-top:12px}
    .charts{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .hero-list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .hero-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hero-item img{width:48px;height:28px;object-fit:cover;border-radius:4px}
    @media (max-width:920px){.grid{grid-template-columns:1fr} .charts{grid-template-columns:1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="card" style="flex:1;display:flex;align-items:center;justify-content:space-between;padding:12px">
      <div>
        <h1>game1 — Прогноз + Закономірності</h1>
        <div class="small">OpenDota аналіз останніх ігор → прогноз, закономірності, графіки, топ-3 героїв.</div>
      </div>
      <div class="small">Тестовий ID: <strong>863386335</strong></div>
    </div>
  </header>

  <div class="card">
    <div style="display:flex;flex-direction:column">
      <label>Steam64 ID або OpenDota account_id:</label>
      <div class="inputs">
        <input id="idInput" placeholder="Steam64 або account_id" />
        <select id="limitSelect">
          <option value="20">Останні 20 ігор</option>
          <option value="50">Останні 50 ігор</option>
          <option value="100">Останні 100 ігор</option>
        </select>
        <button id="fetchBtn">Отримати прогноз</button>
        <button id="patternsBtn">Показати закономірності</button>
        <button id="demoBtn">Тестовий ID</button>
      </div>
      <div class="small" style="margin-top:8px">Натисни «Показати закономірності» після отримання прогнозу — побудуються графіки winrate по днях і годинах і виявляться повторювані патерни.</div>
    </div>
  </div>

  <div class="grid">
    <div class="card" id="leftCard">
      <h3>Останні матчі</h3>
      <div id="statsSummary" class="meta"></div>
      <div style="margin-top:8px;max-height:420px;overflow:auto">
        <table id="matchesTable">
          <thead><tr><th>Дата</th><th>Герой</th><th>K/D/A</th><th>Результат</th><th>Тривалість</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <aside class="card" id="rightCard">
      <h3>Прогноз на наступний матч</h3>
      <div id="predictionArea" class="prediction pred-neutral">Очікування...</div>
      <div id="predictionDetails" class="meta"></div>
      <div id="patterns" class="meta card">
        <h4>Закономірності матчів</h4>
        <div class="charts">
          <canvas id="chartDays" width="400" height="200"></canvas>
          <canvas id="chartHours" width="400" height="200"></canvas>
        </div>
        <div id="patternText" style="margin-top:10px"></div>
        <h4 style="margin-top:10px">Топ-3 герої</h4>
        <div id="topHeroes" class="hero-list"></div>
      </div>
    </aside>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // ==== Глобальні змінні
  let lastMatches = null, lastSummary = null, lastHeroesConst = null;

  // ---- Утиліти
  function steam64ToAccountId(steam64){ try{ const n=BigInt(steam64); const base=BigInt('76561197960265728'); if(n<=BigInt(4294967295)) return Number(n); return Number(n-base);}catch(e){return NaN} }
  function playerWon(m){ const playerRadiant = (m.player_slot||0) < 128; return (playerRadiant && m.radiant_win) || (!playerRadiant && !m.radiant_win); }
  function secsToMinSecs(s){ const m=Math.floor(s/60), sec=s%60; return m+':'+String(sec).padStart(2,'0'); }
  const winrate = (wins,games)=>games?wins/games*100:0;

  // ==== Завантаження героїв
  const HERO_CACHE_KEY = 'heroesCache';
  const CACHE_EXPIRY_MS = 24*60*60*1000; // 1 день

  async function fetchHeroesWithCache() {
    const cached = localStorage.getItem(HERO_CACHE_KEY);
    if(cached){
      const parsed=JSON.parse(cached);
      if(Date.now()-parsed.timestamp<CACHE_EXPIRY_MS){ console.log('Використовується кеш героїв'); return parsed.data; }
    }
    console.log('Підтягуємо героїв з OpenDota');
    const res=await fetch('https://api.opendota.com/api/constants/heroes'); 
    if(!res.ok) throw new Error('OpenDota heroes fetch failed');
    const heroesConstRaw = await res.json();
    const heroList = Object.values(heroesConstRaw).map(h=>({
      id: h.id, name: h.localized_name, roles:[h.attack_type,...h.roles], img:h.img?'https://api.opendota.com'+h.img:null, winrate:h.pro_win||0, pickrate:h.pro_pick||0
    }));
    localStorage.setItem(HERO_CACHE_KEY, JSON.stringify({timestamp:Date.now(), data:heroList}));
    return heroList;
  }

  // ==== Аналіз матчів
  function analyzeMatches(matches){
    const out={games:matches.length,wins:0,k:0,d:0,a:0,dur:0,shortWins:0,shortLosses:0,longWins:0,longLosses:0,leaves:0,byHero:{},seq:[]};
    for(const m of matches){
      const won=playerWon(m);
      out.seq.push(won?'W':'L');
      if(won) out.wins++;
      const kills=m.kills||0,deaths=m.deaths||0,assists=m.assists||0,duration=m.duration||0;
      out.k+=kills; out.d+=deaths; out.a+=assists; out.dur+=duration;
      if(duration<1500 && won) out.shortWins++; if(duration<1500 && !won) out.shortLosses++;
      if(duration>2700 && won) out.longWins++; if(duration>2700 && !won) out.longLosses++;
      if(m.leaver_status && m.leaver_status!==0) out.leaves++;
      const hid=m.hero_id||0;
      if(!out.byHero[hid]) out.byHero[hid]={games:0,wins:0};
      out.byHero[hid].games++; if(won) out.byHero[hid].wins++;
    }
    out.winrate=out.games?out.wins/out.games*100:0;
    out.avgK=out.games?out.k/out.games:0;
    out.avgD=out.games?out.d/out.games:0;
    out.avgA=out.games?out.a/out.games:0;
    out.avgKDA=out.avgD?(out.avgK+out.avgA)/out.avgD:(out.avgK+out.avgA);
    out.avgDuration=out.games?out.dur/out.games:0;
    out.pctShortWins=out.games?out.shortWins/out.games*100:0;
    out.pctShortLosses=out.games?out.shortLosses/out.games*100:0;
    out.pctLongWins=out.games?out.longWins/out.games*100:0;
    out.pctLongLosses=out.games?out.longLosses/out.games*100:0;
    out.leaveRate=out.games?out.leaves/out.games*100:0;
    return out;
  }

  function analyzePhases(matches){
  const phases = [
    {name:'0-27 хв', min:0, max:1620, games:0, wins:0, recentScore:0},
    {name:'27-37 хв', min:1620, max:2220, games:0, wins:0, recentScore:0},
    {name:'37-60 хв', min:2220, max:3600, games:0, wins:0, recentScore:0}
  ];
  for(let i=0;i<matches.length;i++){
    const m = matches[i];
    const dur = m.duration||0;
    const won = playerWon(m);
    const phase = phases.find(p=>dur>=p.min && dur< p.max);
    if(phase){
      phase.games++;
      if(won) phase.wins++;
      // Додатково: динаміка останніх матчів
      phase.recentScore += won?1:-1;
    }
  }
  phases.forEach(p=>p.winrate=p.games?p.wins/p.games*100:0);
  return phases;
}

  // ==== Прогноз (спрощений)
  const defaultWeights = { winrate:0.9, kda:6, shortGamePenalty:-3, shortLossPenalty:-4, leaveRatePenalty:v=>-Math.min(10,Math.round(v)) };
  function computeDetailedProbabilities(summary,w=defaultWeights){
    const reasons=[];
    let winProb=50;
    winProb+= (summary.winrate-50)*w.winrate; reasons.push({factor:"Winrate",value:summary.winrate});
    winProb+= (summary.avgKDA-2)*w.kda; reasons.push({factor:"KDA",value:summary.avgKDA});
    if(summary.avgDuration<1200){ winProb+=w.shortGamePenalty; reasons.push({factor:"Short games"});}
    if(summary.pctShortLosses>20){ winProb+=w.shortLossPenalty; reasons.push({factor:"Short losses"});}
    if(summary.leaveRate>5){ const v=w.leaveRatePenalty(summary.leaveRate); winProb+=v; reasons.push({factor:"Leave rate"});}
    winProb=Math.max(3,Math.min(97,Math.round(winProb)));
    return {winProb,reasons};
  }

  // ==== Рендер матчів
  function renderMatches(matches, heroesConst){
    const tbody=document.querySelector('#matchesTable tbody'); 
    tbody.innerHTML='';
    matches.forEach(m=>{
      const tr=document.createElement('tr');
      const d=new Date((m.start_time||0)*1000);
      const hid=m.hero_id||0;
      const heroData = heroesConst[hid] || {};
      const heroName = heroData.name||`Hero ${hid}`;
      const heroImg = heroData.img||'';
      tr.innerHTML=`
        <td>${d.toLocaleString()}</td>
        <td><img src="${heroImg}" alt="${heroName}" style="width:28px;height:16px;object-fit:cover;border-radius:3px;margin-right:4px;vertical-align:middle">${heroName}</td>
        <td>${m.kills||0}/${m.deaths||0}/${m.assists||0}</td>
        <td>${playerWon(m)?'W':'L'}</td>
        <td>${secsToMinSecs(m.duration||0)}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  // ==== Рендер прогнозу
  function renderPredictionUI(summary,pred){
    const area=document.getElementById('predictionArea');
    const details=document.getElementById('predictionDetails');
    area.className='prediction '+(pred.winProb>=50?'pred-good':'pred-bad');
    area.textContent=`Ймовірність перемоги: ${pred.winProb}%`;
    details.innerHTML=pred.reasons.map(r=>`${r.factor}`).join(', ');
  }

  // ==== Аналіз топ-героїв
  function analyzeTopHeroes(summary, heroesConst, minGames=2){
    const heroStats=[];
    for(const id in summary.byHero){
      const data=summary.byHero[id];
      if(data.games>=minGames){
        const hero=heroesConst[id]||{};
        heroStats.push({id,name:hero.name||`Hero ${id}`,games:data.games,wins:data.wins,winrate:winrate(data.wins,data.games)});
      }
    }
    heroStats.sort((a,b)=>b.winrate-a.winrate);
    return heroStats.slice(0,3);
  }

  // ==== Патерни (дні/години/послідовності)
  function analyzePatterns(matches, summary, heroesConst){
    const days=Array(7).fill(0).map(()=>({games:0,wins:0}));
    const hours=Array(24).fill(0).map(()=>({games:0,wins:0}));
    for(const m of matches){
      const d=new Date((m.start_time||0)*1000);
      const won=playerWon(m);
      days[d.getDay()].games++; if(won) days[d.getDay()].wins++;
      hours[d.getHours()].games++; if(won) hours[d.getHours()].wins++;
    }
    const top3=analyzeTopHeroes(summary,heroesConst,2);
    return {dayRates:days,hourRates:hours,top3};
  }

  // ==== Рендер патернів
  function renderPatternsUI(patterns, heroesConst){
    document.getElementById('patterns').style.display='block';
    const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML='';
    if(patterns.top3.length===0){
      topRoot.innerHTML='<div class="small">Недостатньо ігор на героях (min 2)</div>';
    } else {
      patterns.top3.forEach(h=>{
        const heroData = heroesConst[h.id]||{};
        const el=document.createElement('div'); el.className='hero-item';
        const img=document.createElement('img'); img.src=heroData.img||''; img.alt=h.name;
        const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% · Ігор: ${h.games}</div>`;
        el.appendChild(img); el.appendChild(info); topRoot.appendChild(el);
      });
    }

    // ---- Рендер статистики по фазах та прогноз тривалості гри
function renderPhaseStats(summary, predictedLength){
  const container = document.createElement('div');
  container.innerHTML = '<h4>Статистика по тривалості матчів (фази)</h4>';
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr><th>Фаза</th><th>Ігор</th><th>Winrate %</th><th>Динаміка</th></tr>
    </thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');
  const phases = analyzePhases(lastMatches); 
  phases.forEach(p => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${p.name}</td>
      <td>${p.games}</td>
      <td>${p.winrate.toFixed(1)}</td>
      <td>${(p.recentScore*5).toFixed(1)}%</td>
    `;
    tbody.appendChild(tr);
  });
  container.appendChild(table);

  const predDiv = document.createElement('div');
  predDiv.style.marginTop='8px';
  predDiv.innerHTML = `<strong>Прогнозована тривалість наступної гри:</strong> ${secsToMinSecs(predictedLength)}`;
  container.appendChild(predDiv);

  document.getElementById('predictionDetails').appendChild(container);
}


  // Прогноз тривалості гри
  const predDiv = document.createElement('div');
  predDiv.style.marginTop='8px';
  predDiv.innerHTML = `<strong>Прогнозована тривалість наступної гри:</strong> ${secsToMinSecs(predictedLength)}`;
  container.appendChild(predDiv);

  document.getElementById('predictionDetails').appendChild(container);
}
document.getElementById('fetchBtn').addEventListener('click', async ()=> {
  const raw = document.getElementById('idInput').value.trim();
  if(!raw) return alert('Введіть ID');

  const id = raw.length > 12 ? steam64ToAccountId(raw) : Number(raw);
  if(isNaN(id)) return alert('Не вдалося розпізнати ID');

  const limit = Number(document.getElementById('limitSelect').value);
  document.getElementById('predictionArea').textContent = 'Завантаження...';

  try {
    // 🔹 Завантажуємо матчі
    const matches = await fetchOpenDotaMatches(id, limit);

    // 🔹 Завантажуємо кешованих героїв (або оновлюємо)
    const heroesList = await fetchHeroesWithCache();

    // 🔹 Формуємо об’єкт для зручного доступу по id
    const heroesConst = {};
    heroesList.forEach(h => heroesConst[h.id] = h);

    lastMatches = matches;
    lastSummary = analyzeMatches(matches);
    lastHeroesConst = heroesConst;

    // ---- Ось сюди вставляємо блок ----
    const pred = computeDetailedProbabilities(lastSummary);
renderMatches(lastMatches,lastHeroesConst);
renderPredictionUI(lastSummary,pred);
document.getElementById('predictionDetails').innerHTML='';
renderPhaseStats(lastSummary,predictedLength=lastSummary.avgDuration);

    // ховаємо патерни поки не натиснули кнопку
    document.getElementById('patterns').style.display = 'none';

  } catch(err) {
    console.error(err);
    document.getElementById('predictionArea').textContent = 'Помилка: ' + err.message;
  }
});

    // Тут можна додати chart.js графіки (дні/години)
    function renderPatternsUI(patterns, heroesConst){
  document.getElementById('patterns').style.display='block';
  
  // ---- Топ-3 герої
  const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML='';
  if(patterns.top3.length===0){
    topRoot.innerHTML='<div class="small">Недостатньо ігор на героях (min 2)</div>';
  } else {
    patterns.top3.forEach(h=>{
      const heroData = heroesConst[h.id]||{};
      const el=document.createElement('div'); el.className='hero-item';
      const img=document.createElement('img'); img.src=heroData.img||''; img.alt=h.name;
      const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% · Ігор: ${h.games}</div>`;
      el.appendChild(img); el.appendChild(info); topRoot.appendChild(el);
    });
  }

  // ---- Chart.js: Winrate по днях тижня (bar)
  const daysLabels=['Нд','Пн','Вт','Ср','Чт','Пт','Сб'];
  const daysData = patterns.dayRates.map(d => d.games ? (d.wins/d.games*100).toFixed(1) : 0);
  const ctxDays = document.getElementById('chartDays').getContext('2d');
  if(window.chartDays) window.chartDays.destroy();
  window.chartDays = new Chart(ctxDays, {
    type:'bar',
    data:{labels:daysLabels,datasets:[{label:'Winrate %',data:daysData,backgroundColor:'#1f8feb'}]},
    options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,max:100}}}
  });

  // ---- Chart.js: Winrate по годинам доби (pie)
  const hoursLabels=Array.from({length:24},(_,i)=>i+'h');
  const hoursData = patterns.hourRates.map(h => h.games ? (h.wins/h.games*100).toFixed(1) : 0);
  const ctxHours = document.getElementById('chartHours').getContext('2d');
  if(window.chartHours) window.chartHours.destroy();
  window.chartHours = new Chart(ctxHours,{
    type:'pie',
    data:{
      labels:hoursLabels,
      datasets:[{label:'Winrate по годинам %',data:hoursData,backgroundColor:hoursLabels.map((_,i)=>`hsl(${i*15},70%,50%)`)}]
    },
    options:{responsive:true,plugins:{legend:{position:'right'}}}
  });
}

  }

  // ==== Події кнопок
  document.getElementById('fetchBtn').addEventListener('click',async()=>{
    const idStr=document.getElementById('idInput').value.trim();
    if(!idStr){ alert('Введіть Steam64 або account_id'); return; }
    const accountId=steam64ToAccountId(idStr)||parseInt(idStr,10);
    if(isNaN(accountId)){ alert('Невірний ID'); return; }

    try{
      const heroesList = await fetchHeroesWithCache();
      const heroesConst={}; heroesList.forEach(h=>heroesConst[h.id]=h);
      lastHeroesConst=heroesConst;

      const limit = parseInt(document.getElementById('limitSelect').value,10)||20;
      const res = await fetch(`https://api.opendota.com/api/players/${accountId}/matches?limit=${limit}`);
      if(!res.ok) throw new Error('Не вдалося отримати матчі');
      const matches = await res.json(); lastMatches = matches;

      const summary = analyzeMatches(matches); lastSummary=summary;

      renderMatches(matches, heroesConst);
      const pred=computeDetailedProbabilities(summary);
      renderPredictionUI(summary,pred);

    }catch(e){ console.error(e); alert('Помилка: '+e.message);}
  });

  document.getElementById('patternsBtn').addEventListener('click',async()=>{
    if(!lastMatches||!lastSummary||!lastHeroesConst){ alert('Спочатку отримайте прогноз'); return; }
    try{
      const patterns = analyzePatterns(lastMatches,lastSummary,lastHeroesConst);
      renderPatternsUI(patterns,lastHeroesConst);
    }catch(e){ console.error(e); alert('Помилка побудови закономірностей: '+e.message);}
  });

  document.getElementById('demoBtn').addEventListener('click',()=>{
    document.getElementById('idInput').value='863386335';
  });

</script>
</body>
</html>



