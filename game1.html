<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Dota 2 Match Predictor (OpenDota)</title>
  <style>
    body { background:#111; color:#eee; font-family:monospace; padding:20px; }
    h1 { color:#6cf; }
    h2 { color:#9cf; }
    h3 { color:#acf; }
    .match { margin:5px 0; padding:5px; border-bottom:1px solid #333; }
    .good { color:#6f6; }
    .bad  { color:#f66; }
    table { border-collapse: collapse; margin:10px 0; width:auto; }
    th, td { border:1px solid #333; padding:6px 8px; text-align:left; }
    img.hero { width:40px; height:40px; vertical-align:middle; margin-right:6px; }
    #boosterRuinerStats { margin:8px 0 16px; }
    .hint { color:#bbb; font-size:12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Dota 2 Match Predictor</h1>

  <!-- Summary, –ø—Ä–æ–≥–Ω–æ–∑, —Ç–∞–±–ª–∏—Ü—ñ -->
  <div id="summary"></div>

  <!-- –ì—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤ (–±—É—Å—Ç–µ—Ä–∏/—Ä—É—ñ–Ω–µ—Ä–∏) -->
  <h3>üìà –ì—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤</h3>
  <canvas id="matchChart" width="900" height="260"></canvas>
  <div id="boosterRuinerStats"></div>

  <!-- –ì—Ä–∞—Ñ—ñ–∫ –ø—Ä–æ–≥–Ω–æ–∑—É –ø–æ —Ä–æ–ª—è—Ö -->
  <h3>üìä –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö (–≥—Ä–∞—Ñ—ñ–∫)</h3>
  <canvas id="roleChart" width="700" height="300"></canvas>
  <p class="hint">–ó–µ–ª–µ–Ω–∏–π —Å—Ç–æ–≤–ø—á–∏–∫ ‚Äî —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å (–Ω–∞–π–≤–∏—â–∏–π –ø—Ä–æ–≥–Ω–æ–∑).</p>

  <!-- –°–ø–∏—Å–æ–∫ –º–∞—Ç—á—ñ–≤ -->
  <div id="matches"></div>

  <script>
    const accountId32 = 863386335; // —Ç–≤—ñ–π Steam32 ID
    const MATCH_COUNT = 100;

    async function fetchMatchHistory() {
      const url = `http://localhost:3000/api/matches?account_id=${accountId32}&count=${MATCH_COUNT}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Server unavailable");
      return await res.json();
    }

    async function getHeroesMap() {
      const res = await fetch("https://api.opendota.com/api/heroes");
      const heroes = await res.json();
      const map = {};
      for (const h of heroes) {
        const short = h.name.replace("npc_dota_hero_", "");
        map[h.id] = {
          name: h.localized_name,
          img: `https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/${short}.png`
        };
      }
      return map;
    }

    function roleLabel(id) {
      const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
      return roleNames[id] || "Unknown";
    }

    function safePercent(n) {
      if (!isFinite(n)) return "0.0";
      return n.toFixed(1);
    }

    function buildPrediction({ winrate, streak, lastResultBool, rolesAgg, boosters, ruiners, total, tempoWr }) {
      let score = winrate;

      // —ñ–º–ø—É–ª—å—Å —Å–µ—Ä—ñ—ó
      if (streak > 2 && lastResultBool) score += 5;
      if (streak > 2 && !lastResultBool) score -= 5;

      // —Ç–µ–º–ø
      if (tempoWr.short > winrate) score += 3;
      if (tempoWr.long  > winrate) score += 3;

      // —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å (–Ω–∞–π–≤–∏—â–∏–π WR —Å–µ—Ä–µ–¥ –Ω–∞—è–≤–Ω–∏—Ö)
      let bestRole = null;
      for (const [rid, agg] of Object.entries(rolesAgg)) {
        if (agg.games === 0) continue;
        if (!bestRole || agg.wr > bestRole.wr) bestRole = { id: Number(rid), wr: agg.wr };
      }
      if (bestRole && bestRole.wr > winrate) score += 4;

      score = Math.max(5, Math.min(95, score));

      const boosterChance = safePercent((boosters / total) * 100);
      const ruinerChance  = safePercent((ruiners  / total) * 100);
      const nextWinStreakChance  = !lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";
      const nextLoseStreakChance =  lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";

      return {
        score: score.toFixed(1),
        boosterChance,
        ruinerChance,
        nextWinStreakChance,
        nextLoseStreakChance,
        recommendedRole: bestRole ? `${roleLabel(bestRole.id)} (${bestRole.wr.toFixed(1)}% WR)` : "–Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö"
      };
    }

    // --- –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö (–≤—Ä–∞—Ö–æ–≤—É—î –±—É—Å—Ç–µ—Ä—ñ–≤/—Ä—É—ñ–Ω–µ—Ä—ñ–≤ –Ω–∞ —Ä–æ–ª—è—Ö) ---
    function predictByRole(matches, rolesAgg) {
      const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
      const roleStats = {};

      for (let r=1; r<=5; r++) {
        const arr = matches.filter(m => m.lane_role === r);
        if (arr.length === 0) continue;

        const baseWR = (arr.filter(m => ((m.player_slot<128)===m.radiant_win)).length/arr.length)*100;

        // –º–∞—Ç—á—ñ –∑ –±—É—Å—Ç–µ—Ä–∞–º–∏ –Ω–∞ —Ü—ñ–π —Ä–æ–ª—ñ (—Å–∏–≥–Ω–∞–ª –∑–∞ KDA)
        const boosterMatches = arr.filter(m => {
          const kda = (m.kills+m.assists)/Math.max(1,m.deaths);
          return kda>=6;
        });
        const boosterWR = boosterMatches.length
          ? (boosterMatches.filter(m => ((m.player_slot<128)===m.radiant_win)).length/boosterMatches.length)*100
          : baseWR;

        // –º–∞—Ç—á—ñ –∑ —Ä—É—ñ–Ω–µ—Ä–∞–º–∏ –Ω–∞ —Ü—ñ–π —Ä–æ–ª—ñ (—Å–∏–≥–Ω–∞–ª –∑–∞ KDA)
        const ruinerMatches = arr.filter(m => {
          const kda = (m.kills+m.assists)/Math.max(1,m.deaths);
          return kda<=1;
        });
        const ruinerWR = ruinerMatches.length
          ? (ruinerMatches.filter(m => ((m.player_slot<128)===m.radiant_win)).length/ruinerMatches.length)*100
          : baseWR;

        // –±—ñ–ª—å—à —Ä–µ–∞–ª—ñ—Å—Ç–∏—á–Ω–µ –∑–º—ñ—à—É–≤–∞–Ω–Ω—è: –±—É—Å—Ç–µ—Ä –º–æ–∂–µ –ø—Ä–æ–≥—Ä–∞—Ç–∏, —Ä—É—ñ–Ω–µ—Ä –º–æ–∂–µ –≤–∏–≥—Ä–∞—Ç–∏.
        // –≤–∞–≥–∏ –æ–±–µ—Ä–µ–∂–Ω—ñ, —â–æ–± –Ω–µ –ø–µ—Ä–µ–æ—Ü—ñ–Ω–∏—Ç–∏ –µ—Ñ–µ–∫—Ç
        let predicted = baseWR;
        if (boosterMatches.length>0) predicted = (predicted*0.65 + boosterWR*0.35);
        if (ruinerMatches.length>0) predicted = (predicted*0.75 + ruinerWR*0.25);

        roleStats[r] = {
          name: roleNames[r],
          baseWR: baseWR.toFixed(1),
          boosterWR: boosterWR.toFixed(1),
          ruinerWR:  ruinerWR.toFixed(1),
          predicted: predicted.toFixed(1)
        };
      }
      return roleStats;
    }

    async function analyzeMatches() {
      try {
        const matches = await fetchMatchHistory();
        const heroesMap = await getHeroesMap();

        if (!matches || matches.length === 0) {
          document.getElementById("summary").innerHTML =
            "‚ùå –ú–∞—Ç—á—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä Steam32 ID –∞–±–æ –æ–Ω–æ–≤–∏ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞ OpenDota.";
          return;
        }

        const container = document.getElementById("matches");

        let total = 0, wins = 0, sumKDA = 0;
        let streak = 0, lastResult = null, avgDuration = 0;
        let boosters = 0, ruiners = 0;
        let allyBoosters = 0, enemyBoosters = 0, allyRuiners = 0, enemyRuiners = 0;

        const roles = {1:[],2:[],3:[],4:[],5:[]};
        const heroes = {};
        const durations = {short:[], mid:[], long:[]};

        const labels = [], colors = [];

        for (const [idx, m] of matches.entries()) {
          const k = m.kills || 0, d = m.deaths || 0, a = m.assists || 0;
          const kda = ((k + a) / Math.max(1, d));
          const win = (m.player_slot < 128) === m.radiant_win;
          const duration = m.duration || 0;

          total++;
          if (win) wins++;
          sumKDA += kda;
          avgDuration += duration;

          // streak
          if (lastResult === null || lastResult === win) streak++;
          else streak = 1;
          lastResult = win;

          // –±—É—Å—Ç–µ—Ä/—Ä—É—ñ–Ω–µ—Ä –≤—ñ–∑—É–∞–ª—å–Ω–∏–π —Å–∏–≥–Ω–∞–ª
          let color = "#888";
          const isAlly = (m.player_slot < 128) === m.radiant_win;
          if (kda >= 6 && win) {
            boosters++;
            color = "green";
            if (isAlly) allyBoosters++; else enemyBoosters++;
          } else if (kda <= 1 && !win) {
            ruiners++;
            color = "red";
            if (isAlly) allyRuiners++; else enemyRuiners++;
          }

          // —Ä–æ–ª—ñ
          if (m.lane_role && roles[m.lane_role]) roles[m.lane_role].push({ win, kda });

          // –≥–µ—Ä–æ—ó
          if (!heroes[m.hero_id]) heroes[m.hero_id] = [];
          heroes[m.hero_id].push({ win, kda });

          // —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
          if (duration < 1800) durations.short.push(win);
          else if (duration < 2400) durations.mid.push(win);
          else durations.long.push(win);

          // –≥—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤
          labels.push("M" + (idx + 1));
          colors.push(color);

          // —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á—ñ–≤
          const heroInfo = heroesMap[m.hero_id];
          const heroCell = heroInfo
            ? `<img class="hero" src="${heroInfo.img}" alt="${heroInfo.name}"> ${heroInfo.name}`
            : `Hero ${m.hero_id}`;
          const div = document.createElement("div");
          div.className = "match";
          div.innerHTML = `Match ${m.match_id}: 
            <span class="${win ? 'good':'bad'}">${win ? 'WIN':'LOSS'}</span> 
            | ${heroCell} | K=${k}, D=${d}, A=${a}, KDA=${kda.toFixed(2)} | ${Math.round(duration/60)} —Ö–≤`;
          container.appendChild(div);
        }

        const winrate = parseFloat(((wins / total) * 100).toFixed(1));
        const avgKDAstr = (sumKDA / total).toFixed(2);
        avgDuration = Math.round((avgDuration / total) / 60);

        // –∞–≥—Ä–µ–≥–∞—Ç–∏ —Ä–æ–ª–µ–π
        const rolesAgg = {};
        for (let r = 1; r <= 5; r++) {
          const arr = roles[r] || [];
          const games = arr.length;
          const wr = games ? (arr.filter(x => x.win).length / games) * 100 : 0;
          const ak = games ? (arr.reduce((s, x) => s + x.kda, 0) / games) : 0;
          rolesAgg[r] = { games, wr, ak };
        }

        // WR –∑–∞ —Ç–µ–º–ø–æ–º
        const tempoWr = {
          short: durations.short.length ? (durations.short.filter(x => x).length / durations.short.length) * 100 : 0,
          mid:   durations.mid.length   ? (durations.mid.filter(x => x).length   / durations.mid.length)   * 100 : 0,
          long:  durations.long.length  ? (durations.long.filter(x => x).length  / durations.long.length)  * 100 : 0
        };

        // –ø—Ä–æ–≥–Ω–æ–∑ –º–∞—Ç—á—É
        const prediction = buildPrediction({
          winrate,
          streak,
          lastResultBool: !!lastResult,
          rolesAgg,
          boosters,
          ruiners,
          total,
          tempoWr
        });

        // Summary + –ü—Ä–æ–≥–Ω–æ–∑
        let html = `<h2>üìä Summary (${total} –º–∞—Ç—á—ñ–≤)</h2>
          Winrate: ${winrate}%<br>
          –°–µ—Ä–µ–¥–Ω—ñ–π KDA: ${avgKDAstr}<br>
          –°–µ—Ä–µ–¥–Ω—è —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${avgDuration} —Ö–≤<br>
          –ü–æ—Ç–æ—á–Ω–∞ —Å–µ—Ä—ñ—è: ${streak} ${lastResult ? "W" : "L"}<br><br>`;

        html += `<h2>üîÆ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É</h2>
          –®–∞–Ω—Å –ø–µ—Ä–µ–º–æ–≥–∏: ${prediction.score}%<br>
          –®–∞–Ω—Å –±—É—Å—Ç–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.boosterChance}%<br>
          –®–∞–Ω—Å —Ä—É—ñ–Ω–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.ruinerChance}%<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É win-streak: ${prediction.nextWinStreakChance}<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É lose-streak: ${prediction.nextLoseStreakChance}<br>
          –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å: ${prediction.recommendedRole}<br><br>`;

        // –†–æ–ª—ñ —Ç–∞–±–ª–∏—Ü—è
        html += `<h3>üé≠ –†–æ–ª—ñ</h3><table>
          <tr><th>–†–æ–ª—å</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
        for (let r = 1; r <= 5; r++) {
          const { games, wr, ak } = rolesAgg[r];
          if (!games) continue;
          html += `<tr>
            <td>${roleLabel(r)}</td>
            <td>${games}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // –¢–æ–ø –≥–µ—Ä–æ—ó —Ç–∞–±–ª–∏—Ü—è
        html += `<h3>ü¶∏‚Äç‚ôÇÔ∏è –¢–æ–ø –≥–µ—Ä–æ—ó</h3>
          <table>
            <tr><th>–ì–µ—Ä–æ–π</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
        const topHeroes = Object.entries(heroes)
          .sort((a, b) => b[1].length - a[1].length)
          .slice(0, 5);
        for (const [hid, arr] of topHeroes) {
          const wr = (arr.filter(x => x.win).length / arr.length) * 100;
          const ak = arr.reduce((s, x) => s + x.kda, 0) / arr.length;
          const hero = heroesMap[hid];
          const heroCell = hero
            ? `<img class="hero" src="${hero.img}" alt="${hero.name}"> ${hero.name}`
            : `Hero ${hid}`;
          html += `<tr>
            <td>${heroCell}</td>
            <td>${arr.length}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // –¢–µ–º–ø —ñ–≥–æ—Ä
        html += `<h3>‚è±Ô∏è –¢–µ–º–ø —ñ–≥–æ—Ä</h3><table>
          <tr><th>–ö–∞—Ç–µ–≥–æ—Ä—ñ—è</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th></tr>`;
        const tempoRows = [
          { name: "<30 —Ö–≤",  arr: durations.short, wr: tempoWr.short },
          { name: "30‚Äì40 —Ö–≤",arr: durations.mid,   wr: tempoWr.mid },
          { name: ">40 —Ö–≤",  arr: durations.long,  wr: tempoWr.long }
        ];
        for (const row of tempoRows) {
          if (!row.arr.length) continue;
          html += `<tr>
            <td>${row.name}</td>
            <td>${row.arr.length}</td>
            <td>${row.wr.toFixed(1)}%</td>
          </tr>`;
        }
        html += `</table>`;

        // --- –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö ---
        const rolePredictions = predictByRole(matches, rolesAgg);
        html += `<h3>üéØ –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö</h3>
        <table>
          <tr><th>–†–æ–ª—å</th><th>–ë–∞–∑–æ–≤–∏–π WR</th><th>WR –∑ –±—É—Å—Ç–µ—Ä–∞–º–∏</th><th>WR –∑ —Ä—É—ñ–Ω–µ—Ä–∞–º–∏</th><th>–ü—Ä–æ–≥–Ω–æ–∑</th></tr>`;
        let bestRole = null;
        for (const r in rolePredictions) {
          const rp = rolePredictions[r];
          if (!bestRole || parseFloat(rp.predicted) > parseFloat(bestRole.predicted)) bestRole = rp;
          html += `<tr>
            <td>${rp.name}</td>
            <td>${rp.baseWR}%</td>
            <td>${rp.boosterWR}%</td>
            <td>${rp.ruinerWR}%</td>
            <td><b>${rp.predicted}%</b></td>
          </tr>`;
        }
        html += `</table>`;
        if (bestRole) {
         html += `<p>‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É: <b>${bestRole.name}</b> (${bestRole.predicted}% —à–∞–Ω—Å—ñ–≤ –Ω–∞ –ø–µ—Ä–µ–º–æ–≥—É)</p>`;
        }

        // --- –§–∞–∫—Ç–æ—Ä–∏ —Ä–∏–∑–∏–∫—É —Ç–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç ---
        let contextHtml = `<h3>‚ö° –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É</h3><ul>`;

        // –§–æ—Ä–º–∞ (–æ—Å—Ç–∞–Ω–Ω—ñ 10 —ñ–≥–æ—Ä)
        const last10 = matches.slice(0,10);
        if (last10.length > 0) {
          const last10WR = (last10.filter(m => (m.player_slot<128)===m.radiant_win).length/last10.length*100).toFixed(1);
          const last10KDA = (last10.reduce((s,m)=> s + ((m.kills+m.assists)/Math.max(1,m.deaths)),0)/last10.length).toFixed(2);
          const avgKDA100 = (sumKDA/total).toFixed(2);
          if (parseFloat(last10WR) > winrate) {
            contextHtml += `<li>üî• –§–æ—Ä–º–∞: –æ—Å—Ç–∞–Ω–Ω—ñ 10 —ñ–≥–æ—Ä (${last10WR}% WR, KDA=${last10KDA}) –∫—Ä–∞—â—ñ –∑–∞ —Å–µ—Ä–µ–¥–Ω—ñ–π (${winrate}% WR, KDA=${avgKDA100})</li>`;
          } else {
            contextHtml += `<li>üßä –§–æ—Ä–º–∞: –æ—Å—Ç–∞–Ω–Ω—ñ 10 —ñ–≥–æ—Ä (${last10WR}% WR, KDA=${last10KDA}) –≥—ñ—Ä—à—ñ –∑–∞ —Å–µ—Ä–µ–¥–Ω—ñ–π (${winrate}% WR, KDA=${avgKDA100})</li>`;
          }
        }

        // –°–µ—Ä—ñ—ó
        if (streak >= 5 && lastResult) {
          contextHtml += `<li>üîÅ –°–µ—Ä—ñ—è –∑ ${streak} –ø–µ—Ä–µ–º–æ–≥ ‚Üí –º–æ–∂–ª–∏–≤–µ ¬´–±–∞–ª–∞–Ω—Å—É–≤–∞–Ω–Ω—è¬ª</li>`;
        }

        // –†–æ–ª—å–æ–≤—ñ —Ä–∏–∑–∏–∫–∏ (–¥–µ —á–∞—Å—Ç—ñ—à–µ –±—É—Å—Ç–µ—Ä–∏/—Ä—É—ñ–Ω–µ—Ä–∏ –∑–∞ —ñ—Å—Ç–æ—Ä—ñ—î—é)
        let mostBoostedRoleInfo = null, mostRuinedRoleInfo = null;
        for (let r=1; r<=5; r++){
          const arr = matches.filter(m => m.lane_role===r);
          if (!arr.length) continue;
          const boostersR = arr.filter(m => (m.kills+m.assists)/Math.max(1,m.deaths) >= 6).length;
          const ruinersR  = arr.filter(m => (m.kills+m.assists)/Math.max(1,m.deaths) <= 1).length;
          if (!mostBoostedRoleInfo || boostersR > mostBoostedRoleInfo.count) mostBoostedRoleInfo = { id:r, count:boostersR };
          if (!mostRuinedRoleInfo  || ruinersR  > mostRuinedRoleInfo.count)  mostRuinedRoleInfo  = { id:r, count:ruinersR  };
        }
        if (mostBoostedRoleInfo) contextHtml += `<li>‚úÖ –ù–∞–π—á–∞—Å—Ç—ñ—à–µ –±—É—Å—Ç–µ—Ä–∏ –Ω–∞ —Ä–æ–ª—ñ: ${roleLabel(mostBoostedRoleInfo.id)}</li>`;
        if (mostRuinedRoleInfo)  contextHtml += `<li>‚ùå –ù–∞–π—á–∞—Å—Ç—ñ—à–µ —Ä—É—ñ–Ω–µ—Ä–∏ –Ω–∞ —Ä–æ–ª—ñ: ${roleLabel(mostRuinedRoleInfo.id)}</li>`;

        // –ß–∞—Å –¥–æ–±–∏ / –¥–µ–Ω—å —Ç–∏–∂–Ω—è (–ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–∏: –ø–æ—Ç—Ä—ñ–±–µ–Ω –∞–Ω–∞–ª—ñ–∑ start_time)
        contextHtml += `<li>üïí –ß–∞—Å –¥–æ–±–∏: –¥–æ–¥–∞–π –∞–Ω–∞–ª—ñ–∑ –∑–∞ –≥–æ–¥–∏–Ω–∞–º–∏ (start_time) ‚Äî —É–Ω–æ—á—ñ —Ä–∏–∑–∏–∫ —Ä—É—ñ–Ω–µ—Ä—ñ–≤ –∑–∞–∑–≤–∏—á–∞–π –≤–∏—â–∏–π</li>`;
        contextHtml += `<li>üìÖ –î–µ–Ω—å —Ç–∏–∂–Ω—è: –¥–æ–¥–∞–π –∞–Ω–∞–ª—ñ–∑ –∑–∞ –¥–Ω—è–º–∏ ‚Äî —É –≤–∏—Ö—ñ–¥–Ω—ñ –±—ñ–ª—å—à–µ –Ω–æ–≤–∞—á–∫—ñ–≤, —É –±—É–¥–Ω—ñ —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–µ</li>`;

        // –°–∏–Ω–µ—Ä–≥—ñ—è/–∫–æ–Ω—Ç—Ä–ø–∏–∫–∏ (–ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–∏: –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–∞–Ω—ñ –ø–æ –ø—ñ–∫–∞–º —Å–æ—é–∑–Ω–∏–∫—ñ–≤/–≤–æ—Ä–æ–≥—ñ–≤)
        contextHtml += `<li>ü§ù –°–∏–Ω–µ—Ä–≥—ñ—è –≥–µ—Ä–æ—ó–≤: –ø–µ—Ä–µ–≤—ñ—Ä WR —Ç–≤–æ–≥–æ —Ç–æ–ø-–≥–µ—Ä–æ—è –∑ Mid/Carry –±—É—Å—Ç–µ—Ä–∞–º–∏</li>`;
        contextHtml += `<li>‚öîÔ∏è –ö–æ–Ω—Ç—Ä–ø–∏–∫–∏: –≤—ñ–¥—Å—Ç–µ–∂—É–π –≥–µ—Ä–æ—ó–≤ –≤–æ—Ä–æ–≥—ñ–≤, —â–æ –∫–æ–Ω—Ç—Ä—è—Ç—å —Ç–≤–æ–≥–æ –º–µ–π–Ω–∞</li>`;

        contextHtml += `</ul>`;
        html += contextHtml;

        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è DOM
        document.getElementById("summary").innerHTML = html;

        // --- –ì—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤ ---
        const ctx = document.getElementById("matchChart").getContext("2d");
        new Chart(ctx, {
          type: "bar",
          data: {
            labels,
            datasets: [{
              label: "–ú–∞—Ç—á—ñ",
              data: new Array(labels.length).fill(1),
              backgroundColor: colors
            }]
          },
          options: {
            plugins: { legend: { display: false }, tooltip: { enabled: false } },
            scales: { x: { display: false }, y: { display: false } }
          }
        });

        const allyEvents = allyBoosters + allyRuiners;
        const enemyEvents = enemyBoosters + enemyRuiners;
        const allyPercent = safePercent((allyEvents / total) * 100);
        const enemyPercent = safePercent((enemyEvents / total) * 100);
        document.getElementById("boosterRuinerStats").innerHTML =
          `–£ —Ç–≤–æ—ó–π –∫–æ–º–∞–Ω–¥—ñ: ${allyPercent}% –º–∞—Ç—á—ñ–≤ —ñ–∑ –±—É—Å—Ç–µ—Ä–æ–º/—Ä—É—ñ–Ω–µ—Ä–æ–º (–∑–µ–ª–µ–Ω–∏–π/—á–µ—Ä–≤–æ–Ω–∏–π).<br>` +
          `–£ —Å—É–ø–µ—Ä–Ω–∏–∫—ñ–≤: ${enemyPercent}% –º–∞—Ç—á—ñ–≤ —ñ–∑ –±—É—Å—Ç–µ—Ä–æ–º/—Ä—É—ñ–Ω–µ—Ä–æ–º (–∑–µ–ª–µ–Ω–∏–π/—á–µ—Ä–≤–æ–Ω–∏–π).`;

        // --- –ì—Ä–∞—Ñ—ñ–∫ –ø—Ä–æ–≥–Ω–æ–∑—É –ø–æ —Ä–æ–ª—è—Ö ---
        const roleLabels = Object.values(rolePredictions).map(r => r.name);
        const roleData   = Object.values(rolePredictions).map(r => parseFloat(r.predicted));
        const bestVal    = roleData.length ? Math.max(...roleData) : 0;

        const ctxRole = document.getElementById("roleChart").getContext("2d");
        new Chart(ctxRole, {
          type: "bar",
          data: {
            labels: roleLabels,
            datasets: [{
              label: "–®–∞–Ω—Å –ø–µ—Ä–µ–º–æ–≥–∏ (%)",
              data: roleData,
              backgroundColor: roleData.map(val => val === bestVal ? "limegreen" : "#6cf")
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: true, max: 100, ticks: { color: "#eee" } },
              x: { ticks: { color: "#eee" } }
            },
            plugins: {
              legend: { display: false },
              tooltip: { callbacks: { label: ctx => ctx.raw.toFixed(1) + "%" } }
            }
          }
        });

      } catch (err) {
        document.getElementById("summary").innerHTML = "‚ö†Ô∏è –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –∞–±–æ –ø–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É.";
        console.error(err);
      }
    }

    analyzeMatches();
  </script>
</body>
</html>
 
