<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Dota 2 Match Predictor (OpenDota)</title>
  <style>
    body { background:#111; color:#eee; font-family:monospace; padding:20px; }
    h1 { color:#6cf; }
    h2 { color:#9cf; }
    h3 { color:#acf; }
    .match { margin:5px 0; padding:5px; border-bottom:1px solid #333; }
    .good { color:#6f6; }
    .bad { color:#f66; }
    table { border-collapse: collapse; margin:10px 0; width:auto; }
    th, td { border:1px solid #333; padding:6px 8px; text-align:left; }
    img.hero { width:40px; height:40px; vertical-align:middle; margin-right:6px; }
  </style>
</head>
<body>
  <h1>Dota 2 Match Predictor</h1>
  <div id="summary"></div>
  <div id="matches"></div>

  <script>
    const accountId32 = 863386335; // —Ç–≤—ñ–π Steam32 ID
    const MATCH_COUNT = 100;

    async function fetchMatchHistory() {
      const url = `http://localhost:3000/api/matches?account_id=${accountId32}&count=${MATCH_COUNT}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Server unavailable");
      return await res.json(); // OpenDota –≤—ñ–¥–¥–∞—î –º–∞—Å–∏–≤ –º–∞—Ç—á—ñ–≤
    }

    async function getHeroesMap() {
      const res = await fetch("https://api.opendota.com/api/heroes");
      const heroes = await res.json();
      const map = {};
      for (const h of heroes) {
        const short = h.name.replace("npc_dota_hero_", "");
        map[h.id] = {
          name: h.localized_name,
          short,
          img: `https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/${short}.png`
        };
      }
      return map;
    }

    function roleLabel(id) {
      const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
      return roleNames[id] || "Unknown";
    }

    function safePercent(n) {
      if (!isFinite(n)) return "0.0";
      return n.toFixed(1);
    }

    function buildPrediction({
      winrate,
      streak,
      lastResultBool,
      rolesAgg,
      boosters,
      ruiners,
      total,
      tempoWr
    }) {
      // –±–∞–∑–æ–≤–∏–π —Å–∫–æ—Ä –∑ winrate
      let score = winrate;

      // —ñ–º–ø—É–ª—å—Å —Å–µ—Ä—ñ—ó
      if (streak > 2 && lastResultBool) score += 5;
      if (streak > 2 && !lastResultBool) score -= 5;

      // –±–æ–Ω—É—Å/—à—Ç—Ä–∞—Ñ –∑–∞ —Ç–µ–º–ø (—è–∫—â–æ –∫–æ—Ä–æ—Ç–∫—ñ/–¥–æ–≤–≥—ñ –º–∞—Ç—á—ñ –¥–∞—é—Ç—å –∫—Ä–∞—â–∏–π WR –∑–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π)
      if (tempoWr.short > winrate) score += 3;
      if (tempoWr.long > winrate) score += 3;

      // —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å –∑–∞ –Ω–∞–π–≤–∏—â–∏–º WR
      let bestRole = null;
      let worstRole = null;
      for (const [rid, arr] of Object.entries(rolesAgg)) {
        if (arr.games === 0) continue;
        if (!bestRole || arr.wr > bestRole.wr) bestRole = { id: Number(rid), wr: arr.wr };
        if (!worstRole || arr.wr < worstRole.wr) worstRole = { id: Number(rid), wr: arr.wr };
      }
      if (bestRole && bestRole.wr > winrate) score += 4;
      if (worstRole && worstRole.wr < winrate) score -= 4;

      // –æ–±–º–µ–∂–µ–Ω–Ω—è
      score = Math.max(5, Math.min(95, score));
      const boosterChance = safePercent((boosters / total) * 100);
      const ruinerChance = safePercent((ruiners / total) * 100);
      const nextWinStreakChance = !lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";
      const nextLoseStreakChance = lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";

      return {
        score: score.toFixed(1),
        boosterChance,
        ruinerChance,
        nextWinStreakChance,
        nextLoseStreakChance,
        recommendedRole: bestRole ? `${roleLabel(bestRole.id)} (${bestRole.wr.toFixed(1)}% WR)` : "–Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö"
      };
    }

    async function analyzeMatches() {
      try {
        const matches = await fetchMatchHistory();
        const heroesMap = await getHeroesMap();

        if (!matches || matches.length === 0) {
          document.getElementById("summary").innerHTML =
            "‚ùå –ú–∞—Ç—á—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä Steam32 ID –∞–±–æ –æ–Ω–æ–≤–∏ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞ OpenDota.";
          return;
        }

        const container = document.getElementById("matches");
        let total = 0, wins = 0, sumKDA = 0;
        let streak = 0, lastResult = null, avgDuration = 0;
        let boosters = 0, ruiners = 0;

        const roles = {1:[],2:[],3:[],4:[],5:[]}; // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –º–∞—Å–∏–≤–∏ –∑–∞–ø–∏—Å—ñ–≤ {win,kda}
        const heroes = {}; // hero_id: [ {win,kda} ]
        const durations = {short:[], mid:[], long:[]}; // –º–∞—Å–∏–≤–∏ win(true)/loss(false)

        for (const m of matches) {
          const k = m.kills || 0, d = m.deaths || 0, a = m.assists || 0;
          const kda = ((k + a) / Math.max(1, d));
          const win = (m.player_slot < 128) === m.radiant_win;
          const duration = m.duration || 0;

          total++;
          if (win) wins++;
          sumKDA += kda;
          avgDuration += duration;

          // streak
          if (lastResult === null || lastResult === win) streak++;
          else streak = 1;
          lastResult = win;

          // –±—É—Å—Ç–µ—Ä/—Ä—É—ñ–Ω–µ—Ä —Å–∏–≥–Ω–∞–ª–∏
          if (kda >= 6 && win) boosters++;
          if (kda <= 1 && !win) ruiners++;

          // —Ä–æ–ª—ñ (–º–æ–∂–µ –±—É—Ç–∏ null/undefined, —Ç–æ–º—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ)
          if (m.lane_role && roles[m.lane_role]) roles[m.lane_role].push({ win, kda });

          // –≥–µ—Ä–æ—ó
          if (!heroes[m.hero_id]) heroes[m.hero_id] = [];
          heroes[m.hero_id].push({ win, kda });

          // —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
          if (duration < 1800) durations.short.push(win);
          else if (duration < 2400) durations.mid.push(win);
          else durations.long.push(win);

          // —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á—ñ–≤ (–≤–∏–≤—ñ–¥)
          const heroInfo = heroesMap[m.hero_id];
          const heroCell = heroInfo
            ? `<img class="hero" src="${heroInfo.img}" alt="${heroInfo.name}"> ${heroInfo.name}`
            : `Hero ${m.hero_id}`;
          const div = document.createElement("div");
          div.className = "match";
          div.innerHTML = `Match ${m.match_id}: 
            <span class="${win ? 'good' : 'bad'}">${win ? 'WIN' : 'LOSS'}</span> 
            | ${heroCell} | K=${k}, D=${d}, A=${a}, KDA=${kda.toFixed(2)} | ${Math.round(duration/60)} —Ö–≤`;
          container.appendChild(div);
        }

        const winrate = parseFloat(((wins / total) * 100).toFixed(1));
        const avgKDA = (sumKDA / total).toFixed(2);
        avgDuration = Math.round((avgDuration / total) / 60);

        // –∞–≥—Ä–µ–≥–∞—Ç–∏ –¥–ª—è —Ä–æ–ª–µ–π (WR/KDA)
        const rolesAgg = {};
        for (let r = 1; r <= 5; r++) {
          const arr = roles[r] || [];
          const games = arr.length;
          const wr = games ? (arr.filter(x => x.win).length / games) * 100 : 0;
          const ak = games ? (arr.reduce((s, x) => s + x.kda, 0) / games) : 0;
          rolesAgg[r] = { games, wr, ak };
        }

        // —Ç–µ–º–ø WR
        const tempoWr = {
          short: durations.short.length ? (durations.short.filter(x => x).length / durations.short.length) * 100 : 0,
          mid: durations.mid.length ? (durations.mid.filter(x => x).length / durations.mid.length) * 100 : 0,
          long: durations.long.length ? (durations.long.filter(x => x).length / durations.long.length) * 100 : 0
        };

        // –ø—Ä–æ–≥–Ω–æ–∑
        const prediction = buildPrediction({
          winrate,
          streak,
          lastResultBool: !!lastResult,
          rolesAgg,
          boosters,
          ruiners,
          total,
          tempoWr
        });

        // summary
        let html = `<h2>üìä Summary (${total} –º–∞—Ç—á—ñ–≤)</h2>
          Winrate: ${winrate}%<br>
          –°–µ—Ä–µ–¥–Ω—ñ–π KDA: ${avgKDA}<br>
          –°–µ—Ä–µ–¥–Ω—è —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${avgDuration} —Ö–≤<br>
          –ü–æ—Ç–æ—á–Ω–∞ —Å–µ—Ä—ñ—è: ${streak} ${lastResult ? "W" : "L"}<br><br>`;

        // –ø—Ä–æ–≥–Ω–æ–∑
        html += `<h2>üîÆ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É</h2>
          –®–∞–Ω—Å –ø–µ—Ä–µ–º–æ–≥–∏: ${prediction.score}%<br>
          –®–∞–Ω—Å –±—É—Å—Ç–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.boosterChance}%<br>
          –®–∞–Ω—Å —Ä—É—ñ–Ω–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.ruinerChance}%<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É win-streak: ${prediction.nextWinStreakChance}<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É lose-streak: ${prediction.nextLoseStreakChance}<br>
          –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å: ${prediction.recommendedRole}<br><br>`;

        // —Ä–æ–ª—ñ —Ç–∞–±–ª–∏—Ü—è
        html += `<h3>üé≠ –†–æ–ª—ñ</h3><table><tr><th>–†–æ–ª—å</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
        for (let r = 1; r <= 5; r++) {
          const { games, wr, ak } = rolesAgg[r];
          if (!games) continue;
          html += `<tr>
            <td>${roleLabel(r)}</td>
            <td>${games}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // —Ç–æ–ø –≥–µ—Ä–æ—ó —Ç–∞–±–ª–∏—Ü—è
        html += `<h3>ü¶∏‚Äç‚ôÇÔ∏è –¢–æ–ø –≥–µ—Ä–æ—ó</h3>
          <table>
          <tr><th>–ì–µ—Ä–æ–π</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;

        const topHeroes = Object.entries(heroes)
          .sort((a, b) => b[1].length - a[1].length)
          .slice(0, 5);

        for (const [hid, arr] of topHeroes) {
          const wr = (arr.filter(x => x.win).length / arr.length) * 100;
          const ak = arr.reduce((s, x) => s + x.kda, 0) / arr.length;
          const hero = heroesMap[hid];
          const heroCell = hero
            ? `<img class="hero" src="${hero.img}" alt="${hero.name}"> ${hero.name}`
            : `Hero ${hid}`;
          html += `<tr>
            <td>${heroCell}</td>
            <td>${arr.length}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // —Ç–µ–º–ø —ñ–≥–æ—Ä
        html += `<h3>‚è±Ô∏è –¢–µ–º–ø —ñ–≥–æ—Ä</h3><table>
          <tr><th>–ö–∞—Ç–µ–≥–æ—Ä—ñ—è</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th></tr>`;
        const tempoRows = [
          { name: "<30 —Ö–≤", arr: durations.short, wr: tempoWr.short },
          { name: "30‚Äì40 —Ö–≤", arr: durations.mid, wr: tempoWr.mid },
          { name: ">40 —Ö–≤", arr: durations.long, wr: tempoWr.long }
        ];
        for (const row of tempoRows) {
          if (!row.arr.length) continue;
          html += `<tr>
            <td>${row.name}</td>
            <td>${row.arr.length}</td>
            <td>${row.wr.toFixed(1)}%</td>
          </tr>`;
        }
        html += `</table>`;

        document.getElementById("summary").innerHTML = html;
      } catch (err) {
        document.getElementById("summary").innerHTML = "‚ö†Ô∏è –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –∞–±–æ –ø–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É.";
        console.error(err);
      }
    }

    analyzeMatches();
  </script>
</body>
</html>
