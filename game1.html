<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Dota 2 Role Prediction – OpenDota</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1320;
      --panel: #171b2e;
      --text: #e8ebff;
      --muted: #9aa3c1;
      --accent: #6aa9ff;
      --win: #35c46e;
      --loss: #ff6b6b;
      --warn: #ffc857;
      --grid: rgba(255,255,255,0.08);
    }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 16px 20px;
      background: var(--panel);
      border-bottom: 1px solid var(--grid);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    h1 { font-size: 20px; margin: 0 0 6px; }
    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(180px, 1fr));
      gap: 10px;
      align-items: end;
    }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input, select, button {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--grid);
      background: #0c1020;
      color: var(--text);
      outline: none;
    }
    button {
      background: var(--accent);
      color: #0a1020;
      font-weight: 600;
      border: none;
      cursor: pointer;
    }
    button[disabled] { opacity: 0.6; cursor: default; }
    main { padding: 16px 20px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 12px;
      padding: 14px;
    }
    .panel h2 {
      margin: 0 0 10px;
      font-size: 16px;
      color: var(--muted);
      font-weight: 600;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid var(--grid);
      margin-right: 8px;
      margin-bottom: 6px;
    }
    .pill.win { background: rgba(53,196,110,0.15); color: var(--win); border-color: rgba(53,196,110,0.35); }
    .pill.loss { background: rgba(255,107,107,0.15); color: var(--loss); border-color: rgba(255,107,107,0.35); }
    .pill.warn { background: rgba(255,200,87,0.15); color: var(--warn); border-color: rgba(255,200,87,0.35); }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      text-align: left;
      padding: 8px 10px;
      border-bottom: 1px solid var(--grid);
      vertical-align: top;
    }
    th { color: var(--muted); font-weight: 600; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .small { font-size: 12px; color: var(--muted); }
    .flex { display: flex; gap: 12px; flex-wrap: wrap; }
    .row { display: flex; gap: 10px; align-items: center; }
    .bar {
      height: 8px;
      background: #0c1020;
      border-radius: 999px;
      border: 1px solid var(--grid);
      overflow: hidden;
      margin-top: 6px;
    }
    .bar > span {
      display: block;
      height: 100%;
      background: var(--accent);
    }
    .danger { color: var(--loss); }
    .success { color: var(--win); }
    footer { padding: 12px 20px; color: var(--muted); }
    @media (max-width: 1024px) {
      .grid { grid-template-columns: 1fr; }
      .controls { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Role-based prediction for next match</h1>
    <div class="controls">
      <div>
        <label for="accountId">Steam32 account ID</label>
        <input id="accountId" type="text" placeholder="Напр.: 123456789" />
      </div>
      <div>
        <label for="matchLimit">Аналіз останніх матчів</label>
        <select id="matchLimit">
          <option value="50">50</option>
          <option value="100" selected>100</option>
          <option value="200">200</option>
        </select>
      </div>
      <div>
        <label for="roleNorm">Нормалізація ролей</label>
        <select id="roleNorm">
          <option value="recent" selected>Останні ігри (динамічно)</option>
          <option value="overall">Загальна історія</option>
        </select>
      </div>
      <div>
        <button id="runBtn">Запустити аналіз</button>
      </div>
    </div>
    <div class="hint">Підказка: якщо профіль приватний, OpenDota може повернути неповні дані. Для стабільності краще 100–200 матчів.</div>
  </header>

  <main>
    <div class="grid">
      <section class="panel">
        <h2>Прогноз по ролях</h2>
        <div id="roleForecast" class="flex"></div>
        <div class="hint">Алгоритм враховує: вінрейти по ролях, стабільність ролі, серії, час доби, лейн-результати, геро-пул і останні KPI.</div>
      </section>

      <section class="panel">
        <h2>Серії і форма</h2>
        <div id="streaks"></div>
      </section>
    </div>

    <div class="grid">
      <section class="panel">
        <h2>Метрики по ролях</h2>
        <table id="rolesTable">
          <thead>
            <tr>
              <th>Роль</th>
              <th>Вінрейт</th>
              <th>Матчі</th>
              <th>Стабільність</th>
              <th>Середні KPI</th>
              <th>Геро-пул</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <section class="panel">
        <h2>Час доби, патч, режим</h2>
        <table id="contextTable">
          <thead>
            <tr>
              <th>Фактор</th>
              <th>Метрика</th>
              <th>Примітка</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <div class="grid">
      <section class="panel">
        <h2>Останні матчі (огляд)</h2>
        <table id="recentTable">
          <thead>
            <tr>
              <th>Матч</th>
              <th>Дата/час</th>
              <th>Роль</th>
              <th>Герой</th>
              <th>Результат</th>
              <th>KDA</th>
              <th>GPM/XPM</th>
              <th>Лейн</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <section class="panel">
        <h2>Лейн-результати</h2>
        <table id="laneTable">
          <thead>
            <tr>
              <th>Лейн</th>
              <th>Вінрейт</th>
              <th>Матчі</th>
              <th>Середній нетворк на 10</th>
              <th>Примітка</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>
  </main>

  <footer class="small">
    Побудовано на даних OpenDota. Для стабільної роботи не перевищуй ліміти запитів. Цей інструмент не гарантує результат, він підсвічує ймовірності та ризики.
  </footer>

  <script>
    // ========== CONFIG ==========
    const API = {
      base: 'https://api.opendota.com/api',
      // Якщо маєш ключ, можна додати в headers:
      headers: {}
      // headers: { 'Authorization': 'Bearer YOUR_KEY' }
    };

    // Рольні мапи (спрощено). Можеш доповнити під себе.
    const ROLE_MAP = {
      1: 'Саппорт 1', // pos5
      2: 'Саппорт 2', // pos4
      3: 'Офлейн',    // pos3
      4: 'Мід',       // pos2
      5: 'Керрі'      // pos1
    };

    // Лейни від OpenDota player.lane_role (optional heuristic)
    const LANE_MAP = {
      1: 'Сейф-лейн',
      2: 'Мід',
      3: 'Офлейн',
      4: 'Джангл/Роум'
    };

    // Кеш для сесії
    const cache = new Map();

    // ========== UTIL ==========
    const fmtPct = v => (isNaN(v) ? '-' : (v * 100).toFixed(1) + '%');
    const fmtNum = v => (v == null ? '-' : v.toLocaleString('uk-UA'));
    const fmtDate = ts => {
      try {
        return new Date(ts * 1000).toLocaleString('uk-UA', { hour12: false });
      } catch { return '-'; }
    };
    const kda = (k, d, a) => {
      const denom = Math.max(1, d || 0);
      return ((k || 0) + (a || 0)) / denom;
    };
    const by = key => (a, b) => (a[key] < b[key] ? 1 : -1);

    // Агрегатор середніх
    function aggAvg(list, key) {
      const vals = list.map(x => x[key]).filter(x => typeof x === 'number');
      if (vals.length === 0) return null;
      return vals.reduce((s, v) => s + v, 0) / vals.length;
    }

    // Обмежений вінрейт з довірою (стійкість)
    function stableWinrate(wins, total) {
      if (total === 0) return { wr: 0, stability: 0 };
      const wr = wins / total;
      // Wilson score lower bound (approx)
      const z = 1.96;
      const denom = 1 + z*z/total;
      const center = wr + z*z/(2*total);
      const adj = z * Math.sqrt((wr*(1-wr) + z*z/(4*total)) / total);
      const lower = (center - adj) / denom;
      const stability = Math.max(0, Math.min(1, 1 - (wr - lower))); // чим ближче lower до wr, тим стабільніше
      return { wr, stability };
    }

    // ========== API CALLS ==========
    async function getJSON(url) {
      if (cache.has(url)) return cache.get(url);
      const res = await fetch(url, { headers: API.headers });
      if (!res.ok) throw new Error('HTTP ' + res.status + ' ' + url);
      const data = await res.json();
      cache.set(url, data);
      return data;
    }

    async function fetchPlayer(accountId) {
      return getJSON(`${API.base}/players/${accountId}`);
    }

    async function fetchRecentMatches(accountId, limit = 100) {
      // /players/{account_id}/matches?limit=...
      return getJSON(`${API.base}/players/${accountId}/matches?limit=${limit}`);
    }

    async function fetchPeers(accountId) {
      return getJSON(`${API.base}/players/${accountId}/peers?limit=100`);
    }

    async function fetchHeroConstants() {
      // герої для імен
      return getJSON(`${API.base}/heroes`);
    }

    // ========== ROLE INFERENCE ==========
    // Багато матчів не мають явної позиції. Евристика:
    // - lane_role (якщо доступний)
    // - gold_per_min/xp_per_min + ранні показники
    // - mid lane частота -> pos2; highest GPM/XPM на сейф-лейні -> pos1; часті варди/асисти -> supports
    function inferRole(match) {
      // match: OpenDota recent match item
      // fields: player_slot, radiant_win, hero_id, kills, deaths, assists, lane, lane_role, gold_per_min, xp_per_min, version, start_time, etc.
      const laneRole = match.lane_role;
      const laneName = LANE_MAP[laneRole] || null;
      const gpm = match.gold_per_min || 0;
      const xpm = match.xp_per_min || 0;
      const k = match.kills || 0;
      const a = match.assists || 0;
      const d = match.deaths || 0;

      // simple signals
      const isMid = laneRole === 2;
      const isOfflane = laneRole === 3;
      const isSafelane = laneRole === 1;

      // support-like: high assists, low gpm/xpm relative
      const supportScore = a - k - (gpm + xpm) / 200;
      // core-like: high gpm/xpm and kills
      const coreScore = (gpm + xpm) / 200 + k - d;

      let role;
      if (isMid) role = 4; // pos2
      else if (isOfflane) role = 3;
      else if (isSafelane && coreScore > 0.5) role = 5; // carry pos1
      else if (supportScore > 0.5) role = (k < 6 ? 1 : 2); // pos5 або pos4
      else {
        // fallback by gpm/xpm
        if (gpm > 520 || xpm > 600) role = 5;
        else if (gpm > 430 || xpm > 500) role = 3;
        else role = 2; // roam/pos4 fallback
      }
      return { role, laneName };
    }

    // ========== ANALYTICS ==========
    function computeRoleMetrics(matches, heroesById) {
      const perRole = new Map(); // role -> {wins, total, kdas:[], gpm:[], xpm:[], deaths:[], heroes:Set, lanes:Map}
      const roleSeq = [];

      for (const m of matches) {
        const { role, laneName } = inferRole(m);
        const win = (m.radiant_win && m.player_slot < 128) || (!m.radiant_win && m.player_slot >= 128);
        const heroname = (heroesById.get(m.hero_id) || {}).localized_name || `Hero ${m.hero_id}`;
        const entry = perRole.get(role) || { wins:0, total:0, kdas:[], gpm:[], xpm:[], deaths:[], heroes:new Set(), lanes:new Map() };
        entry.total += 1;
        if (win) entry.wins += 1;
        entry.kdas.push(kda(m.kills, m.deaths, m.assists));
        if (m.gold_per_min) entry.gpm.push(m.gold_per_min);
        if (m.xp_per_min) entry.xpm.push(m.xp_per_min);
        entry.deaths.push(m.deaths || 0);
        entry.heroes.add(heroname);
        if (laneName) {
          const l = entry.lanes.get(laneName) || { wins:0, total:0 };
          l.total += 1;
          if (win) l.wins += 1;
          entry.lanes.set(laneName, l);
        }
        perRole.set(role, entry);
        roleSeq.push(role);
      }

      // стабільність ролі (перемикання)
      let switches = 0;
      for (let i=1; i<roleSeq.length; i++) if (roleSeq[i] !== roleSeq[i-1]) switches++;
      const roleStability = roleSeq.length ? 1 - (switches / roleSeq.length) : 0;

      // агрегати і скоринг
      const result = [];
      for (const [role, data] of perRole.entries()) {
        const { wr, stability } = stableWinrate(data.wins, data.total);
        const avgKDA = aggAvg(data.kdas, null);
        const avgGPM = aggAvg(data.gpm, null);
        const avgXPM = aggAvg(data.xpm, null);
        const avgDeaths = aggAvg(data.deaths, null);

        // лейн найкращий
        let bestLane = null, bestLaneWr = null, bestLaneTotal = 0;
        for (const [lname, ldata] of data.lanes.entries()) {
          const w = ldata.wins / ldata.total;
          if (bestLaneWr == null || w > bestLaneWr) {
            bestLaneWr = w; bestLane = lname; bestLaneTotal = ldata.total;
          }
        }

        // базовий role score: вінрейт зі стабільністю + KPI
        const roleScore =
          (wr * 0.5) +
          (stability * 0.15) +
          ((avgKDA || 1) / 5 * 0.15) +
          (((avgGPM || 400) - 350) / 250 * 0.1) +
          (((avgXPM || 450) - 400) / 250 * 0.1) -
          ((avgDeaths || 6) - 6) * 0.02;

        result.push({
          role, roleName: ROLE_MAP[role] || `Роль ${role}`,
          wr, total: data.total, stability,
          avgKDA, avgGPM, avgXPM, avgDeaths,
          heroPool: Array.from(data.heroes).sort().slice(0, 12),
          bestLane, bestLaneWr, bestLaneTotal,
          score: roleScore
        });
      }

      return { perRole: result.sort(by('score')), roleStability };
    }

    function computeStreaks(matches) {
      const seq = matches.map(m => ((m.radiant_win && m.player_slot < 128) || (!m.radiant_win && m.player_slot >= 128)) ? 1 : 0);
      let cur = 0, bestWin = 0, bestLose = 0;
      for (const w of seq) {
        if (w === 1) {
          cur = cur >= 0 ? cur + 1 : 1;
          bestWin = Math.max(bestWin, cur);
        } else {
          cur = cur <= 0 ? cur - 1 : -1;
          bestLose = Math.max(bestLose, -cur);
        }
      }
      const recent = seq.slice(-10).reduce((s,x)=>s+(x?1:0),0);
      return { current: cur, bestWin, bestLose, recentWins10: recent };
    }

    function computeContext(matches) {
      // Час доби, патч, режим гри
      const byHour = new Map(); // hour -> {wins,total}
      const modes = new Map();  // game_mode -> {wins,total}
      const patches = new Map(); // patch? (OpenDota may not include) fallback by version

      for (const m of matches) {
        const hour = new Date(m.start_time * 1000).getHours();
        const win = (m.radiant_win && m.player_slot < 128) || (!m.radiant_win && m.player_slot >= 128);
        const h = byHour.get(hour) || {wins:0,total:0};
        h.total++; if (win) h.wins++;
        byHour.set(hour, h);

        const gm = m.game_mode ?? -1;
        const g = modes.get(gm) || {wins:0,total:0};
        g.total++; if (win) g.wins++;
        modes.set(gm, g);

        const ver = m.version ?? 'unknown';
        const p = patches.get(ver) || {wins:0,total:0};
        p.total++; if (win) p.wins++;
        patches.set(ver, p);
      }

      // найкращі години
      const hoursArr = Array.from(byHour.entries())
        .map(([h, v]) => ({ hour: h, wr: v.wins / v.total, total: v.total }))
        .sort((a,b) => b.wr - a.wr);
      const bestHour = hoursArr[0] || null;

      const gmArr = Array.from(modes.entries())
        .map(([gm, v]) => ({ gm, wr: v.wins / v.total, total: v.total }))
        .sort((a,b) => b.wr - a.wr);
      const bestMode = gmArr[0] || null;

      const verArr = Array.from(patches.entries())
        .map(([ver, v]) => ({ ver, wr: v.wins / v.total, total: v.total }))
        .sort((a,b) => b.wr - a.wr);
      const bestPatch = verArr[0] || null;

      return { bestHour, hoursArr, bestMode, gmArr, bestPatch, verArr };
    }

    function computeLaneStats(matches) {
      const lanes = new Map(); // lane_role -> {wins,total,gpm10:[], note}
      for (const m of matches) {
        const lr = m.lane_role;
        if (!lr) continue;
        const win = (m.radiant_win && m.player_slot < 128) || (!m.radiant_win && m.player_slot >= 128);
        const e = lanes.get(lr) || { wins:0, total:0, gpm10:[] };
        e.total++; if (win) e.wins++;
        // proxy: не маємо нетворку на 10 хв, використаємо GPM як сурогат
        if (m.gold_per_min) e.gpm10.push(m.gold_per_min / 6); // ~ наближено
        lanes.set(lr, e);
      }
      const rows = [];
      for (const [lr, e] of lanes.entries()) {
        rows.push({
          lane: LANE_MAP[lr] || `Lane ${lr}`,
          wr: e.wins / e.total,
          total: e.total,
          net10: aggAvg(e.gpm10, null),
          note: e.total < 8 ? 'Мало даних' : ''
        });
      }
      return rows.sort((a,b)=>b.wr - a.wr);
    }

    // ========== FORECAST ==========
    function buildRoleForecast(roleMetrics, streaks, context) {
      // Ваги ризику/переваг: базовий score + коригування за серією і часом
      return roleMetrics.perRole.map(r => {
        let score = r.score;
        // серія: якщо довга серія поразок і роль має низьку стабільність — невелике зниження
        if (streaks.current < -3 && r.stability < 0.4) score -= 0.05;
        // фаворитні години: якщо bestHour існує, підсилити роль з кращим вінрейтом
        if (context.bestHour && context.bestHour.wr > 0.55) score += 0.03;
        // лейн співпадіння: якщо є bestLane з wr>0.55 — невеликий бонус
        if (r.bestLaneWr != null && r.bestLaneWr > 0.55) score += 0.02;

        const winProb = Math.max(0.05, Math.min(0.95, score)); // нормалізація до 0..1
        const risk = 1 - (r.stability * 0.7 + (r.wr * 0.3)); // умовний ризик
        return {
          roleName: r.roleName,
          winrate: r.wr,
          total: r.total,
          stability: r.stability,
          winProb,
          risk,
          bestLane: r.bestLane,
          heroPool: r.heroPool
        };
      }).sort((a,b)=>b.winProb - a.winProb);
    }

    // ========== RENDER ==========
    function renderRoleForecast(list) {
      const root = document.getElementById('roleForecast');
      root.innerHTML = '';
      for (const item of list) {
        const div = document.createElement('div');
        div.className = 'panel';
        div.style.minWidth = '260px';
        div.innerHTML = `
          <div class="row">
            <div style="font-weight:700">${item.roleName}</div>
            <div class="pill ${item.winrate>=0.5?'win':'loss'}">WR ${fmtPct(item.winrate)}</div>
            <div class="pill warn">Матчі ${fmtNum(item.total)}</div>
          </div>
          <div class="bar"><span style="width:${(item.winProb*100).toFixed(0)}%"></span></div>
          <div class="small" style="margin-top:6px">Ймовірність виграшу: <span class="${item.winProb>=0.5?'success':'danger'}">${fmtPct(item.winProb)}</span></div>
          <div class="small">Стабільність ролі: ${fmtPct(item.stability)}</div>
          <div class="small">Найкращий лейн: ${item.bestLane || '-'}</div>
          <div class="small">Геро-пул: ${item.heroPool.join(', ') || '-'}</div>
        `;
        root.appendChild(div);
      }
    }

    function renderRolesTable(roleMetrics) {
      const tbody = document.querySelector('#rolesTable tbody');
      tbody.innerHTML = '';
      for (const r of roleMetrics.perRole) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.roleName}</td>
          <td class="mono">${fmtPct(r.wr)}</td>
          <td class="mono">${fmtNum(r.total)}</td>
          <td class="mono">${fmtPct(r.stability)}</td>
          <td>
            <div>Середній KDA: <span class="mono">${(r.avgKDA||0).toFixed(2)}</span></div>
            <div>GPM/XPM: <span class="mono">${fmtNum(Math.round(r.avgGPM||0))}</span>/<span class="mono">${fmtNum(Math.round(r.avgXPM||0))}</span></div>
            <div>Deaths: <span class="mono">${(r.avgDeaths||0).toFixed(1)}</span></div>
          </td>
          <td>${r.heroPool.join(', ') || '-'}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderStreaks(streaks) {
      const root = document.getElementById('streaks');
      const label =
        streaks.current > 0 ? `Поточна серія перемог: ${streaks.current}` :
        streaks.current < 0 ? `Поточна серія поразок: ${-streaks.current}` :
        'Немає поточної серії';
      root.innerHTML = `
        <div class="row">
          <div class="pill ${streaks.current>0?'win':(streaks.current<0?'loss':'warn')}">${label}</div>
          <div class="pill win">Найкраща серія перемог: ${streaks.bestWin}</div>
          <div class="pill loss">Найдовша серія поразок: ${streaks.bestLose}</div>
          <div class="pill warn">Перемоги за останні 10: ${streaks.recentWins10}/10</div>
        </div>
      `;
    }

    function renderContext(context) {
      const tbody = document.querySelector('#contextTable tbody');
      tbody.innerHTML = '';
      const rows = [];

      if (context.bestHour) {
        rows.push({
          factor: 'Час доби (кращий)',
          metric: `${String(context.bestHour.hour).padStart(2,'0')}:00`,
          note: `WR ${fmtPct(context.bestHour.wr)} на ${fmtNum(context.bestHour.total)} матчах`
        });
      }
      if (context.bestMode) {
        rows.push({
          factor: 'Режим гри (кращий)',
          metric: `${context.bestMode.gm}`,
          note: `WR ${fmtPct(context.bestMode.wr)} на ${fmtNum(context.bestMode.total)} матчах`
        });
      }
      if (context.bestPatch) {
        rows.push({
          factor: 'Версія/патч (найкраща)',
          metric: `${context.bestPatch.ver}`,
          note: `WR ${fmtPct(context.bestPatch.wr)} на ${fmtNum(context.bestPatch.total)} матчах`
        });
      }
      if (rows.length === 0) {
        rows.push({ factor: 'Контекст', metric: '-', note: 'Немає достатньо даних' });
      }
      for (const r of rows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${r.factor}</td><td>${r.metric}</td><td>${r.note}</td>`;
        tbody.appendChild(tr);
      }
    }

    function renderRecent(matches, heroesById) {
      const tbody = document.querySelector('#recentTable tbody');
      tbody.innerHTML = '';
      for (const m of matches.slice(0, 30)) {
        const { role, laneName } = inferRole(m);
        const hero = heroesById.get(m.hero_id) || {};
        const win = (m.radiant_win && m.player_slot < 128) || (!m.radiant_win && m.player_slot >= 128);
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="mono">${m.match_id}</td>
          <td>${fmtDate(m.start_time)}</td>
          <td>${ROLE_MAP[role] || '-'}</td>
          <td>${hero.localized_name || ('Hero '+m.hero_id)}</td>
          <td><span class="pill ${win?'win':'loss'}">${win?'Win':'Loss'}</span></td>
          <td class="mono">${(kda(m.kills, m.deaths, m.assists)).toFixed(2)}</td>
          <td class="mono">${fmtNum(m.gold_per_min||0)}/${fmtNum(m.xp_per_min||0)}</td>
          <td>${laneName || '-'}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderLaneStats(rows) {
      const tbody = document.querySelector('#laneTable tbody');
      tbody.innerHTML = '';
      for (const r of rows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.lane}</td>
          <td class="mono">${fmtPct(r.wr)}</td>
          <td class="mono">${fmtNum(r.total)}</td>
          <td class="mono">${fmtNum(Math.round(r.net10||0))}</td>
          <td>${r.note}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    // ========== MAIN ==========
    async function run() {
      const btn = document.getElementById('runBtn');
      const accountId = document.getElementById('accountId').value.trim();
      const limit = parseInt(document.getElementById('matchLimit').value, 10);

      if (!accountId) {
        alert('Введи Steam32 account_id.');
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Завантаження...';

      try {
        const [player, matches, heroes] = await Promise.all([
          fetchPlayer(accountId),
          fetchRecentMatches(accountId, limit),
          fetchHeroConstants()
        ]);

        // heroesById map
        const heroesById = new Map();
        for (const h of heroes) heroesById.set(h.id, h);

        // Фільтруємо валідні матчі (з героями і метриками)
        const valid = matches.filter(m => m && m.hero_id);

        const roleMetrics = computeRoleMetrics(valid, heroesById);
        const streaks = computeStreaks(valid);
        const context = computeContext(valid);
        const laneStats = computeLaneStats(valid);
        const forecast = buildRoleForecast(roleMetrics, streaks, context);

        renderRoleForecast(forecast);
        renderRolesTable(roleMetrics);
        renderStreaks(streaks);
        renderContext(context);
        renderRecent(valid, heroesById);
        renderLaneStats(laneStats);

      } catch (err) {
        console.error(err);
        alert('Помилка завантаження або парсингу даних: ' + err.message);
      } finally {
        btn.disabled = false;
        btn.textContent = 'Запустити аналіз';
      }
    }

    document.getElementById('runBtn').addEventListener('click', run);

    // Для швидкого тесту: постав account_id у URL як ?id=XXXXX
    (function initFromQuery() {
      const params = new URLSearchParams(location.search);
      const id = params.get('id');
      if (id) {
        document.getElementById('accountId').value = id;
      }
    })();
  </script>
</body>
</html>














