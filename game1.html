<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Dota 2 Match Predictor (OpenDota)</title>
  <style>
    body { background:#111; color:#eee; font-family:monospace; padding:20px; }
    h1 { color:#6cf; }
    h2 { color:#9cf; }
    h3 { color:#acf; }
    .match { margin:5px 0; padding:5px; border-bottom:1px solid #333; }
    .good { color:#6f6; }
    .bad { color:#f66; }
    table { border-collapse: collapse; margin:10px 0; width:auto; }
    th, td { border:1px solid #333; padding:6px 8px; text-align:left; }
    img.hero { width:40px; height:40px; vertical-align:middle; margin-right:6px; }
    #boosterRuinerStats { margin:8px 0 16px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Dota 2 Match Predictor</h1>

  <div id="summary"></div>

  <h3>üìà –ì—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤</h3>
  <canvas id="matchChart" width="900" height="260"></canvas>
  <div id="boosterRuinerStats"></div>

  <div id="matches"></div>

  <script>
    const accountId32 = 863386335; // —Ç–≤—ñ–π Steam32 ID
    const MATCH_COUNT = 100;

    async function fetchMatchHistory() {
      const url = `http://localhost:3000/api/matches?account_id=${accountId32}&count=${MATCH_COUNT}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Server unavailable");
      return await res.json();
    }

    async function getHeroesMap() {
      const res = await fetch("https://api.opendota.com/api/heroes");
      const heroes = await res.json();
      const map = {};
      for (const h of heroes) {
        const short = h.name.replace("npc_dota_hero_", "");
        map[h.id] = {
          name: h.localized_name,
          img: `https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/${short}.png`
        };
      }
      return map;
    }

    function roleLabel(id) {
      const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
      return roleNames[id] || "Unknown";
    }

    function safePercent(n) {
      if (!isFinite(n)) return "0.0";
      return n.toFixed(1);
    }

    function buildPrediction({ winrate, streak, lastResultBool, rolesAgg, boosters, ruiners, total, tempoWr }) {
      let score = winrate;

      // —ñ–º–ø—É–ª—å—Å —Å–µ—Ä—ñ—ó
      if (streak > 2 && lastResultBool) score += 5;
      if (streak > 2 && !lastResultBool) score -= 5;

      // —Ç–µ–º–ø
      if (tempoWr.short > winrate) score += 3;
      if (tempoWr.long > winrate) score += 3;

      // —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å (–Ω–∞–π–≤–∏—â–∏–π WR —Å–µ—Ä–µ–¥ –Ω–∞—è–≤–Ω–∏—Ö)
      let bestRole = null;
      for (const [rid, agg] of Object.entries(rolesAgg)) {
        if (agg.games === 0) continue;
        if (!bestRole || agg.wr > bestRole.wr) bestRole = { id: Number(rid), wr: agg.wr };
      }
      if (bestRole && bestRole.wr > winrate) score += 4;

      score = Math.max(5, Math.min(95, score));

      const boosterChance = safePercent((boosters / total) * 100);
      const ruinerChance = safePercent((ruiners / total) * 100);
      const nextWinStreakChance = !lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";
      const nextLoseStreakChance = lastResultBool ? "–í–∏—Å–æ–∫–∏–π" : "–ù–∏–∑—å–∫–∏–π";

      return {
        score: score.toFixed(1),
        boosterChance,
        ruinerChance,
        nextWinStreakChance,
        nextLoseStreakChance,
        recommendedRole: bestRole ? `${roleLabel(bestRole.id)} (${bestRole.wr.toFixed(1)}% WR)` : "–Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö"
      };
    }

    async function analyzeMatches() {
      try {
        const matches = await fetchMatchHistory();
        const heroesMap = await getHeroesMap();

        if (!matches || matches.length === 0) {
          document.getElementById("summary").innerHTML =
            "‚ùå –ú–∞—Ç—á—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä Steam32 ID –∞–±–æ –æ–Ω–æ–≤–∏ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞ OpenDota.";
          return;
        }

        const container = document.getElementById("matches");

        let total = 0, wins = 0, sumKDA = 0;
        let streak = 0, lastResult = null, avgDuration = 0;
        let boosters = 0, ruiners = 0;
        let allyBoosters = 0, enemyBoosters = 0, allyRuiners = 0, enemyRuiners = 0;

        const roles = {1:[],2:[],3:[],4:[],5:[]};
        const heroes = {};
        const durations = {short:[], mid:[], long:[]};

        const labels = [], colors = [];

        for (const [idx, m] of matches.entries()) {
          const k = m.kills || 0, d = m.deaths || 0, a = m.assists || 0;
          const kda = ((k + a) / Math.max(1, d));
          const win = (m.player_slot < 128) === m.radiant_win;
          const duration = m.duration || 0;

          total++;
          if (win) wins++;
          sumKDA += kda;
          avgDuration += duration;

          // streak
          if (lastResult === null || lastResult === win) streak++;
          else streak = 1;
          lastResult = win;

          // –±—É—Å—Ç–µ—Ä/—Ä—É—ñ–Ω–µ—Ä —Å–∏–≥–Ω–∞–ª –¥–ª—è –í–Ü–ó–£–ê–õ–£
          let color = "#888";
          const isAlly = (m.player_slot < 128) === m.radiant_win; // –º–æ—è –∫–æ–º–∞–Ω–¥–∞ = —Ç–∞, —â–æ –≤–∏–≥—Ä–∞–ª–∞, —è–∫—â–æ win===true
          if (kda >= 6 && win) {
            boosters++;
            color = "green";
            if (isAlly) allyBoosters++; else enemyBoosters++;
          } else if (kda <= 1 && !win) {
            ruiners++;
            color = "red";
            if (isAlly) allyRuiners++; else enemyRuiners++;
          }

          // —Ä–æ–ª—ñ
          if (m.lane_role && roles[m.lane_role]) roles[m.lane_role].push({ win, kda });

          // –≥–µ—Ä–æ—ó
          if (!heroes[m.hero_id]) heroes[m.hero_id] = [];
          heroes[m.hero_id].push({ win, kda });

          // —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
          if (duration < 1800) durations.short.push(win);
          else if (duration < 2400) durations.mid.push(win);
          else durations.long.push(win);

          // –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫–∞
          labels.push("M" + (idx + 1));
          colors.push(color);

          // —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á—ñ–≤
          const heroInfo = heroesMap[m.hero_id];
          const heroCell = heroInfo
            ? `<img class="hero" src="${heroInfo.img}" alt="${heroInfo.name}"> ${heroInfo.name}`
            : `Hero ${m.hero_id}`;
          const div = document.createElement("div");
          div.className = "match";
          div.innerHTML = `Match ${m.match_id}: 
            <span class="${win ? 'good':'bad'}">${win ? 'WIN':'LOSS'}</span> 
            | ${heroCell} | K=${k}, D=${d}, A=${a}, KDA=${kda.toFixed(2)} | ${Math.round(duration/60)} —Ö–≤`;
          container.appendChild(div);
        }

        const winrate = parseFloat(((wins / total) * 100).toFixed(1));
        const avgKDAstr = (sumKDA / total).toFixed(2);
        avgDuration = Math.round((avgDuration / total) / 60);

        // –∞–≥—Ä–µ–≥–∞—Ç–∏ —Ä–æ–ª–µ–π
        const rolesAgg = {};
        for (let r = 1; r <= 5; r++) {
          const arr = roles[r] || [];
          const games = arr.length;
          const wr = games ? (arr.filter(x => x.win).length / games) * 100 : 0;
          const ak = games ? (arr.reduce((s, x) => s + x.kda, 0) / games) : 0;
          rolesAgg[r] = { games, wr, ak };
        }

        // WR –∑–∞ —Ç–µ–º–ø–æ–º
        const tempoWr = {
          short: durations.short.length ? (durations.short.filter(x => x).length / durations.short.length) * 100 : 0,
          mid: durations.mid.length ? (durations.mid.filter(x => x).length / durations.mid.length) * 100 : 0,
          long: durations.long.length ? (durations.long.filter(x => x).length / durations.long.length) * 100 : 0
        };

        // –ø—Ä–æ–≥–Ω–æ–∑
        const prediction = buildPrediction({
          winrate,
          streak,
          lastResultBool: !!lastResult,
          rolesAgg,
          boosters,
          ruiners,
          total,
          tempoWr
        });

        // ‚Äî‚Äî‚Äî –í–∏–≤—ñ–¥ Summary —Ç–∞ –ü—Ä–æ–≥–Ω–æ–∑—É ‚Äî‚Äî‚Äî
        let html = `<h2>üìä Summary (${total} –º–∞—Ç—á—ñ–≤)</h2>
          Winrate: ${winrate}%<br>
          –°–µ—Ä–µ–¥–Ω—ñ–π KDA: ${avgKDAstr}<br>
          –°–µ—Ä–µ–¥–Ω—è —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${avgDuration} —Ö–≤<br>
          –ü–æ—Ç–æ—á–Ω–∞ —Å–µ—Ä—ñ—è: ${streak} ${lastResult ? "W" : "L"}<br><br>`;

        html += `<h2>üîÆ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É</h2>
          –®–∞–Ω—Å –ø–µ—Ä–µ–º–æ–≥–∏: ${prediction.score}%<br>
          –®–∞–Ω—Å –±—É—Å—Ç–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.boosterChance}%<br>
          –®–∞–Ω—Å —Ä—É—ñ–Ω–µ—Ä–∞ –≤ –∫–æ–º–∞–Ω–¥—ñ: ${prediction.ruinerChance}%<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É win-streak: ${prediction.nextWinStreakChance}<br>
          –®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É lose-streak: ${prediction.nextLoseStreakChance}<br>
          –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å: ${prediction.recommendedRole}<br><br>`;

        // –†–æ–ª—ñ
        html += `<h3>üé≠ –†–æ–ª—ñ</h3><table>
          <tr><th>–†–æ–ª—å</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
        for (let r = 1; r <= 5; r++) {
          const { games, wr, ak } = rolesAgg[r];
          if (!games) continue;
          html += `<tr>
            <td>${roleLabel(r)}</td>
            <td>${games}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // –¢–æ–ø –≥–µ—Ä–æ—ó
        html += `<h3>ü¶∏‚Äç‚ôÇÔ∏è –¢–æ–ø –≥–µ—Ä–æ—ó</h3>
          <table>
            <tr><th>–ì–µ—Ä–æ–π</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
        const topHeroes = Object.entries(heroes)
          .sort((a, b) => b[1].length - a[1].length)
          .slice(0, 5);
        for (const [hid, arr] of topHeroes) {
          const wr = (arr.filter(x => x.win).length / arr.length) * 100;
          const ak = arr.reduce((s, x) => s + x.kda, 0) / arr.length;
          const hero = heroesMap[hid];
          const heroCell = hero
            ? `<img class="hero" src="${hero.img}" alt="${hero.name}"> ${hero.name}`
            : `Hero ${hid}`;
          html += `<tr>
            <td>${heroCell}</td>
            <td>${arr.length}</td>
            <td>${wr.toFixed(1)}%</td>
            <td>${ak.toFixed(2)}</td>
          </tr>`;
        }
        html += `</table>`;

        // –¢–µ–º–ø
        html += `<h3>‚è±Ô∏è –¢–µ–º–ø —ñ–≥–æ—Ä</h3><table>
          <tr><th>–ö–∞—Ç–µ–≥–æ—Ä—ñ—è</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th></tr>`;
        const tempoRows = [
          { name: "<30 —Ö–≤", arr: durations.short, wr: tempoWr.short },
          { name: "30‚Äì40 —Ö–≤", arr: durations.mid, wr: tempoWr.mid },
          { name: ">40 —Ö–≤", arr: durations.long, wr: tempoWr.long }
        ];
        for (const row of tempoRows) {
          if (!row.arr.length) continue;
          html += `<tr>
            <td>${row.name}</td>
            <td>${row.arr.length}</td>
            <td>${row.wr.toFixed(1)}%</td>
          </tr>`;
        }
        html += `</table>`;

        document.getElementById("summary").innerHTML = html;

        // ‚Äî‚Äî‚Äî –ì—Ä–∞—Ñ—ñ–∫ –º–∞—Ç—á—ñ–≤ (–±–∞—Ä, –∫–æ–ª—å–æ—Ä–∏: –∑–µ–ª–µ–Ω–∏–π=–±—É—Å—Ç–µ—Ä, —á–µ—Ä–≤–æ–Ω–∏–π=—Ä—É—ñ–Ω–µ—Ä, —Å—ñ—Ä–∏–π=–∑–≤–∏—á–∞–π–Ω–∏–π) ‚Äî‚Äî‚Äî
        const ctx = document.getElementById("matchChart").getContext("2d");
        new Chart(ctx, {
          type: "bar",
          data: {
            labels,
            datasets: [{
              label: "–ú–∞—Ç—á—ñ",
              data: new Array(labels.length).fill(1),
              backgroundColor: colors
            }]
          },
          options: {
            plugins: { legend: { display: false }, tooltip: { enabled: false } },
            scales: {
              x: { display: false },
              y: { display: false }
            }
          }
        });

        // --- –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö ---
function predictByRole(matches, rolesAgg) {
  const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
  const roleStats = {};

  for (let r=1;r<=5;r++) {
    const arr = matches.filter(m => m.lane_role === r);
    if (arr.length === 0) continue;

    const baseWR = (arr.filter(m => ((m.player_slot<128)===m.radiant_win)).length/arr.length)*100;

    // –º–∞—Ç—á—ñ –∑ –±—É—Å—Ç–µ—Ä–∞–º–∏ –Ω–∞ —Ü—ñ–π —Ä–æ–ª—ñ
    const boosterMatches = arr.filter(m => {
      const kda = (m.kills+m.assists)/Math.max(1,m.deaths);
      return kda>=6;
    });
    const boosterWR = boosterMatches.length ? 
      (boosterMatches.filter(m => ((m.player_slot<128)===m.radiant_win)).length/boosterMatches.length)*100 : baseWR;

    // –º–∞—Ç—á—ñ –∑ —Ä—É—ñ–Ω–µ—Ä–∞–º–∏ –Ω–∞ —Ü—ñ–π —Ä–æ–ª—ñ
    const ruinerMatches = arr.filter(m => {
      const kda = (m.kills+m.assists)/Math.max(1,m.deaths);
      return kda<=1;
    });
    const ruinerWR = ruinerMatches.length ? 
      (ruinerMatches.filter(m => ((m.player_slot<128)===m.radiant_win)).length/ruinerMatches.length)*100 : baseWR;

    // –ø—Ä–æ–≥–Ω–æ–∑: –±–∞–∑–æ–≤–∏–π + –≤–ø–ª–∏–≤ –±—É—Å—Ç–µ—Ä—ñ–≤/—Ä—É—ñ–Ω–µ—Ä—ñ–≤
    let predicted = baseWR;
    if (boosterMatches.length>0) predicted = (predicted*0.7 + boosterWR*0.3);
    if (ruinerMatches.length>0) predicted = (predicted*0.7 + ruinerWR*0.3);

    roleStats[r] = {
      name: roleNames[r],
      baseWR: baseWR.toFixed(1),
      boosterWR: boosterWR.toFixed(1),
      ruinerWR: ruinerWR.toFixed(1),
      predicted: predicted.toFixed(1)
    };
  }
  return roleStats;
}

const rolePredictions = predictByRole(matches, rolesAgg);

// —Ç–∞–±–ª–∏—Ü—è –ø—Ä–æ–≥–Ω–æ–∑—ñ–≤
html += `<h3>üéØ –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ —Ä–æ–ª—è—Ö</h3>
<table>
<tr><th>–†–æ–ª—å</th><th>–ë–∞–∑–æ–≤–∏–π WR</th><th>WR –∑ –±—É—Å—Ç–µ—Ä–∞–º–∏</th><th>WR –∑ —Ä—É—ñ–Ω–µ—Ä–∞–º–∏</th><th>–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É</th></tr>`;
let bestRole = null;
for (const r in rolePredictions) {
  const rp = rolePredictions[r];
  if (!bestRole || parseFloat(rp.predicted) > parseFloat(bestRole.predicted)) bestRole = rp;
  html += `<tr>
    <td>${rp.name}</td>
    <td>${rp.baseWR}%</td>
    <td>${rp.boosterWR}%</td>
    <td>${rp.ruinerWR}%</td>
    <td><b>${rp.predicted}%</b></td>
  </tr>`;
}
html += `</table>`;
if (bestRole) {
  html += `<p>‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∞ —Ä–æ–ª—å –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º–∞—Ç—á—É: <b>${bestRole.name}</b> (${bestRole.predicted}% —à–∞–Ω—Å—ñ–≤ –Ω–∞ –ø–µ—Ä–µ–º–æ–≥—É)</p>`;
}

        // –í—ñ–¥—Å–æ—Ç–∫–∏ –±—É—Å—Ç–µ—Ä—ñ–≤/—Ä—É—ñ–Ω–µ—Ä—ñ–≤ —É –º–æ—ó–π —Ç–∞ –≤–æ—Ä–æ–∂—ñ–π –∫–æ–º–∞–Ω–¥–∞—Ö
        const allyEvents = allyBoosters + allyRuiners;
        const enemyEvents = enemyBoosters + enemyRuiners;
        const allyPercent = safePercent((allyEvents / total) * 100);
        const enemyPercent = safePercent((enemyEvents / total) * 100);
        document.getElementById("boosterRuinerStats").innerHTML =
          `–£ —Ç–≤–æ—ó–π –∫–æ–º–∞–Ω–¥—ñ: ${allyPercent}% –º–∞—Ç—á—ñ–≤ —ñ–∑ –±—É—Å—Ç–µ—Ä–æ–º/—Ä—É—ñ–Ω–µ—Ä–æ–º (–∑–µ–ª–µ–Ω–∏–π/—á–µ—Ä–≤–æ–Ω–∏–π).<br>` +
          `–£ —Å—É–ø–µ—Ä–Ω–∏–∫—ñ–≤: ${enemyPercent}% –º–∞—Ç—á—ñ–≤ —ñ–∑ –±—É—Å—Ç–µ—Ä–æ–º/—Ä—É—ñ–Ω–µ—Ä–æ–º (–∑–µ–ª–µ–Ω–∏–π/—á–µ—Ä–≤–æ–Ω–∏–π).`;

      } catch (err) {
        document.getElementById("summary").innerHTML = "‚ö†Ô∏è –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –∞–±–æ –ø–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É.";
        console.error(err);
      }
    }

    analyzeMatches();
  </script>
</body>
</html>

    analyzeMatches();
  </script>
</body>
</html>
