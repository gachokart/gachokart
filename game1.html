<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>game1 ‚Äî –ê–Ω–∞–ª—ñ—Ç–∏–∫–∞ —ñ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{--bg:#0b1220;--card:#09111a;--muted:#9aa7bd;--accent:#1f8feb}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#071027 0%,#07111b 100%);color:#e6eef6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
    .wrap{max-width:1100px;width:100%}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    input,button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:9px;border-radius:8px;color:inherit}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);text-align:left}
    .meta{font-size:13px;color:var(--muted)}
    .prediction{padding:12px;border-radius:10px;margin-bottom:10px}
    .pred-good{background:linear-gradient(90deg,#063b12,#0d6430);color:#dfffe0}
    .pred-bad{background:linear-gradient(90deg,#3b0606,#641010);color:#ffe0e0}
    .pred-neutral{background:linear-gradient(90deg,#2a2a3b,#3b3b5a);color:#fff}
    .reason{font-size:13px;margin:6px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    #patterns{display:none;margin-top:12px}
    .charts{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .hero-list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .hero-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hero-item img{width:48px;height:28px;object-fit:cover;border-radius:4px}
    @media (max-width:920px){.grid{grid-template-columns:1fr} .charts{grid-template-columns:1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="card" style="flex:1;display:flex;align-items:center;justify-content:space-between;padding:12px">
      <div>
        <h1>game1 ‚Äî –ü—Ä–æ–≥–Ω–æ–∑ + –ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</h1>
        <div class="small">OpenDota –∞–Ω–∞–ª—ñ–∑ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö —ñ–≥–æ—Ä ‚Üí –ø—Ä–æ–≥–Ω–æ–∑, –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ, –≥—Ä–∞—Ñ—ñ–∫–∏, —Ç–æ–ø-3 –≥–µ—Ä–æ—ó–≤.</div>
      </div>
      <div class="small">–¢–µ—Å—Ç–æ–≤–∏–π ID: <strong>863386335</strong></div>
    </div>
  </header>

  <div class="card">
    <div style="display:flex;flex-direction:column">
      <label>Steam64 ID –∞–±–æ OpenDota account_id:</label>
      <div class="inputs">
        <input id="idInput" placeholder="Steam64 –∞–±–æ account_id" />
        <select id="limitSelect">
          <option value="20">–û—Å—Ç–∞–Ω–Ω—ñ 20 —ñ–≥–æ—Ä</option>
          <option value="50">–û—Å—Ç–∞–Ω–Ω—ñ 50 —ñ–≥–æ—Ä</option>
          <option value="100">–û—Å—Ç–∞–Ω–Ω—ñ 100 —ñ–≥–æ—Ä</option>
        </select>
        <button id="fetchBtn">–û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑</button>
        <button id="patternsBtn">–ü–æ–∫–∞–∑–∞—Ç–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</button>
        <button id="demoBtn">–¢–µ—Å—Ç–æ–≤–∏–π ID</button>
      </div>
      <div class="small" style="margin-top:8px">–ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü–æ–∫–∞–∑–∞—Ç–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ¬ª –ø—ñ—Å–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–æ–≥–Ω–æ–∑—É ‚Äî –ø–æ–±—É–¥—É—é—Ç—å—Å—è –≥—Ä–∞—Ñ—ñ–∫–∏ winrate –ø–æ –¥–Ω—è—Ö —ñ –≥–æ–¥–∏–Ω–∞—Ö —ñ –≤–∏—è–≤–ª—è—Ç—å—Å—è –ø–æ–≤—Ç–æ—Ä—é–≤–∞–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏.</div>
    </div>
  </div>

  <div class="grid">
    <div class="card" id="leftCard">
      <h3>–û—Å—Ç–∞–Ω–Ω—ñ –º–∞—Ç—á—ñ</h3>
      <div id="statsSummary" class="meta"></div>
      <div style="margin-top:8px;max-height:420px;overflow:auto">
        <table id="matchesTable">
          <thead><tr><th>–î–∞—Ç–∞</th><th>–ì–µ—Ä–æ–π</th><th>K/D/A</th><th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th><th>–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <aside class="card" id="rightCard">
      <h3>–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –º–∞—Ç—á</h3>
      <div id="predictionArea" class="prediction pred-neutral">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</div>
      <div id="predictionDetails" class="meta"></div>
      <div id="patterns" class="meta card">
        <h4>–ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ –º–∞—Ç—á—ñ–≤</h4>
        <div class="charts">
          <canvas id="chartDays" width="400" height="200"></canvas>
          <canvas id="chartHours" width="400" height="200"></canvas>
        </div>
        <div id="patternText" style="margin-top:10px"></div>
        <h4 style="margin-top:10px">–¢–æ–ø-3 –≥–µ—Ä–æ—ó</h4>
        <div id="topHeroes" class="hero-list"></div>
      </div>
    </aside>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // ==== –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ
  let lastMatches = null, lastSummary = null, lastHeroesConst = null;

  // ---- –£—Ç–∏–ª—ñ—Ç–∏
  function steam64ToAccountId(steam64){ try{ const n=BigInt(steam64); const base=BigInt('76561197960265728'); if(n<=BigInt(4294967295)) return Number(n); return Number(n-base);}catch(e){return NaN} }
  function playerWon(m){ const playerRadiant = (m.player_slot||0) < 128; return (playerRadiant && m.radiant_win) || (!playerRadiant && !m.radiant_win); }
  function secsToMinSecs(s){ const m=Math.floor(s/60), sec=s%60; return m+':'+String(sec).padStart(2,'0'); }
  const winrate = (wins,games)=>games?wins/games*100:0;

  // ==== –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥–µ—Ä–æ—ó–≤
  const HERO_CACHE_KEY = 'heroesCache';
  const CACHE_EXPIRY_MS = 24*60*60*1000; // 1 –¥–µ–Ω—å

  async function fetchHeroesWithCache() {
    const cached = localStorage.getItem(HERO_CACHE_KEY);
    if(cached){
      const parsed=JSON.parse(cached);
      if(Date.now()-parsed.timestamp<CACHE_EXPIRY_MS){ console.log('–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –∫–µ—à –≥–µ—Ä–æ—ó–≤'); return parsed.data; }
    }
    console.log('–ü—ñ–¥—Ç—è–≥—É—î–º–æ –≥–µ—Ä–æ—ó–≤ –∑ OpenDota');
    const res=await fetch('https://api.opendota.com/api/constants/heroes'); 
    if(!res.ok) throw new Error('OpenDota heroes fetch failed');
    const heroesConstRaw = await res.json();
    const heroList = Object.values(heroesConstRaw).map(h=>({
      id: h.id, name: h.localized_name, roles:[h.attack_type,...h.roles], img:h.img?'https://api.opendota.com'+h.img:null, winrate:h.pro_win||0, pickrate:h.pro_pick||0
    }));
    localStorage.setItem(HERO_CACHE_KEY, JSON.stringify({timestamp:Date.now(), data:heroList}));
    return heroList;
  }

  // ==== –ê–Ω–∞–ª—ñ–∑ –º–∞—Ç—á—ñ–≤
  function analyzeMatches(matches){
    const out={games:matches.length,wins:0,k:0,d:0,a:0,dur:0,shortWins:0,shortLosses:0,longWins:0,longLosses:0,leaves:0,byHero:{},seq:[]};
    for(const m of matches){
      const won=playerWon(m);
      out.seq.push(won?'W':'L');
      if(won) out.wins++;
      const kills=m.kills||0,deaths=m.deaths||0,assists=m.assists||0,duration=m.duration||0;
      out.k+=kills; out.d+=deaths; out.a+=assists; out.dur+=duration;
      if(duration<1500 && won) out.shortWins++; if(duration<1500 && !won) out.shortLosses++;
      if(duration>2700 && won) out.longWins++; if(duration>2700 && !won) out.longLosses++;
      if(m.leaver_status && m.leaver_status!==0) out.leaves++;
      const hid=m.hero_id||0;
      if(!out.byHero[hid]) out.byHero[hid]={games:0,wins:0};
      out.byHero[hid].games++; if(won) out.byHero[hid].wins++;
    }
    out.winrate=out.games?out.wins/out.games*100:0;
    out.avgK=out.games?out.k/out.games:0;
    out.avgD=out.games?out.d/out.games:0;
    out.avgA=out.games?out.a/out.games:0;
    out.avgKDA=out.avgD?(out.avgK+out.avgA)/out.avgD:(out.avgK+out.avgA);
    out.avgDuration=out.games?out.dur/out.games:0;
    out.pctShortWins=out.games?out.shortWins/out.games*100:0;
    out.pctShortLosses=out.games?out.shortLosses/out.games*100:0;
    out.pctLongWins=out.games?out.longWins/out.games*100:0;
    out.pctLongLosses=out.games?out.longLosses/out.games*100:0;
    out.leaveRate=out.games?out.leaves/out.games*100:0;
    return out;
  }

  function analyzePhases(matches){
  const phases = [
    {name:'0-27 —Ö–≤', min:0, max:1620, games:0, wins:0, recentScore:0},
    {name:'27-37 —Ö–≤', min:1620, max:2220, games:0, wins:0, recentScore:0},
    {name:'37-60 —Ö–≤', min:2220, max:3600, games:0, wins:0, recentScore:0}
  ];
  for(let i=0;i<matches.length;i++){
    const m = matches[i];
    const dur = m.duration||0;
    const won = playerWon(m);
    const phase = phases.find(p=>dur>=p.min && dur< p.max);
    if(phase){
      phase.games++;
      if(won) phase.wins++;
      // –î–æ–¥–∞—Ç–∫–æ–≤–æ: –¥–∏–Ω–∞–º—ñ–∫–∞ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –º–∞—Ç—á—ñ–≤
      phase.recentScore += won?1:-1;
    }
  }
  phases.forEach(p=>p.winrate=p.games?p.wins/p.games*100:0);
  return phases;
}

  // ==== –ü—Ä–æ–≥–Ω–æ–∑ (—Å–ø—Ä–æ—â–µ–Ω–∏–π)
  const defaultWeights = { winrate:0.9, kda:6, shortGamePenalty:-3, shortLossPenalty:-4, leaveRatePenalty:v=>-Math.min(10,Math.round(v)) };
  function computeDetailedProbabilities(summary,w=defaultWeights){
    const reasons=[];
    let winProb=50;
    winProb+= (summary.winrate-50)*w.winrate; reasons.push({factor:"Winrate",value:summary.winrate});
    winProb+= (summary.avgKDA-2)*w.kda; reasons.push({factor:"KDA",value:summary.avgKDA});
    if(summary.avgDuration<1200){ winProb+=w.shortGamePenalty; reasons.push({factor:"Short games"});}
    if(summary.pctShortLosses>20){ winProb+=w.shortLossPenalty; reasons.push({factor:"Short losses"});}
    if(summary.leaveRate>5){ const v=w.leaveRatePenalty(summary.leaveRate); winProb+=v; reasons.push({factor:"Leave rate"});}
    winProb=Math.max(3,Math.min(97,Math.round(winProb)));
    return {winProb,reasons};
  }

  // ==== –†–µ–Ω–¥–µ—Ä –º–∞—Ç—á—ñ–≤
  function renderMatches(matches, heroesConst){
    const tbody=document.querySelector('#matchesTable tbody'); 
    tbody.innerHTML='';
    matches.forEach(m=>{
      const tr=document.createElement('tr');
      const d=new Date((m.start_time||0)*1000);
      const hid=m.hero_id||0;
      const heroData = heroesConst[hid] || {};
      const heroName = heroData.name||`Hero ${hid}`;
      const heroImg = heroData.img||'';
      tr.innerHTML=`
        <td>${d.toLocaleString()}</td>
        <td><img src="${heroImg}" alt="${heroName}" style="width:28px;height:16px;object-fit:cover;border-radius:3px;margin-right:4px;vertical-align:middle">${heroName}</td>
        <td>${m.kills||0}/${m.deaths||0}/${m.assists||0}</td>
        <td>${playerWon(m)?'W':'L'}</td>
        <td>${secsToMinSecs(m.duration||0)}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  // ==== –†–µ–Ω–¥–µ—Ä –ø—Ä–æ–≥–Ω–æ–∑—É
  function renderPredictionUI(summary,pred){
    const area=document.getElementById('predictionArea');
    const details=document.getElementById('predictionDetails');
    area.className='prediction '+(pred.winProb>=50?'pred-good':'pred-bad');
    area.textContent=`–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–º–æ–≥–∏: ${pred.winProb}%`;
    details.innerHTML=pred.reasons.map(r=>`${r.factor}`).join(', ');
  }

  // ==== –ê–Ω–∞–ª—ñ–∑ —Ç–æ–ø-–≥–µ—Ä–æ—ó–≤
  function analyzeTopHeroes(summary, heroesConst, minGames=2){
    const heroStats=[];
    for(const id in summary.byHero){
      const data=summary.byHero[id];
      if(data.games>=minGames){
        const hero=heroesConst[id]||{};
        heroStats.push({id,name:hero.name||`Hero ${id}`,games:data.games,wins:data.wins,winrate:winrate(data.wins,data.games)});
      }
    }
    heroStats.sort((a,b)=>b.winrate-a.winrate);
    return heroStats.slice(0,3);
  }

  // ==== –ü–∞—Ç–µ—Ä–Ω–∏ (–¥–Ω—ñ/–≥–æ–¥–∏–Ω–∏/–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ)
  function analyzePatterns(matches, summary, heroesConst){
    const days=Array(7).fill(0).map(()=>({games:0,wins:0}));
    const hours=Array(24).fill(0).map(()=>({games:0,wins:0}));
    for(const m of matches){
      const d=new Date((m.start_time||0)*1000);
      const won=playerWon(m);
      days[d.getDay()].games++; if(won) days[d.getDay()].wins++;
      hours[d.getHours()].games++; if(won) hours[d.getHours()].wins++;
    }
    const top3=analyzeTopHeroes(summary,heroesConst,2);
    return {dayRates:days,hourRates:hours,top3};
  }

  // ==== –†–µ–Ω–¥–µ—Ä –ø–∞—Ç–µ—Ä–Ω—ñ–≤
  function renderPatternsUI(patterns, heroesConst){
    document.getElementById('patterns').style.display='block';
    const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML='';
    if(patterns.top3.length===0){
      topRoot.innerHTML='<div class="small">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—è—Ö (min 2)</div>';
    } else {
      patterns.top3.forEach(h=>{
        const heroData = heroesConst[h.id]||{};
        const el=document.createElement('div'); el.className='hero-item';
        const img=document.createElement('img'); img.src=heroData.img||''; img.alt=h.name;
        const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% ¬∑ –Ü–≥–æ—Ä: ${h.games}</div>`;
        el.appendChild(img); el.appendChild(info); topRoot.appendChild(el);
      });
    }

    // ---- –†–µ–Ω–¥–µ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Ñ–∞–∑–∞—Ö —Ç–∞ –ø—Ä–æ–≥–Ω–æ–∑ —Ç—Ä–∏–≤–∞–ª–æ—Å—Ç—ñ –≥—Ä–∏
function renderPhaseStats(summary, predictedLength){
  const container = document.createElement('div');
  container.innerHTML = '<h4>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç—Ä–∏–≤–∞–ª–æ—Å—Ç—ñ –º–∞—Ç—á—ñ–≤ (—Ñ–∞–∑–∏)</h4>';
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr><th>–§–∞–∑–∞</th><th>–Ü–≥–æ—Ä</th><th>Winrate %</th><th>–î–∏–Ω–∞–º—ñ–∫–∞</th></tr>
    </thead>
    <tbody></tbody>
  `;
  const tbody = table.querySelector('tbody');
  const phases = analyzePhases(lastMatches); 
  phases.forEach(p => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${p.name}</td>
      <td>${p.games}</td>
      <td>${p.winrate.toFixed(1)}</td>
      <td>${(p.recentScore*5).toFixed(1)}%</td>
    `;
    tbody.appendChild(tr);
  });
  container.appendChild(table);

  const predDiv = document.createElement('div');
  predDiv.style.marginTop='8px';
  predDiv.innerHTML = `<strong>–ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –≥—Ä–∏:</strong> ${secsToMinSecs(predictedLength)}`;
  container.appendChild(predDiv);

  document.getElementById('predictionDetails').appendChild(container);
}


  // –ü—Ä–æ–≥–Ω–æ–∑ —Ç—Ä–∏–≤–∞–ª–æ—Å—Ç—ñ –≥—Ä–∏
  const predDiv = document.createElement('div');
  predDiv.style.marginTop='8px';
  predDiv.innerHTML = `<strong>–ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –≥—Ä–∏:</strong> ${secsToMinSecs(predictedLength)}`;
  container.appendChild(predDiv);

  document.getElementById('predictionDetails').appendChild(container);
}
document.getElementById('fetchBtn').addEventListener('click', async ()=> {
  const raw = document.getElementById('idInput').value.trim();
  if(!raw) return alert('–í–≤–µ–¥—ñ—Ç—å ID');

  const id = raw.length > 12 ? steam64ToAccountId(raw) : Number(raw);
  if(isNaN(id)) return alert('–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ ID');

  const limit = Number(document.getElementById('limitSelect').value);
  document.getElementById('predictionArea').textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...';

  try {
    // üîπ –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –º–∞—Ç—á—ñ
    const matches = await fetchOpenDotaMatches(id, limit);

    // üîπ –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∫–µ—à–æ–≤–∞–Ω–∏—Ö –≥–µ—Ä–æ—ó–≤ (–∞–±–æ –æ–Ω–æ–≤–ª—é—î–º–æ)
    const heroesList = await fetchHeroesWithCache();

    // üîπ –§–æ—Ä–º—É—î–º–æ –æ–±‚Äô—î–∫—Ç –¥–ª—è –∑—Ä—É—á–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø—É –ø–æ id
    const heroesConst = {};
    heroesList.forEach(h => heroesConst[h.id] = h);

    lastMatches = matches;
    lastSummary = analyzeMatches(matches);
    lastHeroesConst = heroesConst;

    // ---- –û—Å—å —Å—é–¥–∏ –≤—Å—Ç–∞–≤–ª—è—î–º–æ –±–ª–æ–∫ ----
    const pred = computeDetailedProbabilities(lastSummary);
renderMatches(lastMatches,lastHeroesConst);
renderPredictionUI(lastSummary,pred);
document.getElementById('predictionDetails').innerHTML='';
renderPhaseStats(lastSummary,predictedLength=lastSummary.avgDuration);

    // —Ö–æ–≤–∞—î–º–æ –ø–∞—Ç–µ—Ä–Ω–∏ –ø–æ–∫–∏ –Ω–µ –Ω–∞—Ç–∏—Å–Ω—É–ª–∏ –∫–Ω–æ–ø–∫—É
    document.getElementById('patterns').style.display = 'none';

  } catch(err) {
    console.error(err);
    document.getElementById('predictionArea').textContent = '–ü–æ–º–∏–ª–∫–∞: ' + err.message;
  }
});

    // –¢—É—Ç –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ chart.js –≥—Ä–∞—Ñ—ñ–∫–∏ (–¥–Ω—ñ/–≥–æ–¥–∏–Ω–∏)
    function renderPatternsUI(patterns, heroesConst){
  document.getElementById('patterns').style.display='block';
  
  // ---- –¢–æ–ø-3 –≥–µ—Ä–æ—ó
  const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML='';
  if(patterns.top3.length===0){
    topRoot.innerHTML='<div class="small">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—è—Ö (min 2)</div>';
  } else {
    patterns.top3.forEach(h=>{
      const heroData = heroesConst[h.id]||{};
      const el=document.createElement('div'); el.className='hero-item';
      const img=document.createElement('img'); img.src=heroData.img||''; img.alt=h.name;
      const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% ¬∑ –Ü–≥–æ—Ä: ${h.games}</div>`;
      el.appendChild(img); el.appendChild(info); topRoot.appendChild(el);
    });
  }

  // ---- Chart.js: Winrate –ø–æ –¥–Ω—è—Ö —Ç–∏–∂–Ω—è (bar)
  const daysLabels=['–ù–¥','–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±'];
  const daysData = patterns.dayRates.map(d => d.games ? (d.wins/d.games*100).toFixed(1) : 0);
  const ctxDays = document.getElementById('chartDays').getContext('2d');
  if(window.chartDays) window.chartDays.destroy();
  window.chartDays = new Chart(ctxDays, {
    type:'bar',
    data:{labels:daysLabels,datasets:[{label:'Winrate %',data:daysData,backgroundColor:'#1f8feb'}]},
    options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,max:100}}}
  });

  // ---- Chart.js: Winrate –ø–æ –≥–æ–¥–∏–Ω–∞–º –¥–æ–±–∏ (pie)
  const hoursLabels=Array.from({length:24},(_,i)=>i+'h');
  const hoursData = patterns.hourRates.map(h => h.games ? (h.wins/h.games*100).toFixed(1) : 0);
  const ctxHours = document.getElementById('chartHours').getContext('2d');
  if(window.chartHours) window.chartHours.destroy();
  window.chartHours = new Chart(ctxHours,{
    type:'pie',
    data:{
      labels:hoursLabels,
      datasets:[{label:'Winrate –ø–æ –≥–æ–¥–∏–Ω–∞–º %',data:hoursData,backgroundColor:hoursLabels.map((_,i)=>`hsl(${i*15},70%,50%)`)}]
    },
    options:{responsive:true,plugins:{legend:{position:'right'}}}
  });
}

  }

  // ==== –ü–æ–¥—ñ—ó –∫–Ω–æ–ø–æ–∫
  document.getElementById('fetchBtn').addEventListener('click',async()=>{
    const idStr=document.getElementById('idInput').value.trim();
    if(!idStr){ alert('–í–≤–µ–¥—ñ—Ç—å Steam64 –∞–±–æ account_id'); return; }
    const accountId=steam64ToAccountId(idStr)||parseInt(idStr,10);
    if(isNaN(accountId)){ alert('–ù–µ–≤—ñ—Ä–Ω–∏–π ID'); return; }

    try{
      const heroesList = await fetchHeroesWithCache();
      const heroesConst={}; heroesList.forEach(h=>heroesConst[h.id]=h);
      lastHeroesConst=heroesConst;

      const limit = parseInt(document.getElementById('limitSelect').value,10)||20;
      const res = await fetch(`https://api.opendota.com/api/players/${accountId}/matches?limit=${limit}`);
      if(!res.ok) throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –º–∞—Ç—á—ñ');
      const matches = await res.json(); lastMatches = matches;

      const summary = analyzeMatches(matches); lastSummary=summary;

      renderMatches(matches, heroesConst);
      const pred=computeDetailedProbabilities(summary);
      renderPredictionUI(summary,pred);

    }catch(e){ console.error(e); alert('–ü–æ–º–∏–ª–∫–∞: '+e.message);}
  });

  document.getElementById('patternsBtn').addEventListener('click',async()=>{
    if(!lastMatches||!lastSummary||!lastHeroesConst){ alert('–°–ø–æ—á–∞—Ç–∫—É –æ—Ç—Ä–∏–º–∞–π—Ç–µ –ø—Ä–æ–≥–Ω–æ–∑'); return; }
    try{
      const patterns = analyzePatterns(lastMatches,lastSummary,lastHeroesConst);
      renderPatternsUI(patterns,lastHeroesConst);
    }catch(e){ console.error(e); alert('–ü–æ–º–∏–ª–∫–∞ –ø–æ–±—É–¥–æ–≤–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç–µ–π: '+e.message);}
  });

  document.getElementById('demoBtn').addEventListener('click',()=>{
    document.getElementById('idInput').value='863386335';
  });

</script>
</body>
</html>



