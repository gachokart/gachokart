<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Dota 2 Match Predictor (OpenDota)</title>
  <style>
    body { background:#111; color:#eee; font-family:monospace; padding:20px; }
    h1 { color:#6cf; }
    .match { margin:5px 0; padding:5px; border-bottom:1px solid #333; }
    .good { color:#6f6; }
    .bad { color:#f66; }
  </style>
</head>
<body>
  <h1>Dota 2 Match Predictor</h1>
  <div id="summary"></div>
  <div id="matches"></div>

  <script>
    const accountId32 = 863386335; // —Ç–≤—ñ–π Steam32 ID
    const MATCH_COUNT = 100;

    async function fetchMatchHistory() {
      const url = `http://localhost:3000/api/matches?account_id=${accountId32}&count=${MATCH_COUNT}`;
      const res = await fetch(url);
      return await res.json(); // OpenDota –æ–¥—Ä–∞–∑—É –ø–æ–≤–µ—Ä—Ç–∞—î –º–∞—Å–∏–≤ –º–∞—Ç—á—ñ–≤
    }

    async function fetchMatchDetails(matchId) {
      const url = `http://localhost:3000/api/match/${matchId}`;
      const res = await fetch(url);
      return await res.json();
    }

    async function getHeroesMap() {
  const res = await fetch("https://api.opendota.com/api/heroes");
  const heroes = await res.json();
  const map = {};
  for (const h of heroes) {
    const short = h.name.replace("npc_dota_hero_", "");
    map[h.id] = {
      name: h.localized_name,
      img: `https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/${short}.png`
    };
  }
  return map;
}



    function analyzePlayer(match, accountId32) {
      // OpenDota –≤–∂–µ –¥–∞—î –ø–æ—Ç—Ä—ñ–±–Ω—ñ –ø–æ–ª—è
      const k = match.kills;
      const d = match.deaths;
      const a = match.assists;
      const kda = ((k + a) / Math.max(1, d)).toFixed(2);
      const win = match.radiant_win === (match.player_slot < 128);
      return { k, d, a, kda: parseFloat(kda), win };
    }

    async function analyzeMatches() {
  const matches = await fetchMatchHistory();
  const heroesMap = await getHeroesMap();
   
  if (!matches || matches.length === 0) {
    document.getElementById("summary").innerHTML =
      "‚ùå –ú–∞—Ç—á—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä Steam32 ID –∞–±–æ –æ–Ω–æ–≤–∏ –ø—Ä–æ—Ñ—ñ–ª—å –Ω–∞ OpenDota.";
    return;
  }

  const container = document.getElementById("matches");
  let total = 0, wins = 0, sumKDA = 0;
  let streak = 0, lastResult = null, avgDuration = 0;

  // –õ—ñ—á–∏–ª—å–Ω–∏–∫–∏
  const roles = {1:[],2:[],3:[],4:[],5:[]};
  const heroes = {};
  const durations = {short:[], mid:[], long:[]};

  for (const m of matches) {
    const k = m.kills, d = m.deaths, a = m.assists;
    const kda = ( (k+a) / Math.max(1,d) );
    const win = (m.player_slot < 128) === m.radiant_win;

    total++;
    if (win) wins++;
    sumKDA += kda;
    avgDuration += m.duration;

    // streak
    if (lastResult === null || lastResult === win) {
      streak++;
    } else {
      streak = 1;
    }
    lastResult = win;

    // —Ä–æ–ª—ñ
    if (m.lane_role) roles[m.lane_role].push({win,kda});

    // –≥–µ—Ä–æ—ó
    if (!heroes[m.hero_id]) heroes[m.hero_id] = [];
    heroes[m.hero_id].push({win,kda});

    // —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å
    if (m.duration < 1800) durations.short.push(win);
    else if (m.duration < 2400) durations.mid.push(win);
    else durations.long.push(win);

    // —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á—ñ–≤
    const div = document.createElement("div");
    div.className = "match";
    div.innerHTML = `Match ${m.match_id}: 
      <span class="${win ? 'good':'bad'}">${win ? 'WIN':'LOSS'}</span> 
      | Hero=${m.hero_id} | K=${k}, D=${d}, A=${a}, KDA=${kda.toFixed(2)} | ${Math.round(m.duration/60)} —Ö–≤`;
    container.appendChild(div);
  }

  const winrate = ((wins/total)*100).toFixed(1);
  const avgKDA = (sumKDA/total).toFixed(2);
  avgDuration = Math.round(avgDuration/total/60);

  // summary
  let html = `<h2>üìä Summary (${total} –º–∞—Ç—á—ñ–≤)</h2>
    Winrate: ${winrate}%<br>
    –°–µ—Ä–µ–¥–Ω—ñ–π KDA: ${avgKDA}<br>
    –°–µ—Ä–µ–¥–Ω—è —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${avgDuration} —Ö–≤<br>
    –ü–æ—Ç–æ—á–Ω–∞ —Å–µ—Ä—ñ—è: ${streak} ${lastResult ? "W" : "L"}<br><br>`;

  // —Ä–æ–ª—ñ
  html += `<h3>üé≠ –†–æ–ª—ñ</h3><table border="1" cellpadding="4"><tr><th>–†–æ–ª—å</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;
  const roleNames = {1:"Carry",2:"Mid",3:"Offlane",4:"Support",5:"Hard Support"};
  for (let r=1;r<=5;r++) {
    const arr = roles[r];
    if (arr.length===0) continue;
    const wr = (arr.filter(x=>x.win).length/arr.length*100).toFixed(1);
    const ak = (arr.reduce((s,x)=>s+x.kda,0)/arr.length).toFixed(2);
    html += `<tr><td>${roleNames[r]}</td><td>${arr.length}</td><td>${wr}%</td><td>${ak}</td></tr>`;
  }
  html += `</table>`;

  // –≥–µ—Ä–æ—ó
  html += `<h3>ü¶∏‚Äç‚ôÇÔ∏è –¢–æ–ø –≥–µ—Ä–æ—ó</h3>
<table border="1" cellpadding="4">
<tr><th>–ì–µ—Ä–æ–π</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th><th>Avg KDA</th></tr>`;

const topHeroes = Object.entries(heroes)
  .sort((a,b)=>b[1].length-a[1].length)
  .slice(0,5);

for (const [hid,arr] of topHeroes) {
  const wr = (arr.filter(x=>x.win).length/arr.length*100).toFixed(1);
  const ak = (arr.reduce((s,x)=>s+x.kda,0)/arr.length).toFixed(2);
  const hero = heroesMap[hid];
  html += `<tr>
    <td><img src="${hero.img}" width="40" style="vertical-align:middle"> ${hero.name}</td>
    <td>${arr.length}</td>
    <td>${wr}%</td>
    <td>${ak}</td>
  </tr>`;
}
html += `</table>`;



  // —Ç–µ–º–ø —ñ–≥–æ—Ä
  html += `<h3>‚è±Ô∏è –¢–µ–º–ø —ñ–≥–æ—Ä</h3><table border="1" cellpadding="4"><tr><th>–ö–∞—Ç–µ–≥–æ—Ä—ñ—è</th><th>–Ü–≥–æ—Ä</th><th>Winrate</th></tr>`;
  for (const [cat,arr] of Object.entries(durations)) {
    if (arr.length===0) continue;
    const wr = (arr.filter(x=>x).length/arr.length*100).toFixed(1);
    const name = cat==="short"?"<30 —Ö–≤":cat==="mid"?"30-40 —Ö–≤":">40 —Ö–≤";
    html += `<tr><td>${name}</td><td>${arr.length}</td><td>${wr}%</td></tr>`;
  }
  html += `</table>`;

  document.getElementById("summary").innerHTML = html;
}

    analyzeMatches();
  </script>
</body>
</html>
    analyzeMatches();
  </script>
</body>
</html>
