<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>game1 ‚Äî –ê–Ω–∞–ª—ñ—Ç–∏–∫–∞ —ñ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{--bg:#0b1220;--card:#09111a;--muted:#9aa7bd;--accent:#1f8feb}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#071027 0%,#07111b 100%);color:#e6eef6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
    .wrap{max-width:1100px;width:100%}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    input,button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:9px;border-radius:8px;color:inherit}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);text-align:left}
    .meta{font-size:13px;color:var(--muted)}
    .prediction{padding:12px;border-radius:10px;margin-bottom:10px}
    .pred-good{background:linear-gradient(90deg,#063b12,#0d6430);color:#dfffe0}
    .pred-bad{background:linear-gradient(90deg,#3b0606,#641010);color:#ffe0e0}
    .pred-neutral{background:linear-gradient(90deg,#2a2a3b,#3b3b5a);color:#fff}
    .reason{font-size:13px;margin:6px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    #patterns{display:none;margin-top:12px}
    .charts{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .hero-list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .hero-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hero-item img{width:48px;height:28px;object-fit:cover;border-radius:4px}
    @media (max-width:920px){.grid{grid-template-columns:1fr} .charts{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="flex:1;display:flex;align-items:center;justify-content:space-between;padding:12px">
        <div>
          <h1>game1 ‚Äî –ü—Ä–æ–≥–Ω–æ–∑ + –ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</h1>
          <div class="small">OpenDota –∞–Ω–∞–ª—ñ–∑ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö —ñ–≥–æ—Ä ‚Üí –ø—Ä–æ–≥–Ω–æ–∑, –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ, –≥—Ä–∞—Ñ—ñ–∫–∏, —Ç–æ–ø-3 –≥–µ—Ä–æ—ó–≤.</div>
        </div>
        <div class="small">–¢–µ—Å—Ç–æ–≤–∏–π ID: <strong>863386335</strong></div>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;flex-direction:column">
        <label>Steam64 ID –∞–±–æ OpenDota account_id:</label>
        <div class="inputs">
          <input id="idInput" placeholder="Steam64 –∞–±–æ account_id" />
          <select id="limitSelect">
            <option value="20">–û—Å—Ç–∞–Ω–Ω—ñ 20 —ñ–≥–æ—Ä</option>
            <option value="50">–û—Å—Ç–∞–Ω–Ω—ñ 50 —ñ–≥–æ—Ä</option>
            <option value="100">–û—Å—Ç–∞–Ω–Ω—ñ 100 —ñ–≥–æ—Ä</option>
          </select>
          <button id="fetchBtn">–û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑</button>
          <button id="patternsBtn">–ü–æ–∫–∞–∑–∞—Ç–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</button>
          <button id="demoBtn">–¢–µ—Å—Ç–æ–≤–∏–π ID</button>
        </div>
        <div class="small" style="margin-top:8px">–ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü–æ–∫–∞–∑–∞—Ç–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ¬ª –ø—ñ—Å–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–æ–≥–Ω–æ–∑—É ‚Äî –ø–æ–±—É–¥—É—é—Ç—å—Å—è –≥—Ä–∞—Ñ—ñ–∫–∏ winrate –ø–æ –¥–Ω—è—Ö —ñ –≥–æ–¥–∏–Ω–∞—Ö —ñ –≤–∏—è–≤–ª—è—Ç—å—Å—è –ø–æ–≤—Ç–æ—Ä—é–≤–∞–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏.</div>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="leftCard">
        <h3>–û—Å—Ç–∞–Ω–Ω—ñ –º–∞—Ç—á—ñ</h3>
        <div id="statsSummary" class="meta"></div>
        <div style="margin-top:8px;max-height:420px;overflow:auto">
          <table id="matchesTable">
            <thead><tr><th>–î–∞—Ç–∞</th><th>–ì–µ—Ä–æ–π</th><th>K/D/A</th><th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th><th>–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <aside class="card" id="rightCard">
        <h3>–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –º–∞—Ç—á</h3>
        <div id="predictionArea" class="prediction pred-neutral">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</div>
        <div id="predictionDetails" class="meta"></div>
        <div id="patterns" class="meta card">
          <h4>–ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ –º–∞—Ç—á—ñ–≤</h4>
          <div class="charts">
            <canvas id="chartDays" width="400" height="200"></canvas>
            <canvas id="chartHours" width="400" height="200"></canvas>
          </div>
          <div id="patternText" style="margin-top:10px"></div>
          <h4 style="margin-top:10px">–¢–æ–ø-3 –≥–µ—Ä–æ—ó</h4>
          <div id="topHeroes" class="hero-list"></div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // ---- –£—Ç–∏–ª—ñ—Ç–∏
    function steam64ToAccountId(steam64){ try{ const n=BigInt(steam64); const base=BigInt('76561197960265728'); if(n<=BigInt(4294967295)) return Number(n); return Number(n-base);}catch(e){return NaN} }
    function playerWon(m){ const playerRadiant = (m.player_slot||0) < 128; return (playerRadiant && m.radiant_win) || (!playerRadiant && !m.radiant_win); }
    function secsToMinSecs(s){ const m=Math.floor(s/60), sec=s%60; return m+':'+String(sec).padStart(2,'0'); }

    async function fetchOpenDotaMatches(id,limit){ const url=`https://api.opendota.com/api/players/${id}/matches?limit=${limit}`; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota matches fetch failed: '+res.status); return res.json(); }
    async function fetchHeroesConstants(){ const url='https://api.opendota.com/api/constants/heroes'; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota heroes fetch failed'); return res.json(); }

    // ---- –ê–Ω–∞–ª—ñ–∑
    function analyzeMatches(matches){
      const out={games:matches.length,wins:0,k:0,d:0,a:0,dur:0,shortWins:0,shortLosses:0,longWins:0,longLosses:0,leaves:0,byHero:{},seq:[]};
      for(const m of matches){ const won=playerWon(m); out.seq.push(won?'W':'L'); if(won) out.wins++; const kills=m.kills||0,deaths=m.deaths||0,assists=m.assists||0,duration=m.duration||0; out.k+=kills; out.d+=deaths; out.a+=assists; out.dur+=duration; if(duration<1500 && won) out.shortWins++; if(duration<1500 && !won) out.shortLosses++; if(duration>2700 && won) out.longWins++; if(duration>2700 && !won) out.longLosses++; if(m.leaver_status && m.leaver_status!==0) out.leaves++; const hid=m.hero_id||0; if(!out.byHero[hid]) out.byHero[hid]={games:0,wins:0}; out.byHero[hid].games++; if(won) out.byHero[hid].wins++; }
      out.winrate=out.games? out.wins/out.games*100:0; out.avgK=out.games? out.k/out.games:0; out.avgD=out.games? out.d/out.games:0; out.avgA=out.games? out.a/out.games:0; out.avgKDA=out.avgD? (out.avgK+out.avgA)/out.avgD: (out.avgK+out.avgA); out.avgDuration=out.games? out.dur/out.games:0; out.pctShortWins=out.games? out.shortWins/out.games*100:0; out.pctShortLosses=out.games? out.shortLosses/out.games*100:0; out.pctLongWins=out.games? out.longWins/out.games*100:0; out.pctLongLosses=out.games? out.longLosses/out.games*100:0; out.leaveRate=out.games? out.leaves/out.games*100:0; return out; }

    // ---- –ü—Ä–æ–≥–Ω–æ–∑ (—è–∫ —Ä–∞–Ω—ñ—à–µ, —Ç—Ä–æ—Ö–∏ –≤–¥–æ—Å–∫–æ–Ω–∞–ª–µ–Ω–æ)
  function computeDetailedProbabilities(summary, weights = defaultWeights) {
  const reasons = [];

  // 1. –ë–∞–∑–æ–≤–∞ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–º–æ–≥–∏
  let winProb = baseWinProb(summary, weights, reasons);

  // 2. –ü—Ä–æ–≥–Ω–æ–∑ –¥–æ–≤–∂–∏–Ω–∏ –≥—Ä–∏
  const predictedLength = predictGameLength(summary);

  // 3. Boosters / Ruiners –µ–≤—Ä–∏—Å—Ç–∏–∫–∏
  const { boosterMy, ruinerMy, boosterEnemy, ruinerEnemy, brReasons } = estimateBoostersRuiners(summary);
  reasons.push(...brReasons);

  // 4. –ö—ñ–Ω—Ü–µ–≤–µ –æ–±–º–µ–∂–µ–Ω–Ω—è
  winProb = Math.max(3, Math.min(97, Math.round(winProb)));

  return { winProb, predictedLength, boosterMy, ruinerMy, boosterEnemy, ruinerEnemy, reasons };
}

// -------------------- HELPERS --------------------

const defaultWeights = {
  winrate: 0.9,
  kda: 6,
  shortGamePenalty: -3,
  shortLossPenalty: -4,
  leaveRatePenalty: v => -Math.min(10, Math.round(v))
};

function baseWinProb(summary, w, reasons) {
  let winProb = 50;

  const deltaWinrate = (summary.winrate - 50) * w.winrate;
  winProb += deltaWinrate;
  reasons.push({ factor: "Winrate", value: summary.winrate, delta: deltaWinrate });

  const deltaKDA = (summary.avgKDA - 2) * w.kda;
  winProb += deltaKDA;
  reasons.push({ factor: "KDA", value: summary.avgKDA, delta: deltaKDA });

  if (summary.avgDuration < 1200) {
    winProb += w.shortGamePenalty;
    reasons.push({ factor: "Short games", value: summary.avgDuration, delta: w.shortGamePenalty });
  }

  if (summary.pctShortLosses > 20) {
    winProb += w.shortLossPenalty;
    reasons.push({ factor: "Short losses", value: summary.pctShortLosses, delta: w.shortLossPenalty });
  }

  if (summary.leaveRate > 5) {
    const v = w.leaveRatePenalty(summary.leaveRate);
    winProb += v;
    reasons.push({ factor: "Leave rate", value: summary.leaveRate, delta: v });
  }

  return winProb;
}

function predictGameLength(summary) {
  return Math.round(
    summary.avgDuration *
    (0.95 + Math.max(-0.1, Math.min(0.1, (summary.pctShortWins - summary.pctShortLosses) / 100)))
  );
}

function estimateBoostersRuiners(summary) {
  function clamp(v) { return Math.max(1, Math.min(95, Math.round(v))); }

  let boosterMy = 5, ruinerMy = 5, boosterEnemy = 5, ruinerEnemy = 5;
  const reasons = [];

  if (summary.avgKDA > 3.5) {
    const add = Math.round((summary.avgKDA - 3.5) * 8);
    boosterMy += add;
    reasons.push({ factor: "High KDA", value: summary.avgKDA, delta: add, target: "boosterMy" });
  }

  if (summary.pctShortWins > 20) {
    const add = Math.round((summary.pctShortWins - 20) / 2);
    boosterMy += add;
    reasons.push({ factor: "Short wins", value: summary.pctShortWins, delta: add, target: "boosterMy" });
  }

  if (summary.winrate > 60) {
    const add = Math.round((summary.winrate - 60) / 1.5);
    boosterMy += add;
    reasons.push({ factor: "High winrate", value: summary.winrate, delta: add, target: "boosterMy" });
  }

  if (summary.avgD > 7) {
    const add = Math.round((summary.avgD - 7) * 4);
    ruinerMy += add;
    reasons.push({ factor: "High deaths", value: summary.avgD, delta: add, target: "ruinerMy" });
  }

  if (summary.pctShortLosses > 15) {
    const add = Math.round((summary.pctShortLosses - 15) / 1.5);
    ruinerMy += add;
    reasons.push({ factor: "Short losses", value: summary.pctShortLosses, delta: add, target: "ruinerMy" });
  }

  if (summary.leaveRate > 3) {
    const add = Math.round(summary.leaveRate);
    ruinerMy += add;
    reasons.push({ factor: "Leave rate", value: summary.leaveRate, delta: add, target: "ruinerMy" });
  }

  if (summary.pctShortLosses > 20) {
    const add = Math.round((summary.pctShortLosses - 20) / 1.2);
    boosterEnemy += add;
    reasons.push({ factor: "Enemy boosted by your short losses", value: summary.pctShortLosses, delta: add, target: "boosterEnemy" });
  }

  if (summary.pctLongWins > 15) {
    const add = Math.round((summary.pctLongWins - 15) / 1.2);
    ruinerEnemy += add;
    reasons.push({ factor: "Enemy ruined by your long wins", value: summary.pctLongWins, delta: add, target: "ruinerEnemy" });
  }

  if (summary.pctLongLosses > 12) {
    const add = Math.round((summary.pctLongLosses - 12) / 1.1);
    ruinerEnemy += add;
    reasons.push({ factor: "Enemy ruined by your long losses", value: summary.pctLongLosses, delta: add, target: "ruinerEnemy" });
  }

  if (summary.leaveRate > 6) {
    boosterEnemy += 3; ruinerEnemy += 3;
    reasons.push({ factor: "High leave rate (both sides)", value: summary.leaveRate, delta: "+3 each", target: "both" });
  }

  return {
    boosterMy: clamp(boosterMy),
    ruinerMy: clamp(ruinerMy),
    boosterEnemy: clamp(boosterEnemy),
    ruinerEnemy: clamp(ruinerEnemy),
    brReasons: reasons
  };
}
    // ---- –ü–∞—Ç–µ—Ä–Ω–∏: –¥–Ω—ñ/–≥–æ–¥–∏–Ω–∏/–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ
   // ---- –ö–æ–Ω—Ñ—ñ–≥ –¥–ª—è –ø–æ—Ä–æ–≥—ñ–≤ ----
const PATTERN_CONFIG = {
  shortGameMax: 1500,   // <25 —Ö–≤
  longGameMin: 2700,    // >45 —Ö–≤
  maxSeq: 5,            // –º–∞–∫—Å –¥–æ–≤–∂–∏–Ω–∞ —Å–µ—Ä—ñ—ó –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
  minHeroGames: 2       // –º—ñ–Ω—ñ–º—É–º —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—ó –¥–ª—è —Ç–æ–ø—É
};

// ---- –•–µ–ª–ø–µ—Ä –¥–ª—è winrate ----
const winrate = (wins, games) => games ? wins / games * 100 : 0;

    // ---- –ê–Ω–∞–ª—ñ–∑ –Ω–∞–π–∫—Ä–∞—â–∏—Ö –≥–µ—Ä–æ—ó–≤ ----
function analyzeTopHeroes(summary, heroesConst, minGames = 3) {
  const heroStats = [];

  for (const id in summary.heroes) {
    const data = summary.heroes[id];
    if (data.games >= minGames) {
      const hero = heroesConst.find(h => h.id == id);
      heroStats.push({
        id,
        name: hero ? hero.localized_name : `Hero ${id}`,
        games: data.games,
        wins: data.wins,
        winrate: winrate(data.wins, data.games)
      });
    }
  }

  // —Å–æ—Ä—Ç—É—î–º–æ –∑–∞ winrate
  heroStats.sort((a, b) => b.winrate - a.winrate);

  return heroStats.slice(0, 3); // —Ç–æ–ø-3
}


// ---- –ì–û–õ–û–í–ù–ê –§–£–ù–ö–¶–Ü–Ø ----
function analyzePatterns(matches, summary, heroesConst, cfg = PATTERN_CONFIG) {
  const { days, hours } = analyzeDayHourRates(matches);
  const seqPatterns = analyzeSequences(summary.seq, cfg.maxSeq);
  const { shortWinrate, longWinrate } = analyzeDurations(matches, cfg.shortGameMax, cfg.longGameMin);
  const top3 = analyzeTopHeroes(summary, heroesConst, cfg.minHeroGames);
  const phases = analyzePhases(matches);
    const bestPhase = phases
    .filter(p => p.games >= 5)
    .sort((a, b) => (b.score || 0) - (a.score || 0))[0] || null;


  return {
    dayRates: days,
    hourRates: hours,
    seqPatterns,
    shortWinrate,
    longWinrate,
    phases,
    bestPhase,
    top3,
    meta: {
      totalMatches: matches.length,
      analyzedHeroes: Object.keys(summary.byHero).length
    }
  };
}

// ---- 1. –ê–Ω–∞–ª—ñ–∑ –ø–æ –¥–Ω—è—Ö —ñ –≥–æ–¥–∏–Ω–∞—Ö ----
function analyzeDayHourRates(matches) {
  const days = Array(7).fill(0).map(() => ({ games: 0, wins: 0 }));
  const hours = Array(24).fill(0).map(() => ({ games: 0, wins: 0 }));

  for (const m of matches) {
    const d = new Date((m.start_time || 0) * 1000);
    const dow = d.getDay();
    const h = d.getHours();
    const won = playerWon(m);

    days[dow].games++; if (won) days[dow].wins++;
    hours[h].games++; if (won) hours[h].wins++;
  }

  return {
    days: days.map((x, i) => ({
      day: i,
      winrate: winrate(x.wins, x.games),
      games: x.games
    })),
    hours: hours.map((x, h) => ({
      hour: h,
      winrate: winrate(x.wins, x.games),
      games: x.games
    }))
  };
}

// ---- 2. –ê–Ω–∞–ª—ñ–∑ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π ----
function analyzeSequences(seq, maxN) {
  const patterns = [];
  for (let n = 1; n <= maxN; n++) {
    let total = 0, afterWin = 0;
    for (let i = 0; i + n < seq.length; i++) {
      if (seq.slice(i, i + n).every(ch => ch === 'L')) {
        total++;
        if (seq[i + n] === 'W') afterWin++;
      }
    }
    if (total > 0) {
      patterns.push({
        n,
        total,
        afterWin,
        prob: Math.round(afterWin / total * 100)
      });
    }
  }
  return patterns;
}

// ---- 3. –ê–Ω–∞–ª—ñ–∑ –∫–æ—Ä–æ—Ç–∫–∏—Ö/–¥–æ–≤–≥–∏—Ö —ñ–≥–æ—Ä ----
function analyzeDurations(matches, shortMax, longMin) {
  const shortGames = matches.filter(m => (m.duration || 0) < shortMax);
  const longGames = matches.filter(m => (m.duration || 0) > longMin);

  return {
    shortWinrate: winrate(shortGames.filter(playerWon).length, shortGames.length),
    longWinrate: winrate(longGames.filter(playerWon).length, longGames.length)
  };
}
    function analyzePhases(matches) {
  const phases = [
    { name: '–§–∞–∑–∞ 1 (<27 —Ö–≤)', min: 0, max: 1620, games: 0, wins: 0, recentScore: 0 },
    { name: '–§–∞–∑–∞ 2 (27‚Äì37 —Ö–≤)', min: 1620, max: 2220, games: 0, wins: 0, recentScore: 0 },
    { name: '–§–∞–∑–∞ 3 (37‚Äì47 —Ö–≤)', min: 2220, max: 2820, games: 0, wins: 0, recentScore: 0 },
    { name: '–§–∞–∑–∞ 4 (47‚Äì60 —Ö–≤)', min: 2820, max: 3600, games: 0, wins: 0, recentScore: 0 },
    { name: '–§–∞–∑–∞ 5 (60+ —Ö–≤)', min: 3600, max: Infinity, games: 0, wins: 0, recentScore: 0 }
  ];

  // 1Ô∏è‚É£ –†–∞—Ö—É—î–º–æ –æ—Å–Ω–æ–≤–Ω—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  for (const m of matches) {
    const dur = m.duration || 0;
    const won = playerWon(m);
    const phase = phases.find(p => dur >= p.min && dur < p.max);
    if (phase) {
      phase.games++;
      if (won) phase.wins++;
    }
  }

  // 2Ô∏è‚É£ –î–æ–¥–∞—î–º–æ –¥–∏–Ω–∞–º—ñ–∫—É (–æ—Å—Ç–∞–Ω–Ω—ñ 20 —ñ–≥–æ—Ä –∑ –≤–∞–≥–∞–º–∏)
  const recentMatches = matches.slice(0, 20).reverse(); // –Ω–∞–π–Ω–æ–≤—ñ—à—ñ –∑–Ω–∏–∑—É
  recentMatches.forEach((m, i) => {
    const dur = m.duration || 0;
    const won = playerWon(m);
    const weight = (i + 1) / 20; // 0.05...1.0
    const phase = phases.find(p => dur >= p.min && dur < p.max);
    if (phase) phase.recentScore += (won ? 1 : -1) * weight;
  });

  // 3Ô∏è‚É£ –û–±—á–∏—Å–ª—é—î–º–æ –∑–≤–∞–∂–µ–Ω–∏–π —ñ–Ω–¥–µ–∫—Å
  phases.forEach(p => {
    p.winrate = winrate(p.wins, p.games);
    const trend = (p.recentScore / 10) * 100; // –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ –≤ %
    p.score = (p.winrate * 0.6) + (trend * 0.4); // –∫–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∏–π —ñ–Ω–¥–µ–∫—Å
  });

  return phases;
}


    // ---- –†–µ–Ω–¥–µ—Ä UI
    function renderMatches(matches, heroesConst){ const tbody=document.querySelector('#matchesTable tbody'); tbody.innerHTML=''; matches.forEach(m=>{ const tr=document.createElement('tr'); const d=new Date((m.start_time||0)*1000); const hid=m.hero_id||0; const heroName = heroesConst && heroesConst[hid] ? heroesConst[hid].localized_name : hid; tr.innerHTML=`<td>${d.toLocaleString()}</td><td>${heroName}</td><td>${m.kills||0}/${m.deaths||0}/${m.assists||0}</td><td>${playerWon(m)?'W':'L'}</td><td>${secsToMinSecs(m.duration||0)}</td>`; tbody.appendChild(tr); }); }

    function renderPredictionUI(summary, result){ document.getElementById('statsSummary').innerText = `–Ü–≥–æ—Ä: ${summary.games} ¬∑ Winrate: ${summary.winrate.toFixed(1)}% ¬∑ Avg K/D/A: ${summary.avgK.toFixed(2)}/${summary.avgD.toFixed(2)}/${summary.avgA.toFixed(2)} ¬∑ Avg KDA: ${summary.avgKDA.toFixed(2)} ¬∑ Avg —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${Math.round(summary.avgDuration/60)} —Ö–≤`;
      const p=document.getElementById('predictionArea'); p.className='prediction '+(result.winProb>60?'pred-good':result.winProb<40?'pred-bad':'pred-neutral'); p.innerHTML=`<strong>–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–º–æ–≥–∏: ${result.winProb}%</strong><div class="small">–ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞: ${Math.round(result.predictedLength/60)} —Ö–≤</div>`;
      const det=document.getElementById('predictionDetails'); det.innerHTML=`<div class="reason"><strong>–®–∞–Ω—Å–∏</strong><div class="small">–ë—É—Å—Ç–µ—Ä (–º–æ—ó): ${result.boosterMy}% ¬∑ –†—É—ñ–Ω–µ—Ä (–º–æ—ó): ${result.ruinerMy}%<br>–ë—É—Å—Ç–µ—Ä (–≤–æ—Ä–æ–≥): ${result.boosterEnemy}% ¬∑ –†—É—ñ–Ω–µ—Ä (–≤–æ—Ä–æ–≥): ${result.ruinerEnemy}%</div></div>`;
      if (patterns.bestPhase) {
  const bp = patterns.bestPhase;
  resultMessage += `\n\nüïí –ù–∞–π–∫—Ä–∞—â–∞ —Ñ–∞–∑–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≥—Ä–∏: ${bp.name}.
  –£ –Ω—ñ–π –∫–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∏–π —ñ–Ω–¥–µ–∫—Å —É—Å–ø—ñ—à–Ω–æ—Å—Ç—ñ ‚Äî ${bp.score.toFixed(1)}.
  (Winrate: ${bp.winrate.toFixed(1)}%, –¥–∏–Ω–∞–º—ñ–∫–∞ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö —ñ–≥–æ—Ä: ${(bp.recentScore*5).toFixed(1)}%)`;
}
                                           
    }

    // ---- –ü–æ–±—É–¥–æ–≤–∞ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ —á–µ—Ä–µ–∑ Chart.js
    let chartDays=null, chartHours=null;
    function buildCharts(dayRates, hourRates){ const daysLabels=['–ù–¥','–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±']; const dayData = dayRates.map(d=>+d.winrate.toFixed(1)); const hourLabels = hourRates.map(h=>h.hour); const hourData = hourRates.map(h=>+h.winrate.toFixed(1));
      const ctxD = document.getElementById('chartDays').getContext('2d'); if(chartDays) chartDays.destroy(); chartDays = new Chart(ctxD,{type:'bar',data:{labels:daysLabels, datasets:[{label:'Winrate %', data:dayData}]}, options:{scales:{y:{beginAtZero:true, max:100}}}});
      const ctxH = document.getElementById('chartHours').getContext('2d'); if(chartHours) chartHours.destroy(); chartHours = new Chart(ctxH,{type:'line',data:{labels:hourLabels, datasets:[{label:'Winrate %', data:hourData, fill:true, tension:0.3}]}, options:{scales:{y:{beginAtZero:true, max:100}}}});
    }

    function renderPatternsUI(patterns){ document.getElementById('patterns').style.display='block'; const pt=document.getElementById('patternText'); pt.innerHTML='';
      // sequence patterns
      const seqRoot=document.createElement('div'); seqRoot.innerHTML='<strong>–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ W/L</strong>';
      patterns.seqPatterns.forEach(p=>{ const div=document.createElement('div'); div.className='reason'; div.textContent = `–ü—ñ—Å–ª—è ${p.n} –ø–æ—Ä–∞–∑–æ–∫ –ø–æ—Å–ø—ñ–ª—å (${p.total} –≤–∏–ø–∞–¥–∫—ñ–≤) –Ω–∞—Å—Ç—É–ø–Ω–∞ –≥—Ä–∞ –±—É–ª–∞ –ø–µ—Ä–µ–º–æ–≥–æ—é —É ${p.prob}% –≤–∏–ø–∞–¥–∫—ñ–≤.`; seqRoot.appendChild(div); });
      pt.appendChild(seqRoot);
      // short/long
     // phases
const phaseRoot = document.createElement('div');
phaseRoot.innerHTML = '<strong>–§–∞–∑–∏ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è —ñ–≥–æ—Ä</strong>';
const bestScore = Math.max(...patterns.phases.map(p => p.score || 0));

patterns.phases.forEach(p => {
  const div = document.createElement('div');
  div.className = 'reason';
  const trendPercent = (p.recentScore * 5).toFixed(1); // –¥–∏–Ω–∞–º—ñ–∫–∞ –≤ %
  div.innerHTML = `
    <span>${p.name}</span><br>
    <small>
      ${p.games} —ñ–≥–æ—Ä ¬∑ Winrate: ${p.winrate ? p.winrate.toFixed(1) : 0}% ¬∑ 
      –î–∏–Ω–∞–º—ñ–∫–∞: ${trendPercent}% ¬∑ 
      –Ü–Ω–¥–µ–∫—Å: ${p.score ? p.score.toFixed(1) : 0}
    </small>
  `;
  
  // üî• –ø—ñ–¥—Å–≤—ñ—á—É—î–º–æ –Ω–∞–π–∫—Ä–∞—â—É —Ñ–∞–∑—É
  if (p.score === bestScore) {
    div.style.background = 'rgba(0, 255, 0, 0.15)';
    div.style.border = '1px solid rgba(0, 255, 0, 0.4)';
    div.style.borderRadius = '6px';
  } else {
    div.style.opacity = 0.8;
  }

  phaseRoot.appendChild(div);
});
pt.appendChild(phaseRoot);
                                 
      // top heroes
      const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML=''; if(patterns.top3.length===0){ topRoot.innerHTML='<div class="small">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—è—Ö (min 2)</div>'; } else { patterns.top3.forEach(h=>{ const el=document.createElement('div'); el.className='hero-item'; const img=document.createElement('img'); img.src = h.img || ''; img.alt=h.name; const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% ¬∑ –Ü–≥–æ—Ä: ${h.games}</div>`; el.appendChild(img); el.appendChild(info); topRoot.appendChild(el); }); }
    }

    // ---- –ü–æ—à—É–∫ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç–µ–π –∑–∞ –¥–Ω—è–º–∏/–≥–æ–¥–∏–Ω–∞–º–∏ —Ç–∞ —Ä–µ–Ω–¥–µ—Ä
    async function showPatterns(matches, summary, heroesConst){ const analysis = analyzePatterns(matches, summary, heroesConst); buildCharts(analysis.dayRates, analysis.hourRates); renderPatternsUI(analysis); }

    // ---- –ü–æ–¥—ñ—ó –∫–Ω–æ–ø–æ–∫
    let lastMatches=null, lastSummary=null, lastHeroesConst=null;
    document.getElementById('demoBtn').addEventListener('click', ()=>{ document.getElementById('idInput').value='863386335'; });

    document.getElementById('fetchBtn').addEventListener('click', async ()=>{
      const raw=document.getElementById('idInput').value.trim(); if(!raw) return alert('–í–≤–µ–¥—ñ—Ç—å ID'); const id = raw.length>12? steam64ToAccountId(raw): Number(raw); if(isNaN(id)) return alert('–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ ID'); const limit = Number(document.getElementById('limitSelect').value);
      document.getElementById('predictionArea').textContent='–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...';
      try{
        const [matches, heroesConstRaw] = await Promise.all([ fetchOpenDotaMatches(id, limit), fetchHeroesConstants() ]);
        // normalize heroesConst into map by hero_id (OpenDota constants keys are names, values have 'id')
        const heroesConst = {};
        Object.values(heroesConstRaw).forEach(h=>{ if(h.id!==undefined) heroesConst[h.id]=h; });
        lastMatches = matches; lastSummary = analyzeMatches(matches); lastHeroesConst = heroesConst;
        const pred = computeDetailedProbabilities(lastSummary);
        renderMatches(matches, heroesConst);
        renderPredictionUI(lastSummary, pred);
        // hide patterns until user presses button
        document.getElementById('patterns').style.display='none';
      }catch(err){ console.error(err); document.getElementById('predictionArea').textContent='–ü–æ–º–∏–ª–∫–∞: '+err.message; }
    });

    document.getElementById('patternsBtn').addEventListener('click', async ()=>{
      if(!lastMatches || !lastSummary){ alert('–°–ø–æ—á–∞—Ç–∫—É –æ—Ç—Ä–∏–º–∞–π—Ç–µ –ø—Ä–æ–≥–Ω–æ–∑ (–Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑").'); return; }
      try{ await showPatterns(lastMatches, lastSummary, lastHeroesConst); }catch(err){ console.error(err); alert('–ü—Ä–æ–±–ª–µ–º–∞ –ø—Ä–∏ –ø–æ–±—É–¥–æ–≤—ñ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç–µ–π: '+err.message); }
    });

  </script>
</body>
</html>


