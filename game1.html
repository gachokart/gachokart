<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>game1 ‚Äî –ü—Ä–æ–≥–Ω–æ–∑ –∑ —Ä–æ–ª–ª—é (—Å—Ç–∏–ª—å–Ω–∏–π)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{
      --bg:#07111b; --card:#081323; --muted:#9aa7bd;
      --accent:#1f8feb; --good:#0db36b; --bad:#e25757; --neutral:#9aa4b2;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{margin:0;background:linear-gradient(180deg,#071027 0%,#07111b 100%);color:#e6eef6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
    .wrap{max-width:1200px;width:100%}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:12px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:20px;margin:0}
    .inputs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    input,button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:9px;border-radius:8px;color:inherit}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:1fr 460px;gap:12px;margin-top:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);text-align:left}
    .meta{font-size:13px;color:var(--muted)}
    .prediction{padding:12px;border-radius:12px;margin-bottom:10px;background:linear-gradient(90deg,#22303b,#16232b);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .reason{font-size:13px;margin:6px 0;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:var(--muted)}
    #patterns{display:none;margin-top:12px}
    .charts{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    .hero-list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .hero-item{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .hero-item img{width:48px;height:28px;object-fit:cover;border-radius:4px}

    /* NEW: Stylish role-probability card */
    .role-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.04)}
    .role-row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .role-select{display:flex;gap:8px;align-items:center}
    .prob-large{font-size:28px;font-weight:800}
    .prob-sub{font-size:12px;color:var(--muted)}
    .stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .stat{background:var(--glass);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .stat .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    .bar-wrap{height:10px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
    .bar-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#036b8a);border-radius:999px}
    .mini{font-size:12px;color:var(--muted);margin-top:6px}

    /* colored variants */
    .good { --accent: var(--good); }
    .bad { --accent: var(--bad); }
    .neutral { --accent: linear-gradient(90deg,#6b7a89,#525e6a); }

    @media (max-width:980px){.grid{grid-template-columns:1fr} .charts{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="flex:1;display:flex;align-items:center;justify-content:space-between;padding:12px">
        <div>
          <h1>game1 ‚Äî –ü—Ä–æ–≥–Ω–æ–∑ + –ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ (—Ä–æ–ª—å & –≤—ñ–∑—É–∞–ª)</h1>
          <div class="small">OpenDota –∞–Ω–∞–ª—ñ–∑ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö —ñ–≥–æ—Ä ‚Üí –ø—Ä–æ–≥–Ω–æ–∑, –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ, —Ç–æ–ø-3 –≥–µ—Ä–æ—ó–≤. –î–æ–¥–∞—î —Ä–æ–ª—å —ñ —Å—Ç–∏–ª—å–Ω—É –∫–∞—Ä—Ç—É –ø—Ä–æ–≥–Ω–æ–∑—É.</div>
        </div>
        <div class="small">–¢–µ—Å—Ç–æ–≤–∏–π ID: <strong>863386335</strong></div>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;flex-direction:column">
        <label>Steam64 ID –∞–±–æ OpenDota account_id:</label>
        <div class="inputs">
          <input id="idInput" placeholder="Steam64 –∞–±–æ account_id" />
          <select id="limitSelect">
            <option value="20">–û—Å—Ç–∞–Ω–Ω—ñ 20 —ñ–≥–æ—Ä</option>
            <option value="50">–û—Å—Ç–∞–Ω–Ω—ñ 50 —ñ–≥–æ—Ä</option>
            <option value="100">–û—Å—Ç–∞–Ω–Ω—ñ 100 —ñ–≥–æ—Ä</option>
          </select>
          <button id="fetchBtn">–û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑</button>
          <button id="patternsBtn">–ü–æ–∫–∞–∑–∞—Ç–∏ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ</button>
          <button id="demoBtn">–¢–µ—Å—Ç–æ–≤–∏–π ID</button>
        </div>
        <div class="small" style="margin-top:8px">–ü—ñ—Å–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–æ–≥–Ω–æ–∑—É ‚Äî –∑'—è–≤–∏—Ç—å—Å—è —Å—Ç–∏–ª—ñ–∑–æ–≤–∞–Ω–∞ –∫–∞—Ä—Ç–∫–∞ –¥–ª—è –≤–∏–±–æ—Ä—É —Ä–æ–ª—ñ –π –ø–æ–∫–∞–∑—É —à–∞–Ω—Å—ñ–≤.</div>
      </div>
    </div>
<!-- üîπ –≤—Å—Ç–∞–≤ —Ü–µ–π –±–ª–æ–∫ –ø–µ—Ä–µ–¥ </body> -->
<section id="charts" style="margin-top:20px; text-align:center;">
  <h2>üìä –ì—Ä–∞—Ñ—ñ–∫–∏ –¥–∏–Ω–∞–º—ñ–∫–∏</h2>

  <div style="max-width:800px; margin:auto;">
    <h3>Winrate –ø–æ —Ä–æ–ª—è—Ö</h3>
    <canvas id="chartRoles" height="200"></canvas>
  </div>

  <div style="max-width:800px; margin:auto;">
    <h3>Winrate –ø–æ –¥–Ω—è—Ö</h3>
    <canvas id="chartDays" height="200"></canvas>
  </div>

  <div style="max-width:800px; margin:auto;">
    <h3>Winrate –ø–æ –≥–æ–¥–∏–Ω–∞—Ö</h3>
    <canvas id="chartHours" height="200"></canvas>
  </div>
</section>

    <div class="grid">
      <div class="card" id="leftCard">
        <h3>–û—Å—Ç–∞–Ω–Ω—ñ –º–∞—Ç—á—ñ</h3>
        <div id="statsSummary" class="meta"></div>
        <div style="margin-top:8px;max-height:420px;overflow:auto">
          <table id="matchesTable">
            <thead><tr><th>–î–∞—Ç–∞</th><th>–ì–µ—Ä–æ–π</th><th>K/D/A</th><th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th><th>–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <aside class="card" id="rightCard">
        <h3>–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –º–∞—Ç—á</h3>

        <!-- Stylish prediction card -->
        <div id="rolePredictionCard" class="role-card" style="display:none">
          <div class="role-row">
            <div class="role-select">
              <div style="font-size:13px;color:var(--muted);">–û–±–µ—Ä—ñ—Ç—å —Ä–æ–ª—å:</div>
              <select id="roleSelect" style="padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit">
                <option value="1">1 ‚Äî Carry</option>
                <option value="2">2 ‚Äî Mid</option>
                <option value="3" selected>3 ‚Äî Offlane</option>
                <option value="4">4 ‚Äî Soft support</option>
                <option value="5">5 ‚Äî Hard support</option>
              </select>
            </div>
            <div style="text-align:right">
              <div class="prob-large" id="winPercent">‚Äî%</div>
              <div class="prob-sub">–®–∞–Ω—Å –ø–µ—Ä–µ–º–æ–≥–∏</div>
            </div>
          </div>

          <div class="stat-grid" style="margin-top:12px">
            <div class="stat" id="stat_boosterMy">
              <div class="label">–ë—É—Å—Ç–µ—Ä (—É –≤–∞—à—ñ–π –∫–æ–º–∞–Ω–¥—ñ)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_boosterMy"></div></div>
              <div class="mini" id="text_boosterMy">‚Äî%</div>
            </div>

            <div class="stat" id="stat_ruinerMy">
              <div class="label">–†—É—ñ–Ω–µ—Ä (—É –≤–∞—à—ñ–π –∫–æ–º–∞–Ω–¥—ñ)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_ruinerMy"></div></div>
              <div class="mini" id="text_ruinerMy">‚Äî%</div>
            </div>

            <div class="stat" id="stat_boosterEnemy">
              <div class="label">–ë—É—Å—Ç–µ—Ä (–≤–æ—Ä–æ–∂—ñ)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_boosterEnemy"></div></div>
              <div class="mini" id="text_boosterEnemy">‚Äî%</div>
            </div>

            <div class="stat" id="stat_ruinerEnemy">
              <div class="label">–†—É—ñ–Ω–µ—Ä (–≤–æ—Ä–æ–∂—ñ)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_ruinerEnemy"></div></div>
              <div class="mini" id="text_ruinerEnemy">‚Äî%</div>
            </div>
          </div>

          <div style="margin-top:12px;display:flex;gap:10px">
            <div class="stat" style="flex:1">
              <div class="label">–®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É –≤—ñ–Ω—Å—Ç—Ä—ñ–∫–∞ (3+)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_winstreak"></div></div>
              <div class="mini" id="text_winstreak">‚Äî%</div>
            </div>
            <div class="stat" style="flex:1">
              <div class="label">–®–∞–Ω—Å –ø–æ—á–∞—Ç–∫—É –ª—É–∑—Å—Ç—Ä—ñ–∫–∞ (3+)</div>
              <div class="bar-wrap"><div class="bar-fill" id="bar_losestreak"></div></div>
              <div class="mini" id="text_losestreak">‚Äî%</div>
            </div>
          </div>

          <div style="margin-top:10px" id="roleNotes" class="small"></div>
        </div>

        <div id="predictionArea" class="prediction pred-neutral">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</div>
        <div id="predictionDetails" class="meta"></div>

        <div id="patterns" class="meta card">
          <h4>–ó–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç—ñ –º–∞—Ç—á—ñ–≤</h4>
          <div class="charts">
            <canvas id="chartDays" width="400" height="200"></canvas>
            <canvas id="chartHours" width="400" height="200"></canvas>
          </div>
          <div id="patternText" style="margin-top:10px"></div>
          <h4 style="margin-top:10px">–¢–æ–ø-3 –≥–µ—Ä–æ—ó</h4>
          <div id="topHeroes" class="hero-list"></div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // ---- –£—Ç–∏–ª—ñ—Ç–∏ (–∑–∞–ª–∏—à–∏–≤ –±–µ–∑ –∑–º—ñ–Ω)
    function steam64ToAccountId(steam64){ try{ const n=BigInt(steam64); const base=BigInt('76561197960265728'); if(n<=BigInt(4294967295)) return Number(n); return Number(n-base);}catch(e){return NaN} }
    function playerWon(m){ const playerRadiant = (m.player_slot||0) < 128; return (playerRadiant && m.radiant_win) || (!playerRadiant && !m.radiant_win); }
    function secsToMinSecs(s){ const m=Math.floor(s/60), sec=s%60; return m+':'+String(sec).padStart(2,'0'); }

    async function fetchOpenDotaMatches(id,limit){ const url=`https://api.opendota.com/api/players/${id}/matches?limit=${limit}`; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota matches fetch failed: '+res.status); return res.json(); }
    async function fetchHeroesConstants(){ const url='https://api.opendota.com/api/constants/heroes'; const res=await fetch(url); if(!res.ok) throw new Error('OpenDota heroes fetch failed'); return res.json(); }

    // ---- –ê–Ω–∞–ª—ñ–∑ (–∑–∞–ª–∏—à–∏–≤ —Ç–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó, –¥—Ä—ñ–±–Ω—ñ –¥–æ–ø–æ–≤–Ω–µ–Ω–Ω—è)
    function analyzeMatches(matches){
      const out={games:matches.length,wins:0,k:0,d:0,a:0,dur:0,shortWins:0,shortLosses:0,longWins:0,longLosses:0,leaves:0,byHero:{},seq:[]};
      for(const m of matches){ const won=playerWon(m); out.seq.push(won?'W':'L'); if(won) out.wins++; const kills=m.kills||0,deaths=m.deaths||0,assists=m.assists||0,duration=m.duration||0; out.k+=kills; out.d+=deaths; out.a+=assists; out.dur+=duration; if(duration<1500 && won) out.shortWins++; if(duration<1500 && !won) out.shortLosses++; if(duration>2700 && won) out.longWins++; if(duration>2700 && !won) out.longLosses++; if(m.leaver_status && m.leaver_status!==0) out.leaves++; const hid=m.hero_id||0; if(!out.byHero[hid]) out.byHero[hid]={games:0,wins:0}; out.byHero[hid].games++; if(won) out.byHero[hid].wins++; }
      out.winrate=out.games? out.wins/out.games*100:0; out.avgK=out.games? out.k/out.games:0; out.avgD=out.games? out.d/out.games:0; out.avgA=out.games? out.a/out.games:0; out.avgKDA=out.avgD? (out.avgK+out.avgA)/out.avgD: (out.avgK+out.avgA); out.avgDuration=out.games? out.dur/out.games:0; out.pctShortWins=out.games? out.shortWins/out.games*100:0; out.pctShortLosses=out.games? out.shortLosses/out.games*100:0; out.pctLongWins=out.games? out.longWins/out.games*100:0; out.pctLongLosses=out.games? out.longLosses/out.games*100:0; out.leaveRate=out.games? out.leaves/out.games*100:0; return out; }

    // ---- –ü—Ä–æ–≥–Ω–æ–∑ (—Ç–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó, –∑ –Ω–µ–≤–µ–ª–∏–∫–∏–º —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è–º ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ç–∞–∫–æ–∂ reasons)
  function computeDetailedProbabilities(summary, role = 3, weights = defaultWeights) {
  const reasons = [];

  // 1. –ë–∞–∑–æ–≤–∞ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–º–æ–≥–∏
  let winProb = baseWinProb(summary, weights, reasons);

  // Role-based modifier (–Ω–µ–≤–µ–ª–∏–∫–∏–π, –µ—Å—Ç–∏–º–æ–≤–∞–Ω–∏–π)
  // role 1 (carry) tends to have slightly higher control -> +3
  // role 2 (mid) -> +2, role 3 -> 0, role 4 -> -1, role 5 -> -2
  const roleDeltas = {1: 3, 2: 2, 3: 0, 4: -1, 5: -2};
  const roleDelta = roleDeltas[role] || 0;
  winProb += roleDelta;
  reasons.push({ factor: "Role adjustment", value: role, delta: roleDelta });

  // 2. –ü—Ä–æ–≥–Ω–æ–∑ –¥–æ–≤–∂–∏–Ω–∏ –≥—Ä–∏
  const predictedLength = predictGameLength(summary);

  // 3. Boosters / Ruiners –µ–≤—Ä–∏—Å—Ç–∏–∫–∏
  const { boosterMy, ruinerMy, boosterEnemy, ruinerEnemy, brReasons } = estimateBoostersRuiners(summary);
  reasons.push(...brReasons);

  // 4. –ö—ñ–Ω—Ü–µ–≤–µ –æ–±–º–µ–∂–µ–Ω–Ω—è
  winProb = Math.max(3, Math.min(97, Math.round(winProb)));

  // convert boosters/ruiners (1-95) into percentages (scaled)
  const toPct = v => Math.max(1, Math.min(95, Math.round(v)));
  return { winProb, predictedLength, boosterMy: toPct(boosterMy), ruinerMy: toPct(ruinerMy), boosterEnemy: toPct(boosterEnemy), ruinerEnemy: toPct(ruinerEnemy), reasons };
}

const defaultWeights = {
  winrate: 0.9,
  kda: 6,
  shortGamePenalty: -3,
  shortLossPenalty: -4,
  leaveRatePenalty: v => -Math.min(10, Math.round(v))
};

function baseWinProb(summary, w, reasons) {
  let winProb = 50;

  const deltaWinrate = (summary.winrate - 50) * w.winrate;
  winProb += deltaWinrate;
  reasons.push({ factor: "Winrate", value: summary.winrate, delta: deltaWinrate });

  const deltaKDA = (summary.avgKDA - 2) * w.kda;
  winProb += deltaKDA;
  reasons.push({ factor: "KDA", value: summary.avgKDA, delta: deltaKDA });

  if (summary.avgDuration < 1200) {
    winProb += w.shortGamePenalty;
    reasons.push({ factor: "Short games", value: summary.avgDuration, delta: w.shortGamePenalty });
  }

  if (summary.pctShortLosses > 20) {
    winProb += w.shortLossPenalty;
    reasons.push({ factor: "Short losses", value: summary.pctShortLosses, delta: w.shortLossPenalty });
  }

  if (summary.leaveRate > 5) {
    const v = w.leaveRatePenalty(summary.leaveRate);
    winProb += v;
    reasons.push({ factor: "Leave rate", value: summary.leaveRate, delta: v });
  }

  return winProb;
}

function predictGameLength(summary) {
  return Math.round(
    summary.avgDuration *
    (0.95 + Math.max(-0.1, Math.min(0.1, (summary.pctShortWins - summary.pctShortLosses) / 100)))
  );
}

function estimateBoostersRuiners(summary) {
  function clamp(v) { return Math.max(1, Math.min(95, Math.round(v))); }

  let boosterMy = 5, ruinerMy = 5, boosterEnemy = 5, ruinerEnemy = 5;
  const reasons = [];

  if (summary.avgKDA > 3.5) {
    const add = Math.round((summary.avgKDA - 3.5) * 8);
    boosterMy += add;
    reasons.push({ factor: "High KDA", value: summary.avgKDA, delta: add, target: "boosterMy" });
  }

  if (summary.pctShortWins > 20) {
    const add = Math.round((summary.pctShortWins - 20) / 2);
    boosterMy += add;
    reasons.push({ factor: "Short wins", value: summary.pctShortWins, delta: add, target: "boosterMy" });
  }

  if (summary.winrate > 60) {
    const add = Math.round((summary.winrate - 60) / 1.5);
    boosterMy += add;
    reasons.push({ factor: "High winrate", value: summary.winrate, delta: add, target: "boosterMy" });
  }

  if (summary.avgD > 7) {
    const add = Math.round((summary.avgD - 7) * 4);
    ruinerMy += add;
    reasons.push({ factor: "High deaths", value: summary.avgD, delta: add, target: "ruinerMy" });
  }

  if (summary.pctShortLosses > 15) {
    const add = Math.round((summary.pctShortLosses - 15) / 1.5);
    ruinerMy += add;
    reasons.push({ factor: "Short losses", value: summary.pctShortLosses, delta: add, target: "ruinerMy" });
  }

  if (summary.leaveRate > 3) {
    const add = Math.round(summary.leaveRate);
    ruinerMy += add;
    reasons.push({ factor: "Leave rate", value: summary.leaveRate, delta: add, target: "ruinerMy" });
  }

  if (summary.pctShortLosses > 20) {
    const add = Math.round((summary.pctShortLosses - 20) / 1.2);
    boosterEnemy += add;
    reasons.push({ factor: "Enemy boosted by your short losses", value: summary.pctShortLosses, delta: add, target: "boosterEnemy" });
  }

  if (summary.pctLongWins > 15) {
    const add = Math.round((summary.pctLongWins - 15) / 1.2);
    ruinerEnemy += add;
    reasons.push({ factor: "Enemy ruined by your long wins", value: summary.pctLongWins, delta: add, target: "ruinerEnemy" });
  }

  if (summary.pctLongLosses > 12) {
    const add = Math.round((summary.pctLongLosses - 12) / 1.1);
    ruinerEnemy += add;
    reasons.push({ factor: "Enemy ruined by your long losses", value: summary.pctLongLosses, delta: add, target: "ruinerEnemy" });
  }

  if (summary.leaveRate > 6) {
    boosterEnemy += 3; ruinerEnemy += 3;
    reasons.push({ factor: "High leave rate (both sides)", value: summary.leaveRate, delta: "+3 each", target: "both" });
  }

  return {
    boosterMy: clamp(boosterMy),
    ruinerMy: clamp(ruinerMy),
    boosterEnemy: clamp(boosterEnemy),
    ruinerEnemy: clamp(ruinerEnemy),
    brReasons: reasons
  };
}

    // ---- –ü–∞—Ç–µ—Ä–Ω–∏: –¥–Ω—ñ/–≥–æ–¥–∏–Ω–∏/–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ (–∑–∞–ª–∏—à–∏–≤)
const PATTERN_CONFIG = {
  shortGameMax: 1500,   // <25 —Ö–≤
  longGameMin: 2700,    // >45 —Ö–≤
  maxSeq: 5,            // –º–∞–∫—Å –¥–æ–≤–∂–∏–Ω–∞ —Å–µ—Ä—ñ—ó –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
  minHeroGames: 2       // –º—ñ–Ω—ñ–º—É–º —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—è –¥–ª—è —Ç–æ–ø—É
};

const winrate = (wins, games) => games ? wins / games * 100 : 0;

function analyzePatterns(matches, summary, heroesConst, cfg = PATTERN_CONFIG) {
  const { days, hours } = analyzeDayHourRates(matches);
  const seqPatterns = analyzeSequences(summary.seq, cfg.maxSeq);
  const { shortWinrate, longWinrate } = analyzeDurations(matches, cfg.shortGameMax, cfg.longGameMin);
  const top3 = analyzeTopHeroes(summary, heroesConst, cfg.minHeroGames);
  const phases = analyzePhases(matches);

  return {
    dayRates: days,
    hourRates: hours,
    seqPatterns,
    shortWinrate,
    longWinrate,
    phases,
    top3,
    meta: {
      totalMatches: matches.length,
      analyzedHeroes: Object.keys(summary.byHero).length
    }
  };
}

function analyzeDayHourRates(matches) {
  const days = Array(7).fill(0).map(() => ({ games: 0, wins: 0 }));
  const hours = Array(24).fill(0).map(() => ({ games: 0, wins: 0 }));

  for (const m of matches) {
    const d = new Date((m.start_time || 0) * 1000);
    const dow = d.getDay();
    const h = d.getHours();
    const won = playerWon(m);

    days[dow].games++; if (won) days[dow].wins++;
    hours[h].games++; if (won) hours[h].wins++;
  }

  return {
    days: days.map((x, i) => ({
      day: i,
      winrate: winrate(x.wins, x.games),
      games: x.games
    })),
    hours: hours.map((x, h) => ({
      hour: h,
      winrate: winrate(x.wins, x.games),
      games: x.games
    }))
  };
}

function analyzeSequences(seq, maxN) {
  const patterns = [];
  for (let n = 1; n <= maxN; n++) {
    let total = 0, afterWin = 0;
    for (let i = 0; i + n < seq.length; i++) {
      if (seq.slice(i, i + n).every(ch => ch === 'L')) {
        total++;
        if (seq[i + n] === 'W') afterWin++;
      }
    }
    if (total > 0) {
      patterns.push({
        n,
        total,
        afterWin,
        prob: Math.round(afterWin / total * 100)
      });
    }
  }
  return patterns;
}

function analyzeDurations(matches, shortMax, longMin) {
  const shortGames = matches.filter(m => (m.duration || 0) < shortMax);
  const longGames = matches.filter(m => (m.duration || 0) > longMin);

  return {
    shortWinrate: winrate(shortGames.filter(playerWon).length, shortGames.length),
    longWinrate: winrate(longGames.filter(playerWon).length, longGames.length)
  };
}

function analyzePhases(matches) {
  const phases = [
    { name: '–§–∞–∑–∞ 1 (<27 —Ö–≤)', min: 0, max: 1620, games: 0, wins: 0 },
    { name: '–§–∞–∑–∞ 2 (27‚Äì37 —Ö–≤)', min: 1620, max: 2220, games: 0, wins: 0 },
    { name: '–§–∞–∑–∞ 3 (37‚Äì47 —Ö–≤)', min: 2220, max: 2820, games: 0, wins: 0 },
    { name: '–§–∞–∑–∞ 4 (47‚Äì60 —Ö–≤)', min: 2820, max: 3600, games: 0, wins: 0 },
    { name: '–§–∞–∑–∞ 5 (60+ —Ö–≤)', min: 3600, max: Infinity, games: 0, wins: 0 }
  ];

  for (const m of matches) {
    const dur = m.duration || 0;
    const won = playerWon(m);
    const phase = phases.find(p => dur >= p.min && dur < p.max);
    if (phase) {
      phase.games++;
      if (won) phase.wins++;
    }
  }

  phases.forEach(p => p.winrate = winrate(p.wins, p.games));
  return phases;
}

function analyzeTopHeroes(summary, heroesConst, minGames) {
  const heroes = Object.entries(summary.byHero).map(([hid, st]) => ({
    hero_id: Number(hid),
    games: st.games,
    wins: st.wins,
    winrate: winrate(st.wins, st.games)
  }));

  heroes.sort((a, b) =>
    (b.winrate - a.winrate) || (b.games - a.games)
  );

  return heroes
    .filter(h => h.games >= minGames)
    .slice(0, 3)
    .map(h => {
      const c = heroesConst[h.hero_id];
      return {
        ...h,
        name: c?.localized_name || `hero_${h.hero_id}`,
        img: c?.img ? 'https://api.opendota.com' + c.img : null
      };
    });
}

    // ---- –†–µ–Ω–¥–µ—Ä UI (–æ–Ω–æ–≤–ª–µ–Ω–∏–π —â–æ–± –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ role card)
    function renderMatches(matches, heroesConst){ const tbody=document.querySelector('#matchesTable tbody'); tbody.innerHTML=''; matches.forEach(m=>{ const tr=document.createElement('tr'); const d=new Date((m.start_time||0)*1000); const hid=m.hero_id||0; const heroName = heroesConst && heroesConst[hid] ? heroesConst[hid].localized_name : hid; tr.innerHTML=`<td>${d.toLocaleString()}</td><td>${heroName}</td><td>${m.kills||0}/${m.deaths||0}/${m.assists||0}</td><td>${playerWon(m)?'W':'L'}</td><td>${secsToMinSecs(m.duration||0)}</td>`; tbody.appendChild(tr); }); }

    function renderPredictionUI(summary, result){
      document.getElementById('statsSummary').innerText = `–Ü–≥–æ—Ä: ${summary.games} ¬∑ Winrate: ${summary.winrate.toFixed(1)}% ¬∑ Avg K/D/A: ${summary.avgK.toFixed(2)}/${summary.avgD.toFixed(2)}/${summary.avgA.toFixed(2)} ¬∑ Avg KDA: ${summary.avgKDA.toFixed(2)} ¬∑ Avg —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: ${Math.round(summary.avgDuration/60)} —Ö–≤`;
      const p=document.getElementById('predictionArea');
      p.className='prediction '+(result.winProb>60?'pred-good':result.winProb<40?'pred-bad':'pred-neutral');
      p.innerHTML=`<strong>–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–º–æ–≥–∏ (–±–µ–∑ —Ä–æ–ª—ñ): ${result.winProb}%</strong><div class="small">–ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞: ${Math.round(result.predictedLength/60)} —Ö–≤</div>`;
      const det=document.getElementById('predictionDetails');
      det.innerHTML=`<div class="reason"><strong>–®–∞–Ω—Å–∏ (–º–æ–¥–µ–ª—å)</strong><div class="small">–ë—É—Å—Ç–µ—Ä (–º–æ—ó): ${result.boosterMy}% ¬∑ –†—É—ñ–Ω–µ—Ä (–º–æ—ó): ${result.ruinerMy}%<br>–ë—É—Å—Ç–µ—Ä (–≤–æ—Ä–æ–≥): ${result.boosterEnemy}% ¬∑ –†—É—ñ–Ω–µ—Ä (–≤–æ—Ä–æ–≥): ${result.ruinerEnemy}%</div></div>`;
    }

    // ---- –ü–æ–±—É–¥–æ–≤–∞ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ —á–µ—Ä–µ–∑ Chart.js
    let chartDays=null, chartHours=null;
    function buildChartsExtended(patterns) {
  // –û—á–∏—â–µ–Ω–Ω—è –æ–±–ª–∞—Å—Ç—ñ
  const chartArea = document.getElementById('chartArea');
  chartArea.innerHTML = `
    <div class="card" style="margin-top:20px;">
      <h3 style="text-align:center;">üìä –ì—Ä–∞—Ñ—ñ–∫–∏ –¥–∏–Ω–∞–º—ñ–∫–∏</h3>
      <div class="chart-container" style="display:grid;grid-template-columns:1fr;gap:30px;margin-top:20px;">
        <canvas id="roleChart" height="200"></canvas>
        <canvas id="dayChart" height="200"></canvas>
        <canvas id="hourChart" height="200"></canvas>
      </div>
    </div>
  `;

  // ---- –î–∞–Ω—ñ –¥–ª—è —Ä–æ–ª–µ–π
  const roleLabels = Object.keys(patterns.roleRates || {});
  const roleData = Object.values(patterns.roleRates || {}).map(r => r.winrate);

  // ---- –î–∞–Ω—ñ –ø–æ –¥–Ω—è—Ö
  const dayLabels = ['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–ù–¥'];
  const dayData = dayLabels.map(d => {
    const item = patterns.dayRates.find(x => x.name === d);
    return item ? item.winrate : null;
  });

  // ---- –î–∞–Ω—ñ –ø–æ –≥–æ–¥–∏–Ω–∞—Ö
  const hourLabels = Array.from({length:24}, (_,i)=>i+':00');
  const hourData = hourLabels.map(h=>{
    const hourNum = parseInt(h);
    const item = patterns.hourRates.find(x=>x.hour===hourNum);
    return item ? item.winrate : null;
  });

  // ---- –°—Ç–∏–ª—å –≥—Ä–∞—Ñ—ñ–∫—ñ–≤
  const commonOpts = {
    responsive: true,
    plugins: {
      legend: { labels:{ color:'#ccc' } },
      tooltip: { mode: 'index', intersect: false }
    },
    scales: {
      x: { ticks:{ color:'#aaa' }, grid:{ color:'#333' } },
      y: { ticks:{ color:'#aaa' }, grid:{ color:'#333' }, beginAtZero:true, max:100 }
    }
  };

  // ---- –ì—Ä–∞—Ñ—ñ–∫ —Ä–æ–ª–µ–π
  new Chart(document.getElementById('roleChart'), {
    type: 'bar',
    data: {
      labels: roleLabels,
      datasets: [{
        label: 'Winrate –ø–æ —Ä–æ–ª—è—Ö (%)',
        data: roleData,
        borderColor: '#00bcd4',
        backgroundColor: 'rgba(0,188,212,0.4)',
        borderWidth: 2
      }]
    },
    options: commonOpts
  });

  // ---- –ì—Ä–∞—Ñ—ñ–∫ –¥–Ω—ñ–≤
  new Chart(document.getElementById('dayChart'), {
    type: 'line',
    data: {
      labels: dayLabels,
      datasets: [{
        label: 'Winrate –ø–æ –¥–Ω—è—Ö (%)',
        data: dayData,
        borderColor: '#4caf50',
        backgroundColor: 'rgba(76,175,80,0.2)',
        tension: 0.3,
        fill: true
      }]
    },
    options: commonOpts
  });

  // ---- –ì—Ä–∞—Ñ—ñ–∫ –≥–æ–¥–∏–Ω
  new Chart(document.getElementById('hourChart'), {
    type: 'line',
    data: {
      labels: hourLabels,
      datasets: [{
        label: 'Winrate –ø–æ –≥–æ–¥–∏–Ω–∞—Ö (%)',
        data: hourData,
        borderColor: '#ff9800',
        backgroundColor: 'rgba(255,152,0,0.2)',
        tension: 0.3,
        fill: true
      }]
    },
    options: commonOpts
  });
}

// üîπ –†–æ–∑—à–∏—Ä—é—î–º–æ analyzePatterns(), —â–æ–± –¥–æ–¥–∞—Ç–∏ –¥–∞–Ω—ñ –ø–æ —Ä–æ–ª—è—Ö
const oldAnalyzePatterns = analyzePatterns;
analyzePatterns = function(matches, summary, heroesConst){
  const result = oldAnalyzePatterns(matches, summary, heroesConst);

  // –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ winrate –ø–æ —Ä–æ–ª—è—Ö
  const roleMap = {};
  matches.forEach(m=>{
    if(!m.player_slot) return;
    const roleName = m.lane_role===1 ? 'Carry' :
                     m.lane_role===2 ? 'Mid' :
                     m.lane_role===3 ? 'Offlane' :
                     m.lane_role===4 ? 'Support' :
                     m.lane_role===5 ? 'Hard Supp' : '–Ü–Ω—à–µ';
    if(!roleMap[roleName]) roleMap[roleName]={games:0,wins:0};
    roleMap[roleName].games++;
    if(m.radiant_win === (m.player_slot < 128)) roleMap[roleName].wins++;
  });

  result.roleRates = {};
  Object.entries(roleMap).forEach(([role,v])=>{
    result.roleRates[role]={winrate:(v.wins/v.games*100).toFixed(1)};
  });

  return result;
};

// üîπ –í–∏–∫–ª–∏–∫–∞—î–º–æ extended buildCharts —É renderPatternsUI
const oldRenderPatternsUI = renderPatternsUI;
renderPatternsUI = function(patterns) {
  oldRenderPatternsUI(patterns);
  buildChartsExtended(patterns);
};

    function renderPatternsUI(patterns){ document.getElementById('patterns').style.display='block'; const pt=document.getElementById('patternText'); pt.innerHTML='';
      const seqRoot=document.createElement('div'); seqRoot.innerHTML='<strong>–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ W/L</strong>';
      patterns.seqPatterns.forEach(p=>{ const div=document.createElement('div'); div.className='reason'; div.textContent = `–ü—ñ—Å–ª—è ${p.n} –ø–æ—Ä–∞–∑–æ–∫ –ø–æ—Å–ø—ñ–ª—å (${p.total} –≤–∏–ø–∞–¥–∫—ñ–≤) –Ω–∞—Å—Ç—É–ø–Ω–∞ –≥—Ä–∞ –±—É–ª–∞ –ø–µ—Ä–µ–º–æ–≥–æ—é —É ${p.prob}% –≤–∏–ø–∞–¥–∫—ñ–≤.`; seqRoot.appendChild(div); });
      pt.appendChild(seqRoot);
      const durRoot=document.createElement('div'); durRoot.innerHTML='<strong>–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —ñ winrate</strong>';
      durRoot.appendChild(Object.assign(document.createElement('div'),{className:'reason',textContent:`–ö–æ—Ä–æ—Ç–∫—ñ —ñ–≥—Ä–∏ (<25—Ö–≤) winrate: ${patterns.shortWinrate?patterns.shortWinrate.toFixed(1):0}%` }));
      durRoot.appendChild(Object.assign(document.createElement('div'),{className:'reason',textContent:`–î–æ–≤–≥—ñ —ñ–≥—Ä–∏ (>45—Ö–≤) winrate: ${patterns.longWinrate?patterns.longWinrate.toFixed(1):0}%` }));
      pt.appendChild(durRoot);
      const phaseRoot=document.createElement('div');
      phaseRoot.innerHTML='<strong>–§–∞–∑–∏ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è —ñ–≥–æ—Ä</strong>';
      patterns.phases.forEach(p=>{ const div=document.createElement('div'); div.className='reason'; div.textContent = `${p.name}: ${p.games} —ñ–≥–æ—Ä ¬∑ Winrate: ${p.winrate ? p.winrate.toFixed(1) : 0}%`; phaseRoot.appendChild(div); });
      pt.appendChild(phaseRoot);
      const topRoot=document.getElementById('topHeroes'); topRoot.innerHTML=''; if(patterns.top3.length===0){ topRoot.innerHTML='<div class="small">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —ñ–≥–æ—Ä –Ω–∞ –≥–µ—Ä–æ—è—Ö (min 2)</div>'; } else { patterns.top3.forEach(h=>{ const el=document.createElement('div'); el.className='hero-item'; const img=document.createElement('img'); img.src = h.img || ''; img.alt=h.name; const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:600">${h.name}</div><div class="small">Winrate: ${h.winrate.toFixed(1)}% ¬∑ –Ü–≥–æ—Ä: ${h.games}</div>`; el.appendChild(img); el.appendChild(info); topRoot.appendChild(el); }); }
    }

    // ---- New: render role prediction card (fills bars & texts)
    function showRoleCard(summary, baseResult){
      const card = document.getElementById('rolePredictionCard');
      card.style.display = 'block';
      // default render using current role select
      updateRoleCard(summary, baseResult);
    }

    function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

    function updateRoleCard(summary, baseResult){
      const role = Number(document.getElementById('roleSelect').value || 3);
      const resultWithRole = computeDetailedProbabilities(summary, role);
      // win percent
      const winP = resultWithRole.winProb;
      document.getElementById('winPercent').innerText = winP + '%';

      // boosters/ruiners
      setBar('boosterMy', resultWithRole.boosterMy);
      setBar('ruinerMy', resultWithRole.ruinerMy);
      setBar('boosterEnemy', resultWithRole.boosterEnemy);
      setBar('ruinerEnemy', resultWithRole.ruinerEnemy);

      // Winstreak (3+): simple independent estimate: p^3
      const p = winP/100;
      const winstreakPct = Math.round(Math.pow(p,3) * 10000)/100; // 2 decimals
      const losestreakPct = Math.round(Math.pow(1-p,3) * 10000)/100;
      setBar('winstreak', winstreakPct);
      setBar('losestreak', losestreakPct);

      // notes / reasons
      const notes = [];
      notes.push(`–†–æ–ª—å: ${role} (–º–∞–ª–∞ –∫–æ—Ä–µ–∫—Ü—ñ—è –º–æ–¥–µ–ª—ñ).`);
      notes.push(`–ë–∞–∑–æ–≤–∏–π —à–∞–Ω—Å (–º–æ–¥–µ–ª—å): ${baseResult.winProb}% ¬∑ –ü—ñ—Å–ª—è —Ä–æ–ª—ñ: ${winP}%`);
      notes.push(`–û—Ü—ñ–Ω–∫–∏ –±—É—Å—Ç–µ—Ä—ñ–≤/—Ä—É—ñ–Ω–µ—Ä—ñ–≤ ‚Äî —ñ–Ω–¥–µ–∫—Å –≤—ñ–¥ 1 –¥–æ 95 (–≤—ñ–∑—É–∞–ª—ñ–∑–æ–≤–∞–Ω–æ —è–∫ %).`);
      document.getElementById('roleNotes').innerText = notes.join(' ¬∑ ');
    }

    function setBar(id, pct){
      const textEl = document.getElementById('text_' + id);
      const barEl = document.getElementById('bar_' + id);
      if(!textEl || !barEl) return;
      const v = clamp(Number(pct) || 0, 0, 100);
      textEl.innerText = v.toFixed(1) + '%';
      barEl.style.width = v + '%';
      // color variant depending on value
      const parent = document.getElementById('stat_' + id);
      if(parent){
        parent.classList.remove('good','bad','neutral');
        if(v >= 60) parent.classList.add('good');
        else if(v <= 35) parent.classList.add('bad');
        else parent.classList.add('neutral');
      }
    }

    // ---- –ü–æ—à—É–∫ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç–µ–π / –ø–æ–¥—ñ—ó –∫–Ω–æ–ø–æ–∫
    let lastMatches=null, lastSummary=null, lastHeroesConst=null;
    document.getElementById('demoBtn').addEventListener('click', ()=>{ document.getElementById('idInput').value='863386335'; });

    document.getElementById('fetchBtn').addEventListener('click', async ()=>{
      const raw=document.getElementById('idInput').value.trim(); if(!raw) return alert('–í–≤–µ–¥—ñ—Ç—å ID');
      const id = raw.length>12? steam64ToAccountId(raw): Number(raw); if(isNaN(id)) return alert('–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ ID');
      const limit = Number(document.getElementById('limitSelect').value);
      document.getElementById('predictionArea').textContent='–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...';
      try{
        const [matches, heroesConstRaw] = await Promise.all([ fetchOpenDotaMatches(id, limit), fetchHeroesConstants() ]);
        const heroesConst = {};
        Object.values(heroesConstRaw).forEach(h=>{ if(h.id!==undefined) heroesConst[h.id]=h; });
        lastMatches = matches; lastSummary = analyzeMatches(matches); lastHeroesConst = heroesConst;
        const baseResult = computeDetailedProbabilities(lastSummary); // base (role default 3 inside function)
        renderMatches(matches, heroesConst);
        renderPredictionUI(lastSummary, baseResult);
        // show role card and wire role change
        showRoleCard(lastSummary, baseResult);
        document.getElementById('roleSelect').onchange = ()=> updateRoleCard(lastSummary, baseResult);
        // hide patterns until user presses button
        document.getElementById('patterns').style.display='none';
        // reset charts area (will be built on patterns)
      }catch(err){ console.error(err); document.getElementById('predictionArea').textContent='–ü–æ–º–∏–ª–∫–∞: '+err.message; }
    });

    document.getElementById('patternsBtn').addEventListener('click', async ()=>{
      if(!lastMatches || !lastSummary){ alert('–°–ø–æ—á–∞—Ç–∫—É –æ—Ç—Ä–∏–º–∞–π—Ç–µ –ø—Ä–æ–≥–Ω–æ–∑ (–Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑").'); return; }
      try{ const analysis = analyzePatterns(lastMatches, lastSummary, lastHeroesConst); buildChartsExtended(analysis.dayRates, analysis.hourRates); renderPatternsUI(analysis); }catch(err){ console.error(err); alert('–ü—Ä–æ–±–ª–µ–º–∞ –ø—Ä–∏ –ø–æ–±—É–¥–æ–≤—ñ –∑–∞–∫–æ–Ω–æ–º—ñ—Ä–Ω–æ—Å—Ç–µ–π: '+err.message); }
    });

    // ---- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è (–Ω–µ–º–∞—î)
  </script>
</body>
</html>

